

begin, , , carro_vacio_carro

// ------------------------ Instanciando una nueva lista atributo --------------------
+, P, 0, t1; //pos this
=>, t1, t2, stack; // obtenienido apuntador al heap para la lista
=>, t2, t3, heap; //apauntador al heap para el objeto
+, t3, 0, t4; // pos donde inicia la lista
<=, t4, H, heap;
<=, H, -1, heap; // ingresando el size de la lista
+, H, 1, H;
<=, H, -1, heap; // ingresando el apuntador nulo a la lista
+, H, 3, H;

end, , carro_vacio_carro




begin, , , persona_PRINCIPAL

// ------------------------ Creando arreglo local nombre
+, P, 0, t5; //pos de arreglo nombre
<=, t5, H, stack; // ingrensando al stack apunt del heap para nombre
+, H, 1, t6;
<=, H, t6, heap; //insetnado donde inicia el arreglo nombre
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t7; //calculando el n real
-, t7, 0, t8; //iReal columna 0
+, t8, 1, t8; //size del arreglo nombre
<=, H, t8, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, h, t8, h; // reservnado el espacio del arreglo nombre
+, P, 0, t11; // pos del arreglo 
=>, t11, t12, stack; //apuntador al heap del arreglo
=>, t12, t13, heap; // apuntador del heap al heap donde inicia la cadena
=>, t13, t9, heap; // size del arreglo nombre
+, t13, 1, t10; // pos 0 donde inicia el arreglo nombre
// Resolviendo una cadena 
+, H, 0, t14; //apuntaodr a cadena 
+, H, 1, t15; //apu donde inicia la cadena
<=, t14, t15, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 12, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t16; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 85, heap; //guardadndo U
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t14, t17, heap; // pos que apunta al size de la cadena
=>, t17, t18, heap; // size de la cadena
+, t17, 1, t19; // Pos 0 de la cadena
=>, t19, t20, heap; // sacandor el caracter del heap cadena
jle, t18, t9, L1;
jmp, , , L2;
jmp, , , L1;
L1:
jne, t20, 34, L3;
jmp, , , L4;
jmp, , , L3;
L3:
<=, t10, t20, heap; // guardando el caracter 
+, t10, 1, t10; // incremnetnado la pos del arreglo
+, t19, 1, t19; // incrementando la pos de la cadena
=>, t19, t20, heap; // sacandor el caracter del heap cadena
jmp, , , L1;
jmp, , , L4;
L4:
jmp, , , L2;
L2:
// ----------------- Resolviendo acceso local 
+, P, 0, t21; // pos del objeto
=>, t21, t22, stack; //apuntador al heap del obejto
=>, t22, t23, heap; // pos donde inicial el objeto nombre
=>, t23, t24, heap; // obteneindio el size del arreglo 
print("%d", t24);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t25; // pos de i
<=, t25, 0, stack; // asignando a i
// Resolviendo un repetur mientras
jmp, , ,L5; //regresando a la etiqueral del ciclo repetir- mientras
L5:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t26; // pos de i
=>, t26, t27, stack; // valor de lo que trae en el stack i
// ----------------- Resolviendo acceso local 
+, P, 0, t28; // pos del objeto
=>, t28, t29, stack; //apuntador al heap del obejto
=>, t29, t30, heap; // pos donde inicial el objeto nombre
=>, t30, t31, heap; // obteneindio el size del arreglo 
jl, t27, t31, L6;
jmp, , , L7;
L6:

+, P, 0, t32; // pos de arreglo nombre
=>, t32, t33, stack; // apunt al heap de arreglo nombre
=>, t33, t34, heap; //apunt al heap donde inicia el arreglo nombre
=>, t34, t35, heap; //obteniendo el tamanio del arreglo nombre
+, t34, 1, t36; // pos 0 del arreglo nombre
// ---- Calculo de valor de las posiciones  
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t37; // pos de i
=>, t37, t38, stack; // valor de lo que trae en el stack i
// -----------(Obteniendo valor) Calculo de iReal para el arreglo nombre
-, t38, 0, t39; //calculando el n real ()
-, t39, 0, t40; //iReal columna 0
+, t36, t40, t41; // pos buscada del arreglo  nombre
=>, t41, t42, heap; //valor que trae el objeto
print("%c", t42);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t43; // pos de i
=>, t43, t44, stack; //obtenidoe el valor de i
+, t44, 1, t45;
<=, t43, t45, stack; // asignando a i
jmp, , ,L5; //regresando a la etiqueral del ciclo repetir mientras
L7:


end, , persona_PRINCIPAL




begin, , , persona_vacio_persona

// ----------- Instancia a un atributo --------------
+, p, 0, t46;// pos this de c
=>, t46, t47, stack; //apuntador del heap de c
=>, t47, t48, heap; //posicion real del heap donde inicia c
+, t48, 0, t49; //pos real del atributo c
<=, t49, h, heap; //guardando la pos real donde inicia el objeto c
+, h, 1, h; // reservando el espacio de memoria para el nuevo objeto c

// Guardando la referencia al this del objeto para la llamada al constructor c
+, p, 0, t50;
=>, t50, t51, stack; //apuntador al heap de c
=>, t51, t52, heap; //posicion real donde incia el objeto c
+, t52, 0, t53; // pos real donde incial el objeto c

+, p, 2, t54; // tamanho de la funcion actual persona_vacio_persona
+, t54, 0, t55; // pos del this para la nueva instancia de c
<=, t55, t53, stack; //guaradndo el puntero del this en el stack 

// No posee parametros 
+, p, 2, p; // simulando cambio de ambito
call, , , carro_vacio_carro;
-, p, 2, p; // regresando al ambito acutal

// Resolviendo un acceso para un atrinuto
+, P, 0, t56; 
=>, t56, t57, stack; // apuntador al heap
=>, t57, t58, heap;
+, t58, 0, t59; 
=>, t59, t60, heap; // recuperando pos incial del objeto
+, t60, 0, t61;
=>, t61, t60, heap; // pos inicial de otro objeto o valor de una vairble comun 
//-------------- Apiladndo elemento 
+, t60, 0, t62; // posicion de; size de una lista
=>, t62, t63, heap; // valor del size de una lista
+, t62, 1, t64; // pos de puntero
=>, t64, t65, heap; //valor del puntero
+, t64, 1, t66; // pos del indice
+, t66, 1, t67; // pos del valor
jmp, , , L8;
L8:
je, t65, -1, L9;
jmp, , , L10;
jmp, , ,L9;
L9:
+, t63, 1, t63; // incrementandor en uno el size de la lista
<=, t62, t63, heap; // guarnado el size de la lista
<=, t64, H, heap; // guardando el nuevo apuntador 
<=, t66, t63, heap; // guarando el indice del nuevo elemento
<=, t67, 100, heap; // guardando el valor del nuevo insert en la lista
<=, H, -1, heap; // ingresando el nulo del atributo siguiente
+, H, 3, H; // incrementado el h
jmp, , , L11;
jmp, , , L10;
L10:
+, t65, 0, t64; // pos del apuntador
=>, t64, t65, heap; // valor del apuntador
+, t64, 1, t66; // pos del indice
+, t66, 1, t67; //pos valor 
jmp, , , L8;
jmp, , , L11;
L11:
print("%d", t63);
// Resolviendo un acceso para un atrinuto
+, P, 0, t68; 
=>, t68, t69, stack; // apuntador al heap
=>, t69, t70, heap;
+, t70, 0, t71; 
=>, t71, t72, heap; // recuperando pos incial del objeto
+, t72, 0, t73;
=>, t73, t72, heap; // pos inicial de otro objeto o valor de una vairble comun 
//-------------- Apiladndo elemento 
+, t72, 0, t74; // posicion de; size de una lista
=>, t74, t75, heap; // valor del size de una lista
+, t74, 1, t76; // pos de puntero
=>, t76, t77, heap; //valor del puntero
+, t76, 1, t78; // pos del indice
+, t78, 1, t79; // pos del valor
jmp, , , L12;
L12:
je, t77, -1, L13;
jmp, , , L14;
jmp, , ,L13;
L13:
+, t75, 1, t75; // incrementandor en uno el size de la lista
<=, t74, t75, heap; // guarnado el size de la lista
<=, t76, H, heap; // guardando el nuevo apuntador 
<=, t78, t75, heap; // guarando el indice del nuevo elemento
<=, t79, 200, heap; // guardando el valor del nuevo insert en la lista
<=, H, -1, heap; // ingresando el nulo del atributo siguiente
+, H, 3, H; // incrementado el h
jmp, , , L15;
jmp, , , L14;
L14:
+, t77, 0, t76; // pos del apuntador
=>, t76, t77, heap; // valor del apuntador
+, t76, 1, t78; // pos del indice
+, t78, 1, t79; //pos valor 
jmp, , , L12;
jmp, , , L15;
L15:
print("%d", t75);
// Resolviendo un acceso para un atrinuto
+, P, 0, t80; 
=>, t80, t81, stack; // apuntador al heap
=>, t81, t82, heap;
+, t82, 0, t83; 
=>, t83, t84, heap; // recuperando pos incial del objeto
+, t84, 0, t85;
=>, t85, t84, heap; // pos inicial de otro objeto o valor de una vairble comun 
//-------------- Apiladndo elemento 
+, t84, 0, t86; // posicion de; size de una lista
=>, t86, t87, heap; // valor del size de una lista
+, t86, 1, t88; // pos de puntero
=>, t88, t89, heap; //valor del puntero
+, t88, 1, t90; // pos del indice
+, t90, 1, t91; // pos del valor
jmp, , , L16;
L16:
je, t89, -1, L17;
jmp, , , L18;
jmp, , ,L17;
L17:
+, t87, 1, t87; // incrementandor en uno el size de la lista
<=, t86, t87, heap; // guarnado el size de la lista
<=, t88, H, heap; // guardando el nuevo apuntador 
<=, t90, t87, heap; // guarando el indice del nuevo elemento
<=, t91, 300, heap; // guardando el valor del nuevo insert en la lista
<=, H, -1, heap; // ingresando el nulo del atributo siguiente
+, H, 3, H; // incrementado el h
jmp, , , L19;
jmp, , , L18;
L18:
+, t89, 0, t88; // pos del apuntador
=>, t88, t89, heap; // valor del apuntador
+, t88, 1, t90; // pos del indice
+, t90, 1, t91; //pos valor 
jmp, , , L16;
jmp, , , L19;
L19:
print("%d", t87);
// Resolviendo un acceso para un atrinuto
+, P, 0, t92; 
=>, t92, t93, stack; // apuntador al heap
=>, t93, t94, heap;
+, t94, 0, t95; 
=>, t95, t96, heap; // recuperando pos incial del objeto
+, t96, 0, t97;
=>, t97, t96, heap; // pos inicial de otro objeto o valor de una vairble comun 
+, t96, 0, t98; // posicion de; size de una lista
=>, t98, t99, heap; // valor del size de una lista
+, t98, 1, t100; // pos de puntero
=>, t100, t101, heap; //valor del puntero
+, t100, 1, t102; // pos del indice
+, t102, 1, t103; // pos del valor
=>, t102, t104, heap; // valor del indice actual
-, t99, 1, t107; // siguiente poscions a la que apuntara la cabeza de la pila
// ------ funcion desapilar de una pila  ---
jge, t107, 0, L20;
jmp, , , L21;
jmp, , , L20;
L20:
je, t107, t104, L22;
jmp, , , L23;
jmp, , , L22;
L22:
+, t100, 0, t106; // pos del puntero donde insertarmemos un nulo
+, t101, 0, t100;
=>, t100, t101, heap; // val del punteor del siguiente elmento
+, t100, 1, t102;
+, t102, 1, t103;
=>, t102, t104, heap; //valor del proximo indice
<=, t106, -1, heap; // direccionando a nulo (nueva cabeza de al pila)
jmp, , , L20;
jmp, , , L23;
L23:
je, t99, t104, L24;
jmp, , , L25;
jmp, , , L24;
L24:
=>, t103, t96, heap; // valor de la posicion que saldra de la pila
<=, t98, t107, heap; // cambiando el size de la pila
jmp, , , L26;
jmp, , , L25;
L25:
+, t101, 0, t100;
=>, t100, t101, heap; // val del punteor del siguiente elmento
+, t100, 1, t102;
+, t102, 1, t103;
=>, t102, t104, heap; //valor del proximo indice
jmp, , , L20;
jmp, , , L26;
L26:
jmp, , , L21;
L21:
print("%d", t96);
// Resolviendo un acceso para un atrinuto
+, P, 0, t108; 
=>, t108, t109, stack; // apuntador al heap
=>, t109, t110, heap;
+, t110, 0, t111; 
=>, t111, t112, heap; // recuperando pos incial del objeto
+, t112, 0, t113;
=>, t113, t112, heap; // pos inicial de otro objeto o valor de una vairble comun 
+, t112, 0, t114; // posicion de; size de una lista
=>, t114, t115, heap; // valor del size de una lista
+, t114, 1, t116; // pos de puntero
=>, t116, t117, heap; //valor del puntero
+, t116, 1, t118; // pos del indice
+, t118, 1, t119; // pos del valor
=>, t118, t120, heap; // valor del indice actual
-, t115, 1, t123; // siguiente poscions a la que apuntara la cabeza de la pila
// ------ funcion desapilar de una pila  ---
jge, t123, 0, L27;
jmp, , , L28;
jmp, , , L27;
L27:
je, t123, t120, L29;
jmp, , , L30;
jmp, , , L29;
L29:
+, t116, 0, t122; // pos del puntero donde insertarmemos un nulo
+, t117, 0, t116;
=>, t116, t117, heap; // val del punteor del siguiente elmento
+, t116, 1, t118;
+, t118, 1, t119;
=>, t118, t120, heap; //valor del proximo indice
<=, t122, -1, heap; // direccionando a nulo (nueva cabeza de al pila)
jmp, , , L27;
jmp, , , L30;
L30:
je, t115, t120, L31;
jmp, , , L32;
jmp, , , L31;
L31:
=>, t119, t112, heap; // valor de la posicion que saldra de la pila
<=, t114, t123, heap; // cambiando el size de la pila
jmp, , , L33;
jmp, , , L32;
L32:
+, t117, 0, t116;
=>, t116, t117, heap; // val del punteor del siguiente elmento
+, t116, 1, t118;
+, t118, 1, t119;
=>, t118, t120, heap; //valor del proximo indice
jmp, , , L27;
jmp, , , L33;
L33:
jmp, , , L28;
L28:
print("%d", t112);

end, , persona_vacio_persona


