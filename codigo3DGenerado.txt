

begin, , , holis_vacio_holis_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t1; //pos this del arreglo
=>, t1, t2, stack; //obteniendo apuntador de arreglo en eel heap
=>, t2, t3, heap;//apuntando donde en verdad inicia el arreglo
+, t3, 0, t4; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t4, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 10, 1, t5; //calculando el n real
-, t5, 0, t6; //iReal columna 0
+, t6, 1, t6; //size del arreglo nombre
<=, H, t6, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t6, 0, t7; // anhadiendo una posicion mas
+, h, t7, h; // reservnado el espacio del arreglo nombre
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t8; // pos this 
=>, t8, t9, stack; // obtenido apuntador al heap 
=>, t9, t10, heap; // apuntador 
+, t10, 0, t11; // pos de nombre
=>, t11, t12, heap; // obtengo el valor que se encuentre en el heap 
+, P, 1, t13;
=>, t13, t14, stack; 
=>, t14, t15, heap; 
=>, t15, t16, heap; // valor de size del arreglo n
+, t15, 1, t17; // apuntador donde inicia el arreglo n
=>, t17, t18, heap; // primer caracter del arreglo n
+, H, 0, t19;
+, H, 1, t20;
<=, t19, t20, heap; 
+, H, 1, H;
+, 0, 0, t21;
<=, H, t21, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L2:
jne, t18, 36, L3;
jmp, , , L4;
L3:
<=, H, t18, heap; // ingresando el caracter 
+, H, 1, H;
+, t21, 1, t21; // incrementando en uno el size de la nueva cadena
+, t17, 1, t17;
=>, t17, t18, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L2;
L4:
<=, t20, t21, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t11, 1, t22;
// -------------------- Arreglo global asignar :) 
=>, t11, t23, heap; // inicia el arreglo
=>, t23, t24, heap; // size del arreglo 
+, t23, 1, t25; //Pos 0 del arreglo
=>, t19, t26, heap; // pos que apunta al size de la cadena
=>, t26, t27, heap; // size de la cadena
+, t26, 1, t28; // Pos 0 de la cadena
=>, t28, t29, heap; // sacandor el caracter del heap cadena
jle, t27, t24, L5;
jmp, , , L6;
jmp, , , L5;
L5:
jne, t29, 34, L7;
jmp, , , L8;
jmp, , , L7;
L7:
<=, t25, t29, heap; // guardando el caracter 
+, t25, 1, t25; // incremnetnado la pos del arreglo
+, t28, 1, t28; // incrementando la pos de la cadena
=>, t28, t29, heap; // sacandor el caracter del heap cadena
jmp, , , L5;
jmp, , , L8;
L8:
jmp, , , L6;
L6:
// Resolviendo una cadena 
+, H, 0, t30; //apuntaodr a cadena 
+, H, 1, t31; //apu donde inicia la cadena
<=, t30, t31, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 18, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t32; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 104, heap; //guardadndo h
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t30);
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t33; // pos this 
=>, t33, t34, stack; // obtenido apuntador al heap 
=>, t34, t35, heap; // apuntador 
+, t35, 0, t36; // pos de nombre
=>, t36, t37, heap; // obtengo el valor que se encuentre en el heap 
print("%a", t36);

L1:
end, , holis_vacio_holis_caracter




begin, , , individuo_vacio_individuo_entero_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t38; //pos this del arreglo
=>, t38, t39, stack; //obteniendo apuntador de arreglo en eel heap
=>, t39, t40, heap;//apuntando donde en verdad inicia el arreglo
+, t40, 0, t41; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t41, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 10, 1, t42; //calculando el n real
-, t42, 0, t43; //iReal columna 0
+, t43, 1, t43; //size del arreglo nombre
<=, H, t43, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t43, 0, t44; // anhadiendo una posicion mas
+, h, t44, h; // reservnado el espacio del arreglo nombre
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t45; // pos this 
=>, t45, t46, stack; // obtenido apuntador al heap 
=>, t46, t47, heap; // apuntador 
+, t47, 0, t48; // pos de nombre
=>, t48, t49, heap; // obtengo el valor que se encuentre en el heap 
+, P, 2, t50;
=>, t50, t51, stack; 
=>, t51, t52, heap; 
=>, t52, t53, heap; // valor de size del arreglo nom
+, t52, 1, t54; // apuntador donde inicia el arreglo nom
=>, t54, t55, heap; // primer caracter del arreglo nom
+, H, 0, t56;
+, H, 1, t57;
<=, t56, t57, heap; 
+, H, 1, H;
+, 0, 0, t58;
<=, H, t58, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L10:
jne, t55, 36, L11;
jmp, , , L12;
L11:
<=, H, t55, heap; // ingresando el caracter 
+, H, 1, H;
+, t58, 1, t58; // incrementando en uno el size de la nueva cadena
+, t54, 1, t54;
=>, t54, t55, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L10;
L12:
<=, t57, t58, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t48, 1, t59;
// -------------------- Arreglo global asignar :) 
=>, t48, t60, heap; // inicia el arreglo
=>, t60, t61, heap; // size del arreglo 
+, t60, 1, t62; //Pos 0 del arreglo
=>, t56, t63, heap; // pos que apunta al size de la cadena
=>, t63, t64, heap; // size de la cadena
+, t63, 1, t65; // Pos 0 de la cadena
=>, t65, t66, heap; // sacandor el caracter del heap cadena
jle, t64, t61, L13;
jmp, , , L14;
jmp, , , L13;
L13:
jne, t66, 34, L15;
jmp, , , L16;
jmp, , , L15;
L15:
<=, t62, t66, heap; // guardando el caracter 
+, t62, 1, t62; // incremnetnado la pos del arreglo
+, t65, 1, t65; // incrementando la pos de la cadena
=>, t65, t66, heap; // sacandor el caracter del heap cadena
jmp, , , L13;
jmp, , , L16;
L16:
jmp, , , L14;
L14:
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t67; // pos this 
=>, t67, t68, stack; // obtenido apuntador al heap 
=>, t68, t69, heap; // apuntador 
+, t69, 1, t70; // pos de edad
=>, t70, t71, heap; // obtengo el valor que se encuentre en el heap 
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t72; // pos de edad
=>, t72, t73, stack; // valor de lo que trae en el stack edad
<=, t70, t73, HEAP; // asignando variable 
// Resolviendo una cadena 
+, H, 0, t74; //apuntaodr a cadena 
+, H, 1, t75; //apu donde inicia la cadena
<=, t74, t75, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 34, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t76; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t74);
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t77; // pos this 
=>, t77, t78, stack; // obtenido apuntador al heap 
=>, t78, t79, heap; // apuntador 
+, t79, 0, t80; // pos de nombre
=>, t80, t81, heap; // obtengo el valor que se encuentre en el heap 
print("%a", t80);
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t82; // pos this 
=>, t82, t83, stack; // obtenido apuntador al heap 
=>, t83, t84, heap; // apuntador 
+, t84, 1, t85; // pos de edad
=>, t85, t86, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t86);
// ----------- Instancia a un atributo --------------
+, p, 0, t87;// pos this de g
=>, t87, t88, stack; //apuntador del heap de g
=>, t88, t89, heap; //posicion real del heap donde inicia g
+, t89, 2, t90; //pos real del atributo g
<=, t90, h, heap; //guardando la pos real donde inicia el objeto g
+, h, 1, h; // reservando el espacio de memoria para el nuevo objeto g

// Guardando la referencia al this del objeto para la llamada al constructor g
+, p, 0, t91;
=>, t91, t92, stack; //apuntador al heap de g
=>, t92, t93, heap; //posicion real donde incia el objeto g
+, t93, 2, t94; // pos real donde incial el objeto g

+, p, 4, t95; // tamanho de la funcion actual individuo_vacio_individuo_entero_caracter
+, t95, 0, t96; // pos del this para la nueva instancia de g
<=, t96, t94, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
// declarando parametros  arreglo de tipo n
// ------------------------ Creando arreglo local n
+, P, 1, t97; //pos de arreglo n
<=, t97, H, stack; // ingrensando al stack apunt del heap para n
+, H, 1, t98;
<=, H, t98, heap; //insetnado donde inicia el arreglo n
+, H, 1, H;
// calculando el tamanho del arreglo
-, 10, 1, t99; //calculando el n real
-, t99, 0, t100; //iReal columna 0
+, t100, 1, t100; //size del arreglo n
<=, H, t100, heap; // insertando el tamanio del arreglo linealizado n
+, H, 1, H;
+, h, t100, h; // reservnado el espacio del arreglo n
+, p, 4, t101; // size de funcion actual
+, t101, 1, t102; //pos del parametro 1
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t103; // pos this 
=>, t103, t104, stack; // obtenido apuntador al heap 
=>, t104, t105, heap; // apuntador 
+, t105, 0, t106; // pos de nombre
=>, t106, t107, heap; // obtengo el valor que se encuentre en el heap 
<=, t102, t106, stack; //  reerencia del arreglo asignado al stack el parametro
+, p, 4, p; // simulando cambio de ambito
call, , , holis_vacio_holis_caracter;
-, p, 4, p; // regresando al ambito acutal


L9:
end, , individuo_vacio_individuo_entero_caracter




begin, , , ejemplos_PRINCIPAL

// ------------------------ Creando arreglo local h
+, P, 0, t108; //pos de arreglo h
<=, t108, H, stack; // ingrensando al stack apunt del heap para h
+, H, 1, t109;
<=, H, t109, heap; //insetnado donde inicia el arreglo h
+, H, 1, H;
// calculando el tamanho del arreglo
-, 10, 1, t110; //calculando el n real
-, t110, 0, t111; //iReal columna 0
+, t111, 1, t111; //size del arreglo h
<=, H, t111, heap; // insertando el tamanio del arreglo linealizado h
+, H, 1, H;
+, h, t111, h; // reservnado el espacio del arreglo h
+, P, 0, t114; // pos del arreglo 
=>, t114, t115, stack; //apuntador al heap del arreglo
=>, t115, t116, heap; // apuntador del heap al heap donde inicia la cadena
=>, t116, t112, heap; // size del arreglo h
+, t116, 1, t113; // pos 0 donde inicia el arreglo h
// Resolviendo una cadena 
+, H, 0, t117; //apuntaodr a cadena 
+, H, 1, t118; //apu donde inicia la cadena
<=, t117, t118, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t119; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t117, t120, heap; // pos que apunta al size de la cadena
=>, t120, t121, heap; // size de la cadena
+, t120, 1, t122; // Pos 0 de la cadena
=>, t122, t123, heap; // sacandor el caracter del heap cadena
jle, t121, t112, L18;
jmp, , , L19;
jmp, , , L18;
L18:
jne, t123, 34, L20;
jmp, , , L21;
jmp, , , L20;
L20:
<=, t113, t123, heap; // guardando el caracter 
+, t113, 1, t113; // incremnetnado la pos del arreglo
+, t122, 1, t122; // incrementando la pos de la cadena
=>, t122, t123, heap; // sacandor el caracter del heap cadena
jmp, , , L18;
jmp, , , L21;
L21:
jmp, , , L19;
L19:
+, P, 0, t124;
=>, t124, t125, stack; 
=>, t125, t126, heap; 
=>, t126, t127, heap; // valor de size del arreglo h
+, t126, 1, t128; // apuntador donde inicia el arreglo h
=>, t128, t129, heap; // primer caracter del arreglo h
+, H, 0, t130;
+, H, 1, t131;
<=, t130, t131, heap; 
+, H, 1, H;
+, 0, 0, t132;
<=, H, t132, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L22:
jne, t129, 36, L23;
jmp, , , L24;
L23:
<=, H, t129, heap; // ingresando el caracter 
+, H, 1, H;
+, t132, 1, t132; // incrementando en uno el size de la nueva cadena
+, t128, 1, t128;
=>, t128, t129, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L22;
L24:
<=, t131, t132, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t130);
// ----------- Instancia a una variable local --------------
+, p, 1, t133; // pos de j
<=, t133, h, stack; //guardando referencia del heap para el objeto j
+, h, 1, t134; // guardo la posicion donde inicia el objeto 
<=, h, t134, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto j
//Ingresando referencia al this del objeto j
+, p, 1, t135; // pos de j
=>, t135, t136, stack; // obteniendo apuntador de j
+, p, 2, t137; // simulando cambio de ambito
+, t137, 0, t138; //pos del this de j
<=, t138, t136, stack; // insertando apuntador del heap al stack del obeto j
// Asignando parametros  
+, p, 2, t139; // size de funcion actual
+, t139, 1, t140; //pos del parametro 1
<=, t140, 25, stack; // asignado al stack el parametro
// declarando parametros  arreglo de tipo nom
// ------------------------ Creando arreglo local nom
+, P, 2, t141; //pos de arreglo nom
<=, t141, H, stack; // ingrensando al stack apunt del heap para nom
+, H, 1, t142;
<=, H, t142, heap; //insetnado donde inicia el arreglo nom
+, H, 1, H;
// calculando el tamanho del arreglo
-, 10, 1, t143; //calculando el n real
-, t143, 0, t144; //iReal columna 0
+, t144, 1, t144; //size del arreglo nom
<=, H, t144, heap; // insertando el tamanio del arreglo linealizado nom
+, H, 1, H;
+, h, t144, h; // reservnado el espacio del arreglo nom
+, p, 2, t145; // size de funcion actual
+, t145, 2, t146; //pos del parametro 2
// Resolviendo una cadena 
+, H, 0, t147; //apuntaodr a cadena 
+, H, 1, t148; //apu donde inicia la cadena
<=, t147, t148, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t149; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t146, t147, stack; // asignado al stack el parametro
+, p, 2, p; // simulando cambio de ambito
call, , , individuo_vacio_individuo_entero_caracter;
-, p, 2, p; // regresando al ambito acutal

// Resolviendo una cadena 
+, H, 0, t150; //apuntaodr a cadena 
+, H, 1, t151; //apu donde inicia la cadena
<=, t150, t151, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 28, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t152; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 45, heap; //guardadndo -
+, H, 1, H;
<=, H, 45, heap; //guardadndo -
+, H, 1, H;
<=, H, 45, heap; //guardadndo -
+, H, 1, H;
<=, H, 45, heap; //guardadndo -
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t150);
// ----------------- Resolviendo acceso local 
+, P, 1, t153; // pos del objeto
=>, t153, t155, stack; //apuntador al heap del obejto
=>, t155, t156, heap; // recuperando pos incial del objeto
+, t156, 0, t155;
=>, t155, t157, heap; // valor a retoranar del acceso
print("%a", t155);
// ----------------- Resolviendo acceso local 
+, P, 1, t158; // pos del objeto
=>, t158, t160, stack; //apuntador al heap del obejto
=>, t160, t161, heap; // recuperando pos incial del objeto
+, t161, 1, t160;
=>, t160, t162, heap; // valor a retoranar del acceso
print("%d", t162);

L17:
end, , ejemplos_PRINCIPAL




begin, , , ejemplos_vacio_ejemplos_individuo

// Resolviendo una cadena 
+, H, 0, t163; //apuntaodr a cadena 
+, H, 1, t164; //apu donde inicia la cadena
<=, t163, t164, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t165; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 104, heap; //guardadndo h
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t163);
// ----------------- Resolviendo acceso local 
+, P, 1, t166; // pos del objeto
=>, t166, t168, stack; //apuntador al heap del obejto
=>, t168, t169, heap; // recuperando pos incial del objeto
+, t169, 1, t168;
=>, t168, t170, heap; // valor a retoranar del acceso
print("%d", t170);
// ----------------- Resolviendo acceso local 
+, P, 1, t171; // pos del objeto
=>, t171, t173, stack; //apuntador al heap del obejto
=>, t173, t174, heap; // recuperando pos incial del objeto
+, t174, 0, t173;
=>, t173, t175, heap; // valor a retoranar del acceso
print("%a", t173);
// ------------------------ Creando arreglo local k
+, P, 2, t176; //pos de arreglo k
<=, t176, H, stack; // ingrensando al stack apunt del heap para k
+, H, 1, t177;
<=, H, t177, heap; //insetnado donde inicia el arreglo k
+, H, 1, H;
// calculando el tamanho del arreglo
-, 10, 1, t178; //calculando el n real
-, t178, 0, t179; //iReal columna 0
+, t179, 1, t179; //size del arreglo k
<=, H, t179, heap; // insertando el tamanio del arreglo linealizado k
+, H, 1, H;
+, h, t179, h; // reservnado el espacio del arreglo k
// ----------------- Resolviendo acceso local 
+, P, 1, t180; // pos del objeto
=>, t180, t182, stack; //apuntador al heap del obejto
=>, t182, t183, heap; // recuperando pos incial del objeto
+, t183, 0, t182;
=>, t182, t184, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t185; // pos de k
<=, t185, t182, stack; // cosa de direccion arreglo
// Resolviendo una cadena 
+, H, 0, t186; //apuntaodr a cadena 
+, H, 1, t187; //apu donde inicia la cadena
<=, t186, t187, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t188; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t186);
+, P, 2, t189;
=>, t189, t190, stack; 
=>, t190, t191, heap; 
=>, t191, t192, heap; // valor de size del arreglo k
+, t191, 1, t193; // apuntador donde inicia el arreglo k
=>, t193, t194, heap; // primer caracter del arreglo k
+, H, 0, t195;
+, H, 1, t196;
<=, t195, t196, heap; 
+, H, 1, H;
+, 0, 0, t197;
<=, H, t197, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L26:
jne, t194, 36, L27;
jmp, , , L28;
L27:
<=, H, t194, heap; // ingresando el caracter 
+, H, 1, H;
+, t197, 1, t197; // incrementando en uno el size de la nueva cadena
+, t193, 1, t193;
=>, t193, t194, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L26;
L28:
<=, t196, t197, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t195);
// ----------- Instancia a una variable local --------------
+, p, 3, t198; // pos de l
<=, t198, h, stack; //guardando referencia del heap para el objeto l
+, h, 1, t199; // guardo la posicion donde inicia el objeto 
<=, h, t199, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto l
//Ingresando referencia al this del objeto l
+, p, 3, t200; // pos de l
=>, t200, t201, stack; // obteniendo apuntador de l
+, p, 5, t202; // simulando cambio de ambito
+, t202, 0, t203; //pos del this de l
<=, t203, t201, stack; // insertando apuntador del heap al stack del obeto l
// Asignando parametros  
+, p, 5, t204; // size de funcion actual
+, t204, 1, t205; //pos del parametro 1
<=, t205, 12, stack; // asignado al stack el parametro
// declarando parametros  arreglo de tipo nom
// ------------------------ Creando arreglo local nom
+, P, 2, t206; //pos de arreglo nom
<=, t206, H, stack; // ingrensando al stack apunt del heap para nom
+, H, 1, t207;
<=, H, t207, heap; //insetnado donde inicia el arreglo nom
+, H, 1, H;
// calculando el tamanho del arreglo
-, 10, 1, t208; //calculando el n real
-, t208, 0, t209; //iReal columna 0
+, t209, 1, t209; //size del arreglo nom
<=, H, t209, heap; // insertando el tamanio del arreglo linealizado nom
+, H, 1, H;
+, h, t209, h; // reservnado el espacio del arreglo nom
+, p, 5, t210; // size de funcion actual
+, t210, 2, t211; //pos del parametro 2
+, P, 2, t212;
=>, t212, t213, stack; 
=>, t213, t214, heap; 
=>, t214, t215, heap; // valor de size del arreglo k
+, t214, 1, t216; // apuntador donde inicia el arreglo k
=>, t216, t217, heap; // primer caracter del arreglo k
+, H, 0, t218;
+, H, 1, t219;
<=, t218, t219, heap; 
+, H, 1, H;
+, 0, 0, t220;
<=, H, t220, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L29:
jne, t217, 36, L30;
jmp, , , L31;
L30:
<=, H, t217, heap; // ingresando el caracter 
+, H, 1, H;
+, t220, 1, t220; // incrementando en uno el size de la nueva cadena
+, t216, 1, t216;
=>, t216, t217, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L29;
L31:
<=, t219, t220, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, t211, t218, stack; // asignado al stack el parametro
+, p, 5, p; // simulando cambio de ambito
call, , , individuo_vacio_individuo_entero_caracter;
-, p, 5, p; // regresando al ambito acutal

// Resolviendo una cadena 
+, H, 0, t221; //apuntaodr a cadena 
+, H, 1, t222; //apu donde inicia la cadena
<=, t221, t222, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 9, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t223; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t221);
// ----------------- Resolviendo acceso local 
+, P, 3, t224; // pos del objeto
=>, t224, t226, stack; //apuntador al heap del obejto
=>, t226, t227, heap; // recuperando pos incial del objeto
+, t227, 1, t226;
=>, t226, t228, heap; // valor a retoranar del acceso
print("%d", t228);
// ----------------- Resolviendo acceso local 
+, P, 3, t229; // pos del objeto
=>, t229, t231, stack; //apuntador al heap del obejto
=>, t231, t232, heap; // recuperando pos incial del objeto
+, t232, 0, t231;
=>, t231, t233, heap; // valor a retoranar del acceso
print("%a", t231);
// Resolviendo una cadena 
+, H, 0, t234; //apuntaodr a cadena 
+, H, 1, t235; //apu donde inicia la cadena
<=, t234, t235, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 14, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t236; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t234);
// ----------------- Resolviendo acceso local 
+, P, 1, t237; // pos del objeto
=>, t237, t239, stack; //apuntador al heap del obejto
=>, t239, t240, heap; // recuperando pos incial del objeto
+, t240, 2, t239;
=>, t239, t241, heap; // recuperando pos incial del objeto
+, t241, 0, t239;
=>, t239, t242, heap; // valor a retoranar del acceso
print("%a", t239);
// ----------------- Resolviendo acceso local 
+, P, 3, t243; // pos del objeto
=>, t243, t245, stack; //apuntador al heap del obejto
=>, t245, t246, heap; // recuperando pos incial del objeto
+, t246, 0, t245;
=>, t245, t247, heap; // valor a retoranar del acceso
// Resolviendo una cadena 
+, H, 0, t248; //apuntaodr a cadena 
+, H, 1, t249; //apu donde inicia la cadena
<=, t248, t249, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t250; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t245, t251, heap; 
=>, t251, t252, heap; // size arreglo heap a convertir a cadena
+, t251, 1, t253; // pos actual del arreglo a convertir a cadena
=>, t253, t254, heap; // caracter acutal del arreglo a convertir
+, 0, 0, t255;
// ------------------------------ Iniciando cadena de una arreglo a convertir ---------
+, H, 0, t256; // referencia de la cadena
+, H, 1, t257; // valor de la cadena
<=, t256, t257, heap; 
+, H, 1, H; 
+, H, 0, t258;
+, H, 1, H; 
L35:
jne, t254, 36, L36;
jmp, , , L37;
L36:
<=, H, t254, heap; // insertarndo caracter 
+, H, 1, H; 
+, t255, 1, t255; // incrementando en 1 el contador de la cadena 
+, t253, 1, t253; // incrementando en 1 la posicion acutal de la cadena 
=>, t253, t254, heap; // caracter acutal del arreglo a convertir
jmp, , , L35;
L37:
<=, H, 34, heap; // insertarndo caracter de escape
+, H, 1, H; 
<=, t258, t255, heap; // insertando el size de la cadena 
// ------------ Obtenieido suma de caracteres de una cadena --------
=>, t256, t259, heap; // apunt al heap donde inicia la cadena
+, t259, 1, t260; // pos donde incia la cadena
=>, t260, t261, heap; // valor caracter  de la cadena
+, 0, 0, t262; //acumulador de la cadena
jmp, , , L38;
L38: //etiquera ciclo suma cadena
jne, t261, 34, L39;
jmp, , , L40;
L39:
+, t262, t261, t262; // sumando los caracteres 
+, t260, 1, t260; // sumando una posicion
=>, t260, t261, heap; // obteniendo el valor del caracter 
jmp, , , L38;
L40:
// ------------ Obtenieido suma de caracteres de una cadena --------
=>, t248, t263, heap; // apunt al heap donde inicia la cadena
+, t263, 1, t264; // pos donde incia la cadena
=>, t264, t265, heap; // valor caracter  de la cadena
+, 0, 0, t266; //acumulador de la cadena
jmp, , , L41;
L41: //etiquera ciclo suma cadena
jne, t265, 34, L42;
jmp, , , L43;
L42:
+, t266, t265, t266; // sumando los caracteres 
+, t264, 1, t264; // sumando una posicion
=>, t264, t265, heap; // obteniendo el valor del caracter 
jmp, , , L41;
L43:
jne, t262, t266, L33;
jmp, , , L34;
L33:

// Resolviendo una cadena 
+, H, 0, t267; //apuntaodr a cadena 
+, H, 1, t268; //apu donde inicia la cadena
<=, t267, t268, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t269; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t267);
jmp, , , L32; // salida del if
L34:

// Resolviendo una cadena 
+, H, 0, t270; //apuntaodr a cadena 
+, H, 1, t271; //apu donde inicia la cadena
<=, t270, t271, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 18, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t272; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 102, heap; //guardadndo f
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t270);
L32:

L25:
end, , ejemplos_vacio_ejemplos_individuo


