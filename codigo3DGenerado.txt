

begin, , , llanta_vacio_llanta_entero_entero

// Asignando atributo valor1Llanta
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de valor1Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de val1
=>, t5, t6, stack; // valor de lo que trae en el stack val1
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo valor2Llanta
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de valor2Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t11; // pos de val2
=>, t11, t12, stack; // valor de lo que trae en el stack val2
<=, t10, t12, heap; //guardando en el heap el valor del atributo

L1:
end, , llanta_vacio_llanta_entero_entero




begin, , , llanta_vacio_mostrarVAlor1

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t13; // pos this 
=>, t13, t14, stack; // obtenido apuntador al heap 
=>, t14, t15, heap; // apuntador 
+, t15, 0, t16; // pos de valor1Llanta
=>, t16, t17, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t17);

L2:
end, , llanta_vacio_mostrarVAlor1




begin, , , llanta_vacio_mostrarVAlor2

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t18; // pos this 
=>, t18, t19, stack; // obtenido apuntador al heap 
=>, t19, t20, heap; // apuntador 
+, t20, 1, t21; // pos de valor2Llanta
=>, t21, t22, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t22);

L3:
end, , llanta_vacio_mostrarVAlor2




begin, , , carro_vacio_carro_caracter_entero

// Asignando atributo col
+, p, 0, t23; //pos this 
=>, t23, t24, stack; // apuntador al heap
=>, t24, t25, heap; // apuntador donde inicia el objeto
+, t25, 0, t26; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t27; // pos de color
=>, t27, t28, stack; // valor de lo que trae en el stack color
<=, t26, t28, heap; //guardando en el heap el valor del atributo
print("%c", 89);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t29; // pos de rinLlanta
=>, t29, t30, stack; // valor de lo que trae en el stack rinLlanta
print("%d", t30);
// Asignando atributo valorCarro
+, p, 0, t31; //pos this 
=>, t31, t32, stack; // apuntador al heap
=>, t32, t33, heap; // apuntador donde inicia el objeto
+, t33, 2, t34; // pos real  de valorCarro
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t35; // pos de rinLlanta
=>, t35, t36, stack; // valor de lo que trae en el stack rinLlanta
<=, t34, t36, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t37;// pos this de lla1
=>, t37, t38, stack; //apuntador del heap de lla1
=>, t38, t39, heap; //posicion real del heap donde inicia lla1
+, t39, 1, t40; //pos real del atributo lla1
<=, t40, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t41;
=>, t41, t42, stack; //apuntador al heap de lla1
=>, t42, t43, heap; //posicion real donde incia el objeto lla1
+, t43, 1, t44; // pos real donde incial el objeto lla1

+, p, 4, t45; // tamanho de la funcion actual carro_vacio_carro_caracter_entero
+, t45, 0, t46; // pos del this para la nueva instancia de lla1
<=, t46, t44, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 4, t47; // size de funcion actual
+, t47, 1, t48; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t49; // pos de rinLlanta
=>, t49, t50, stack; // valor de lo que trae en el stack rinLlanta
*, t50, 2, t51;
<=, t48, t51, stack; // asignado al stack el parametro
+, p, 4, t52; // size de funcion actual
+, t52, 2, t53; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t54; // pos de rinLlanta
=>, t54, t55, stack; // valor de lo que trae en el stack rinLlanta
*, t55, 3, t56;
<=, t53, t56, stack; // asignado al stack el parametro
+, p, 4, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 4, p; // regresando al ambito acutal


L4:
end, , carro_vacio_carro_caracter_entero




begin, , , carro_caracter_obtenerColor

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t57; // pos this 
=>, t57, t58, stack; // obtenido apuntador al heap 
=>, t58, t59, heap; // apuntador 
+, t59, 0, t60; // pos de col
=>, t60, t61, heap; // obtengo el valor que se encuentre en el heap 
+, P, 1, t62; // pos de retorno de a funcion carro_caracter_obtenerColor
<=, t62, t61, stack; //asignando el retorno con su valor
jmp, , , L5;

L5:
end, , carro_caracter_obtenerColor




begin, , , carro_entero_obtenerValor

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t63; // pos this 
=>, t63, t64, stack; // obtenido apuntador al heap 
=>, t64, t65, heap; // apuntador 
+, t65, 2, t66; // pos de valorCarro
=>, t66, t67, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t67);
print("%c", 76);
// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t68; // pos this 
=>, t68, t69, stack; // obtenido apuntador al heap 
=>, t69, t70, heap; // apuntador 
+, t70, 2, t71; // pos de valorCarro
=>, t71, t72, heap; // obtengo el valor que se encuentre en el heap 
*, t72, 5, t73;
+, P, 1, t74; // pos de retorno de a funcion carro_entero_obtenerValor
<=, t74, t73, stack; //asignando el retorno con su valor
jmp, , , L6;

L6:
end, , carro_entero_obtenerValor




begin, , , carro_vacio_carro_caracter

// Asignando atributo col
+, p, 0, t75; //pos this 
=>, t75, t76, stack; // apuntador al heap
=>, t76, t77, heap; // apuntador donde inicia el objeto
+, t77, 0, t78; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t79; // pos de n
=>, t79, t80, stack; // valor de lo que trae en el stack n
<=, t78, t80, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t81;// pos this de lla1
=>, t81, t82, stack; //apuntador del heap de lla1
=>, t82, t83, heap; //posicion real del heap donde inicia lla1
+, t83, 1, t84; //pos real del atributo lla1
<=, t84, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t85;
=>, t85, t86, stack; //apuntador al heap de lla1
=>, t86, t87, heap; //posicion real donde incia el objeto lla1
+, t87, 1, t88; // pos real donde incial el objeto lla1

+, p, 3, t89; // tamanho de la funcion actual carro_vacio_carro_caracter
+, t89, 0, t90; // pos del this para la nueva instancia de lla1
<=, t90, t88, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 3, t91; // size de funcion actual
+, t91, 1, t92; //pos del parametro 1
<=, t92, 10, stack; // asignado al stack el parametro
+, p, 3, t93; // size de funcion actual
+, t93, 2, t94; //pos del parametro 2
<=, t94, 20, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 3, p; // regresando al ambito acutal


L7:
end, , carro_vacio_carro_caracter




begin, , , carro_vacio_imprimir_Color

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t95; // pos this 
=>, t95, t96, stack; // obtenido apuntador al heap 
=>, t96, t97, heap; // apuntador 
+, t97, 0, t98; // pos de col
=>, t98, t99, heap; // obtengo el valor que se encuentre en el heap 
print("%c", t99);

L8:
end, , carro_vacio_imprimir_Color




begin, , , persona_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t100; // pos de p1
<=, t100, h, stack; //guardando referencia del heap para el objeto p1
+, h, 1, t101; // guardo la posicion donde inicia el objeto 
<=, h, t101, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto p1
//Ingresando referencia al this del objeto p1
+, p, 0, t102; // pos de p1
=>, t102, t103, stack; // obteniendo apuntador de p1
+, p, 3, t104; // simulando cambio de ambito
+, t104, 0, t105; //pos del this de p1
<=, t105, t103, stack; // insertando apuntador del heap al stack del obeto p1
// Asignando parametros  
+, p, 3, t106; // size de funcion actual
+, t106, 1, t107; //pos del parametro 1
<=, t107, 25, stack; // asignado al stack el parametro
+, p, 3, t108; // size de funcion actual
+, t108, 2, t109; //pos del parametro 2
<=, t109, 80, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , persona_vacio_persona_entero_caracter;
-, p, 3, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t110; // pos del objeto
=>, t110, t112, stack; //apuntador al heap del obejto
+, P, 2, t113;
+, t113, 0, t114;
<=, t114, t112, stack; // pasadon como refeenria el valor del this
+, P, 2, P;
call, , , persona_entero_incrementarEdad;
+, P, 1, t115;
=>, t115, t116, stack; // valor del return
-, P, 2, P;
=>, t115, t117, stack; // valor a retoranar del acceso
print("%d", t117);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t118; // pos de valor1
// ----------------- Resolviendo acceso local 
+, P, 0, t119; // pos del objeto
=>, t119, t121, stack; //apuntador al heap del obejto
+, P, 3, t122;
+, t122, 0, t123;
<=, t123, t121, stack; // pasadon como refeenria el valor del this
+, P, 3, P;
call, , , persona_carro_retornoCarro;
+, P, 2, t124;
=>, t124, t125, stack; // valor del return
-, P, 3, P;
=>, t124, t126, stack; // recuperando pos incial del objeto
=>, t126, t126, heap; // apuntador inciail del objeto 
+, t126, 2, t124;
=>, t124, t127, heap; // valor a retoranar del acceso
<=, t118, t127, stack; // asignando a valor1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t128; // pos de valor1
=>, t128, t129, stack; // valor de lo que trae en el stack valor1
print("%d", t129);
// ------------------------ Creando arreglo local nombre
+, P, 2, t130; //pos de arreglo nombre
<=, t130, H, stack; // ingrensando al stack apunt del heap para nombre
+, H, 1, t131;
<=, H, t131, heap; //insetnado donde inicia el arreglo nombre
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t132; //calculando el n real
-, t132, 0, t133; //iReal columna 0
+, t133, 1, t133; //size del arreglo nombre
<=, H, t133, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, h, t133, h; // reservnado el espacio del arreglo nombre
// Resolviendo una cadena 
+, H, 0, t134; //apuntaodr a cadena 
+, H, 1, t135; //apu donde inicia la cadena
<=, t134, t135, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 12, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t136; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 85, heap; //guardadndo U
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 2, t139; // pos del arreglo 
=>, t139, t140, stack; //apuntador al heap del arreglo
=>, t140, t141, heap; // apuntador del heap al heap donde inicia la cadena
=>, t141, t137, heap; // size del arreglo nombre
+, t141, 1, t138; // pos 0 donde inicia el arreglo nombre
=>, t134, t142, heap; // pos que apunta al size de la cadena
=>, t142, t143, heap; // size de la cadena
+, t142, 1, t144; // Pos 0 de la cadena
=>, t144, t145, heap; // sacandor el caracter del heap cadena
jle, t143, t137, L10;
jmp, , , L11;
jmp, , , L10;
L10:
jne, t145, 34, L12;
jmp, , , L13;
jmp, , , L12;
L12:
<=, t138, t145, heap; // guardando el caracter 
+, t138, 1, t138; // incremnetnado la pos del arreglo
+, t144, 1, t144; // incrementando la pos de la cadena
=>, t144, t145, heap; // sacandor el caracter del heap cadena
jmp, , , L10;
jmp, , , L13;
L13:
jmp, , , L11;
L11:
+, P, 2, t146; // pos de arreglo nombre
=>, t146, t147, stack; // apunt al heap de arreglo nombre
=>, t147, t148, heap; //apunt al heap donde inicia el arreglo nombre
=>, t148, t149, heap; //obteniendo el tamanio del arreglo nombre
+, t148, 1, t150; // pos 0 del arreglo nombre
// ---- Calculo de valor de las posiciones  
// -----------(Obteniendo valor) Calculo de iReal para el arreglo nombre
-, 8, 0, t151; //calculando el n real ()
-, t151, 0, t152; //iReal columna 0
+, t150, t152, t153; // pos buscada del arreglo  nombre
=>, t153, t154, heap; //valor que trae el objeto
print("%c", t154);

L9:
end, , persona_PRINCIPAL




begin, , , persona_vacio_molestar

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t155; // pos this 
=>, t155, t156, stack; // obtenido apuntador al heap 
=>, t156, t157, heap; // apuntador 
+, t157, 0, t158; // pos de edad
=>, t158, t159, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t159);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t160; // pos de a
<=, t160, 189, stack; // asignando a a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t161; // pos de a
=>, t161, t162, stack; // valor de lo que trae en el stack a
print("%d", t162);
// RESOLVIENDO UN RETORNO
jmp, , , L14;
print("%c", 84);

L14:
end, , persona_vacio_molestar




begin, , , persona_carro_obtenerCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t163; // pos de c
<=, t163, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t164; // guardo la posicion donde inicia el objeto 
<=, h, t164, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t165; // pos de c
=>, t165, t166, stack; // obteniendo apuntador de c
+, p, 3, t167; // simulando cambio de ambito
+, t167, 0, t168; //pos del this de c
<=, t168, t166, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t169; // size de funcion actual
+, t169, 1, t170; //pos del parametro 1
<=, t170, 72, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t171; // pos de c
=>, t171, t172, stack; // valor de lo que trae en el stack c
+, P, 2, t173; // pos de retorno de a funcion persona_carro_obtenerCarro
<=, t173, t172, stack; //asignando el retorno con su valor
jmp, , , L15;

L15:
end, , persona_carro_obtenerCarro




begin, , , persona_entero_obtenernUmero

// RESOLVIENDO UN RETORNO
*, 5, 8, t174;
+, P, 1, t175; // pos de retorno de a funcion persona_entero_obtenernUmero
<=, t175, t174, stack; //asignando el retorno con su valor
jmp, , , L16;

L16:
end, , persona_entero_obtenernUmero




begin, , , persona_vacio_persona_entero_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t176; //pos this del arreglo
=>, t176, t177, stack; //obteniendo apuntador de arreglo en eel heap
=>, t177, t178, heap;//apuntando donde en verdad inicia el arreglo
+, t178, 2, t179; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t179, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t180; //calculando el n real
-, t180, 0, t181; //iReal columna 0
+, t181, 1, t181; //size del arreglo nombre
<=, H, t181, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t181, 0, t182; // anhadiendo una posicion mas
+, h, t182, h; // reservnado el espacio del arreglo nombre
+, P, 0, t185; // pos this del objeto 
=>, t185, t186, stack; // apuntador al heap del objeto 
=>, t186, t187, heap; // apunt al heap donde inica el objeto
+, t187, 2, t188; //apuntador a posicion donde incia el arreglo
=>, t188, t189, heap; // inicia el arreglo
=>, t189, t183, heap; // size del arreglo nombre
+, t189, 1, t184; //Pos 0 del arreglo
// Resolviendo una cadena 
+, H, 0, t190; //apuntaodr a cadena 
+, H, 1, t191; //apu donde inicia la cadena
<=, t190, t191, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 20, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t192; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 85, heap; //guardadndo U
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t190, t193, heap; // pos que apunta al size de la cadena
=>, t193, t194, heap; // size de la cadena
+, t193, 1, t195; // Pos 0 de la cadena
=>, t195, t196, heap; // sacandor el caracter del heap cadena
jle, t194, t183, L18;
jmp, , , L19;
jmp, , , L18;
L18:
jne, t196, 34, L20;
jmp, , , L21;
jmp, , , L20;
L20:
<=, t184, t196, heap; // guardando el caracter 
+, t184, 1, t184; // incremnetnado la pos del arreglo
+, t195, 1, t195; // incrementando la pos de la cadena
=>, t195, t196, heap; // sacandor el caracter del heap cadena
jmp, , , L18;
jmp, , , L21;
L21:
jmp, , , L19;
L19:
// Asignando atributo edad
+, p, 0, t197; //pos this 
=>, t197, t198, stack; // apuntador al heap
=>, t198, t199, heap; // apuntador donde inicia el objeto
+, t199, 0, t200; // pos real  de edad
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t201; // pos de val
=>, t201, t202, stack; // valor de lo que trae en el stack val
<=, t200, t202, heap; //guardando en el heap el valor del atributo
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t203; // pos this 
=>, t203, t204, stack; // obtenido apuntador al heap 
=>, t204, t205, heap; // apuntador 
+, t205, 0, t206; // pos de edad
=>, t206, t207, heap; // obtengo el valor que se encuentre en el heap 
+, t207, 10, t208;
print("%d", t208);
// ----------- Instancia a un atributo --------------
+, p, 0, t209;// pos this de car
=>, t209, t210, stack; //apuntador del heap de car
=>, t210, t211, heap; //posicion real del heap donde inicia car
+, t211, 1, t212; //pos real del atributo car
<=, t212, h, heap; //guardando la pos real donde inicia el objeto car
+, h, 3, h; // reservando el espacio de memoria para el nuevo objeto car

// Guardando la referencia al this del objeto para la llamada al constructor car
+, p, 0, t213;
=>, t213, t214, stack; //apuntador al heap de car
=>, t214, t215, heap; //posicion real donde incia el objeto car
+, t215, 1, t216; // pos real donde incial el objeto car

+, p, 7, t217; // tamanho de la funcion actual persona_vacio_persona_entero_caracter
+, t217, 0, t218; // pos del this para la nueva instancia de car
<=, t218, t216, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 7, t219; // size de funcion actual
+, t219, 1, t220; //pos del parametro 1
<=, t220, 70, stack; // asignado al stack el parametro
+, p, 7, t221; // size de funcion actual
+, t221, 2, t222; //pos del parametro 2
<=, t222, 126, stack; // asignado al stack el parametro
+, p, 7, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter_entero;
-, p, 7, p; // regresando al ambito acutal

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t223; // pos de color
// Resolviendo un acceso para un atrinuto
+, P, 0, t224; 
=>, t224, t225, stack; // apuntador al heap
=>, t225, t226, heap;
+, t226, 1, t228; 
+, P, 2, t229;
+, t229, 0, t230;
<=, t230, t228, stack; // pasadon como refeenria el valor del this
+, P, 2, P;
call, , , carro_caracter_obtenerColor;
+, P, 1, t231;
=>, t231, t232, stack; // valor del return
-, P, 2, P;
=>, t231, t233, stack; // valor a retoranar del acceso
<=, t223, t233, stack; // asignando a color
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t234; // pos de color
=>, t234, t235, stack; // valor de lo que trae en el stack color
print("%c", t235);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t236; // pos de i
<=, t236, 0, stack; // asignando a i
// Resolviendo un repetur mientras
jmp, , ,L22; //regresando a la etiqueral del ciclo repetir- mientras
L22:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t237; // pos de i
=>, t237, t238, stack; // valor de lo que trae en el stack i
// Resolviendo un acceso para un atrinuto
+, P, 0, t239; 
=>, t239, t240, stack; // apuntador al heap
=>, t240, t241, heap;
+, t241, 2, t243; 
=>, t243, t244, heap; // recuperando pos incial del objeto
=>, t244, t245, heap; // obteneindio el size del arreglo 
jl, t238, t245, L23;
jmp, , , L24;
L23:

//------------- Asignancio posicion de un arreglo Atributo  nombre
+, P, 0, t246; // pos this del objeto 
=>, t246, t247, stack; // apunt del heap para le objeto
=>, t247, t248, heap; // apunt donde inicia el objeto
+, t248, 2, t249; // pos del arreglo dentro del heap 
=>, t249, t250, heap; // apuntador donde inicia el arreglo
=>, t250, t251, heap; // size del arreglo nombre
+, t250, 1, t252; //pos 0 del arreglo nombre
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t253; // pos de i
=>, t253, t254, stack; // valor de lo que trae en el stack i
// ----------- Calculo de iReal para el arreglo nombre
-, t254, 0, t255; //calculando el n real ()
-, t255, 0, t256; //iReal columna 0
+, t252, t256, t257; // pos buscade del arreglo atributo nombre
=>, t257, t258, heap; //valor que trae el objeto
print("%c", t258);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t259; // pos de i
=>, t259, t260, stack; //obtenidoe el valor de i
+, t260, 1, t261;
<=, t259, t261, stack; // asignando a i
jmp, , ,L22; //regresando a la etiqueral del ciclo repetir mientras
L24:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 5, t262; // pos de g
+, P, 0, t263;
=>, t263, t264, stack; 
+, P, 7, t265;
+, t264, 0, t266;
<=, t265, t264, stack; 
+, P, 7, P;
call, , , persona_caracter_obtenerChar;
+, P, 1, t267;
=>, t267, t268, stack; // valor del return
-, P, 7, P;
<=, t262, t268, stack; // asignando a g
// -------------- Resolviendo para un ID (var local) ------------
+, p, 5, t269; // pos de g
=>, t269, t270, stack; // valor de lo que trae en el stack g
print("%c", t270);

L17:
end, , persona_vacio_persona_entero_caracter




begin, , , persona_caracter_obtenerChar

// RESOLVIENDO UN RETORNO
+, P, 1, t271; // pos de retorno de a funcion persona_caracter_obtenerChar
<=, t271, 75, stack; //asignando el retorno con su valor
jmp, , , L25;

L25:
end, , persona_caracter_obtenerChar




begin, , , persona_carro_retornoCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t272; // pos de c
<=, t272, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t273; // guardo la posicion donde inicia el objeto 
<=, h, t273, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t274; // pos de c
=>, t274, t275, stack; // obteniendo apuntador de c
+, p, 3, t276; // simulando cambio de ambito
+, t276, 0, t277; //pos del this de c
<=, t277, t275, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t278; // size de funcion actual
+, t278, 1, t279; //pos del parametro 1
<=, t279, 82, stack; // asignado al stack el parametro
+, 5, 5, t282;
*, t282, 2, t283;
+, p, 3, t280; // size de funcion actual
+, t280, 2, t281; //pos del parametro 2
<=, t281, t283, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter_entero;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t284; // pos de c
=>, t284, t285, stack; // valor de lo que trae en el stack c
+, P, 2, t286; // pos de retorno de a funcion persona_carro_retornoCarro
<=, t286, t285, stack; //asignando el retorno con su valor
jmp, , , L26;

L26:
end, , persona_carro_retornoCarro




begin, , , persona_entero_incrementarEdad

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t287; // pos this 
=>, t287, t288, stack; // obtenido apuntador al heap 
=>, t288, t289, heap; // apuntador 
+, t289, 0, t290; // pos de edad
=>, t290, t291, heap; // obtengo el valor que se encuentre en el heap 
+, t291, 1, t292;
+, P, 1, t293; // pos de retorno de a funcion persona_entero_incrementarEdad
<=, t293, t292, stack; //asignando el retorno con su valor
jmp, , , L27;

L27:
end, , persona_entero_incrementarEdad


