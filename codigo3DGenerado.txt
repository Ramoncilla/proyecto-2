

begin, , , holis_vacio_holis_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t1; //pos this del arreglo
=>, t1, t2, stack; //obteniendo apuntador de arreglo en eel heap
=>, t2, t3, heap;//apuntando donde en verdad inicia el arreglo
+, t3, 0, t4; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t4, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 20, 1, t5; //calculando el n real
-, t5, 0, t6; //iReal columna 0
+, t6, 1, t6; //size del arreglo nombre
<=, H, t6, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t6, 0, t7; // anhadiendo una posicion mas
+, h, t7, h; // reservnado el espacio del arreglo nombre
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t8; // pos this 
=>, t8, t9, stack; // obtenido apuntador al heap 
=>, t9, t10, heap; // apuntador 
+, t10, 0, t11; // pos de nombre
=>, t11, t12, heap; // obtengo el valor que se encuentre en el heap 
+, P, 1, t13;
=>, t13, t14, stack; 
=>, t14, t15, heap; 
=>, t15, t16, heap; // valor de size del arreglo n
+, t15, 1, t17; // apuntador donde inicia el arreglo n
=>, t17, t18, heap; // primer caracter del arreglo n
+, H, 0, t19;
+, H, 1, t20;
<=, t19, t20, heap; 
+, H, 1, H;
+, 0, 0, t21;
<=, H, t21, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L2:
jne, t18, 36, L3;
jmp, , , L4;
L3:
<=, H, t18, heap; // ingresando el caracter 
+, H, 1, H;
+, t21, 1, t21; // incrementando en uno el size de la nueva cadena
+, t17, 1, t17;
=>, t17, t18, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L2;
L4:
<=, t20, t21, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t11, 1, t22;
// -------------------- Arreglo global asignar :) 
=>, t11, t23, heap; // inicia el arreglo
=>, t23, t24, heap; // size del arreglo 
+, t23, 1, t25; //Pos 0 del arreglo
=>, t19, t26, heap; // pos que apunta al size de la cadena
=>, t26, t27, heap; // size de la cadena
+, t26, 1, t28; // Pos 0 de la cadena
=>, t28, t29, heap; // sacandor el caracter del heap cadena
jle, t27, t24, L5;
jmp, , , L6;
jmp, , , L5;
L5:
jne, t29, 34, L7;
jmp, , , L8;
jmp, , , L7;
L7:
<=, t25, t29, heap; // guardando el caracter 
+, t25, 1, t25; // incremnetnado la pos del arreglo
+, t28, 1, t28; // incrementando la pos de la cadena
=>, t28, t29, heap; // sacandor el caracter del heap cadena
jmp, , , L5;
jmp, , , L8;
L8:
jmp, , , L6;
L6:
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t30; // pos this 
=>, t30, t31, stack; // obtenido apuntador al heap 
=>, t31, t32, heap; // apuntador 
+, t32, 0, t33; // pos de nombre
=>, t33, t34, heap; // obtengo el valor que se encuentre en el heap 
print("%a", t33);
+, P, 1, t35;
=>, t35, t36, stack; 
=>, t36, t37, heap; 
=>, t37, t38, heap; // valor de size del arreglo n
+, t37, 1, t39; // apuntador donde inicia el arreglo n
=>, t39, t40, heap; // primer caracter del arreglo n
+, H, 0, t41;
+, H, 1, t42;
<=, t41, t42, heap; 
+, H, 1, H;
+, 0, 0, t43;
<=, H, t43, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L9:
jne, t40, 36, L10;
jmp, , , L11;
L10:
<=, H, t40, heap; // ingresando el caracter 
+, H, 1, H;
+, t43, 1, t43; // incrementando en uno el size de la nueva cadena
+, t39, 1, t39;
=>, t39, t40, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L9;
L11:
<=, t42, t43, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t41);

L1:
end, , holis_vacio_holis_caracter




begin, , , individuo_vacio_individuo_entero_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t44; //pos this del arreglo
=>, t44, t45, stack; //obteniendo apuntador de arreglo en eel heap
=>, t45, t46, heap;//apuntando donde en verdad inicia el arreglo
+, t46, 0, t47; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t47, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 20, 1, t48; //calculando el n real
-, t48, 0, t49; //iReal columna 0
+, t49, 1, t49; //size del arreglo nombre
<=, H, t49, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t49, 0, t50; // anhadiendo una posicion mas
+, h, t50, h; // reservnado el espacio del arreglo nombre
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t51; // pos this 
=>, t51, t52, stack; // obtenido apuntador al heap 
=>, t52, t53, heap; // apuntador 
+, t53, 0, t54; // pos de nombre
=>, t54, t55, heap; // obtengo el valor que se encuentre en el heap 
+, P, 2, t56;
=>, t56, t57, stack; 
=>, t57, t58, heap; 
=>, t58, t59, heap; // valor de size del arreglo nom
+, t58, 1, t60; // apuntador donde inicia el arreglo nom
=>, t60, t61, heap; // primer caracter del arreglo nom
+, H, 0, t62;
+, H, 1, t63;
<=, t62, t63, heap; 
+, H, 1, H;
+, 0, 0, t64;
<=, H, t64, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L13:
jne, t61, 36, L14;
jmp, , , L15;
L14:
<=, H, t61, heap; // ingresando el caracter 
+, H, 1, H;
+, t64, 1, t64; // incrementando en uno el size de la nueva cadena
+, t60, 1, t60;
=>, t60, t61, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L13;
L15:
<=, t63, t64, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t54, 1, t65;
// -------------------- Arreglo global asignar :) 
=>, t54, t66, heap; // inicia el arreglo
=>, t66, t67, heap; // size del arreglo 
+, t66, 1, t68; //Pos 0 del arreglo
=>, t62, t69, heap; // pos que apunta al size de la cadena
=>, t69, t70, heap; // size de la cadena
+, t69, 1, t71; // Pos 0 de la cadena
=>, t71, t72, heap; // sacandor el caracter del heap cadena
jle, t70, t67, L16;
jmp, , , L17;
jmp, , , L16;
L16:
jne, t72, 34, L18;
jmp, , , L19;
jmp, , , L18;
L18:
<=, t68, t72, heap; // guardando el caracter 
+, t68, 1, t68; // incremnetnado la pos del arreglo
+, t71, 1, t71; // incrementando la pos de la cadena
=>, t71, t72, heap; // sacandor el caracter del heap cadena
jmp, , , L16;
jmp, , , L19;
L19:
jmp, , , L17;
L17:
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t73; // pos this 
=>, t73, t74, stack; // obtenido apuntador al heap 
=>, t74, t75, heap; // apuntador 
+, t75, 1, t76; // pos de edad
=>, t76, t77, heap; // obtengo el valor que se encuentre en el heap 
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t78; // pos de edad
=>, t78, t79, stack; // valor de lo que trae en el stack edad
<=, t76, t79, HEAP; // asignando variable 
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t80; // pos this 
=>, t80, t81, stack; // obtenido apuntador al heap 
=>, t81, t82, heap; // apuntador 
+, t82, 0, t83; // pos de nombre
=>, t83, t84, heap; // obtengo el valor que se encuentre en el heap 
print("%a", t83);
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t85; // pos this 
=>, t85, t86, stack; // obtenido apuntador al heap 
=>, t86, t87, heap; // apuntador 
+, t87, 1, t88; // pos de edad
=>, t88, t89, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t89);
// ----------- Instancia a un atributo --------------
+, p, 0, t90;// pos this de g
=>, t90, t91, stack; //apuntador del heap de g
=>, t91, t92, heap; //posicion real del heap donde inicia g
+, t92, 2, t93; //pos real del atributo g
<=, t93, h, heap; //guardando la pos real donde inicia el objeto g
+, h, 1, h; // reservando el espacio de memoria para el nuevo objeto g

// Guardando la referencia al this del objeto para la llamada al constructor g
+, p, 0, t94;
=>, t94, t95, stack; //apuntador al heap de g
=>, t95, t96, heap; //posicion real donde incia el objeto g
+, t96, 2, t97; // pos real donde incial el objeto g

+, p, 4, t98; // tamanho de la funcion actual individuo_vacio_individuo_entero_caracter
+, t98, 0, t99; // pos del this para la nueva instancia de g
<=, t99, t97, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 4, t100; // size de funcion actual
+, t100, 1, t101; //pos del parametro 1
// declarando parametros  arreglo de tipo n
// ------------------------ Creando arreglo local n
+, P, t101, t102; //pos de arreglo n
<=, t102, H, stack; // ingrensando al stack apunt del heap para n
+, H, 1, t103;
<=, H, t103, heap; //insetnado donde inicia el arreglo n
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t104; //calculando el n real
-, t104, 0, t105; //iReal columna 0
+, t105, 1, t105; //size del arreglo n
<=, H, t105, heap; // insertando el tamanio del arreglo linealizado n
+, H, 1, H;
+, h, t105, h; // reservnado el espacio del arreglo n
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t106; // pos this 
=>, t106, t107, stack; // obtenido apuntador al heap 
=>, t107, t108, heap; // apuntador 
+, t108, 0, t109; // pos de nombre
=>, t109, t110, heap; // obtengo el valor que se encuentre en el heap 
<=, t101, t109, stack; //  reerencia del arreglo asignado al stack el parametro
+, p, 4, p; // simulando cambio de ambito
call, , , holis_vacio_holis_caracter;
-, p, 4, p; // regresando al ambito acutal


L12:
end, , individuo_vacio_individuo_entero_caracter




begin, , , ejemplos_PRINCIPAL

// ------------------------ Creando arreglo local h
+, P, 0, t111; //pos de arreglo h
<=, t111, H, stack; // ingrensando al stack apunt del heap para h
+, H, 1, t112;
<=, H, t112, heap; //insetnado donde inicia el arreglo h
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t113; //calculando el n real
-, t113, 0, t114; //iReal columna 0
+, t114, 1, t114; //size del arreglo h
<=, H, t114, heap; // insertando el tamanio del arreglo linealizado h
+, H, 1, H;
+, h, t114, h; // reservnado el espacio del arreglo h
+, P, 0, t117; // pos del arreglo 
=>, t117, t118, stack; //apuntador al heap del arreglo
=>, t118, t119, heap; // apuntador del heap al heap donde inicia la cadena
=>, t119, t115, heap; // size del arreglo h
+, t119, 1, t116; // pos 0 donde inicia el arreglo h
// Resolviendo una cadena 
+, H, 0, t120; //apuntaodr a cadena 
+, H, 1, t121; //apu donde inicia la cadena
<=, t120, t121, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t122; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t120, t123, heap; // pos que apunta al size de la cadena
=>, t123, t124, heap; // size de la cadena
+, t123, 1, t125; // Pos 0 de la cadena
=>, t125, t126, heap; // sacandor el caracter del heap cadena
jle, t124, t115, L21;
jmp, , , L22;
jmp, , , L21;
L21:
jne, t126, 34, L23;
jmp, , , L24;
jmp, , , L23;
L23:
<=, t116, t126, heap; // guardando el caracter 
+, t116, 1, t116; // incremnetnado la pos del arreglo
+, t125, 1, t125; // incrementando la pos de la cadena
=>, t125, t126, heap; // sacandor el caracter del heap cadena
jmp, , , L21;
jmp, , , L24;
L24:
jmp, , , L22;
L22:
+, P, 0, t127;
=>, t127, t128, stack; 
=>, t128, t129, heap; 
=>, t129, t130, heap; // valor de size del arreglo h
+, t129, 1, t131; // apuntador donde inicia el arreglo h
=>, t131, t132, heap; // primer caracter del arreglo h
+, H, 0, t133;
+, H, 1, t134;
<=, t133, t134, heap; 
+, H, 1, H;
+, 0, 0, t135;
<=, H, t135, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L25:
jne, t132, 36, L26;
jmp, , , L27;
L26:
<=, H, t132, heap; // ingresando el caracter 
+, H, 1, H;
+, t135, 1, t135; // incrementando en uno el size de la nueva cadena
+, t131, 1, t131;
=>, t131, t132, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L25;
L27:
<=, t134, t135, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t133);
// ----------- Instancia a una variable local --------------
+, p, 1, t136; // pos de j
<=, t136, h, stack; //guardando referencia del heap para el objeto j
+, h, 1, t137; // guardo la posicion donde inicia el objeto 
<=, h, t137, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto j
//Ingresando referencia al this del objeto j
+, p, 1, t138; // pos de j
=>, t138, t139, stack; // obteniendo apuntador de j
+, p, 3, t140; // simulando cambio de ambito
+, t140, 0, t141; //pos del this de j
<=, t141, t139, stack; // insertando apuntador del heap al stack del obeto j
// Asignando parametros  
+, p, 3, t142; // size de funcion actual
+, t142, 1, t143; //pos del parametro 1
<=, t143, 25, stack; // asignado al stack el parametro
+, p, 3, t144; // size de funcion actual
+, t144, 2, t145; //pos del parametro 2
// declarando parametros  arreglo de tipo nom
// ------------------------ Creando arreglo local nom
+, P, t145, t146; //pos de arreglo nom
<=, t146, H, stack; // ingrensando al stack apunt del heap para nom
+, H, 1, t147;
<=, H, t147, heap; //insetnado donde inicia el arreglo nom
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t148; //calculando el n real
-, t148, 0, t149; //iReal columna 0
+, t149, 1, t149; //size del arreglo nom
<=, H, t149, heap; // insertando el tamanio del arreglo linealizado nom
+, H, 1, H;
+, h, t149, h; // reservnado el espacio del arreglo nom
// Resolviendo una cadena 
+, H, 0, t150; //apuntaodr a cadena 
+, H, 1, t151; //apu donde inicia la cadena
<=, t150, t151, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t152; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t145, t150, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , individuo_vacio_individuo_entero_caracter;
-, p, 3, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 1, t153; // pos del objeto
=>, t153, t155, stack; //apuntador al heap del obejto
=>, t155, t156, heap; // recuperando pos incial del objeto
+, t156, 0, t155;
=>, t155, t157, heap; // valor a retoranar del acceso
print("%a", t155);
// ----------------- Resolviendo acceso local 
+, P, 1, t158; // pos del objeto
=>, t158, t160, stack; //apuntador al heap del obejto
=>, t160, t161, heap; // recuperando pos incial del objeto
+, t161, 1, t160;
=>, t160, t162, heap; // valor a retoranar del acceso
print("%d", t162);
// ----------------- Resolviendo acceso local 
+, P, 1, t163; // pos del objeto
=>, t163, t165, stack; //apuntador al heap del obejto
=>, t165, t166, heap; // recuperando pos incial del objeto
+, t166, 0, t165;
=>, t165, t167, heap; // valor a retoranar del acceso
// Resolviendo una cadena 
+, H, 0, t168; //apuntaodr a cadena 
+, H, 1, t169; //apu donde inicia la cadena
<=, t168, t169, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t170; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
-, t165, 1, t171;
// -------------------- Arreglo global asignar :) 
=>, t165, t172, heap; // inicia el arreglo
=>, t172, t173, heap; // size del arreglo 
+, t172, 1, t174; //Pos 0 del arreglo
=>, t168, t175, heap; // pos que apunta al size de la cadena
=>, t175, t176, heap; // size de la cadena
+, t175, 1, t177; // Pos 0 de la cadena
=>, t177, t178, heap; // sacandor el caracter del heap cadena
jle, t176, t173, L28;
jmp, , , L29;
jmp, , , L28;
L28:
jne, t178, 34, L30;
jmp, , , L31;
jmp, , , L30;
L30:
<=, t174, t178, heap; // guardando el caracter 
+, t174, 1, t174; // incremnetnado la pos del arreglo
+, t177, 1, t177; // incrementando la pos de la cadena
=>, t177, t178, heap; // sacandor el caracter del heap cadena
jmp, , , L28;
jmp, , , L31;
L31:
jmp, , , L29;
L29:
// ----------------- Resolviendo acceso local 
+, P, 1, t179; // pos del objeto
=>, t179, t181, stack; //apuntador al heap del obejto
=>, t181, t182, heap; // recuperando pos incial del objeto
+, t182, 0, t181;
=>, t181, t183, heap; // valor a retoranar del acceso
print("%a", t181);
// ----------- Instancia a una variable local --------------
+, p, 2, t184; // pos de p
<=, t184, h, stack; //guardando referencia del heap para el objeto p
+, h, 1, t185; // guardo la posicion donde inicia el objeto 
<=, h, t185, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 0, h; // reservando espacio para el objeto p
//Ingresando referencia al this del objeto p
+, p, 2, t186; // pos de p
=>, t186, t187, stack; // obteniendo apuntador de p
+, p, 3, t188; // simulando cambio de ambito
+, t188, 0, t189; //pos del this de p
<=, t189, t187, stack; // insertando apuntador del heap al stack del obeto p
// Asignando parametros  
+, p, 3, t190; // size de funcion actual
+, t190, 1, t191; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t192; // pos de j
=>, t192, t193, stack; // valor de lo que trae en el stack j
<=, t191, t193, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , ejemplos_vacio_ejemplos_individuo;
-, p, 3, p; // regresando al ambito acutal


L20:
end, , ejemplos_PRINCIPAL




begin, , , ejemplos_vacio_ejemplos_individuo

// ----------------- Resolviendo acceso local 
+, P, 1, t194; // pos del objeto
=>, t194, t196, stack; //apuntador al heap del obejto
=>, t196, t197, heap; // recuperando pos incial del objeto
+, t197, 1, t196;
=>, t196, t198, heap; // valor a retoranar del acceso
print("%d", t198);
// ----------------- Resolviendo acceso local 
+, P, 1, t199; // pos del objeto
=>, t199, t201, stack; //apuntador al heap del obejto
=>, t201, t202, heap; // recuperando pos incial del objeto
+, t202, 0, t201;
=>, t201, t203, heap; // valor a retoranar del acceso
print("%a", t201);
// ------------------------ Creando arreglo local k
+, P, 2, t204; //pos de arreglo k
<=, t204, H, stack; // ingrensando al stack apunt del heap para k
+, H, 1, t205;
<=, H, t205, heap; //insetnado donde inicia el arreglo k
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t206; //calculando el n real
-, t206, 0, t207; //iReal columna 0
+, t207, 1, t207; //size del arreglo k
<=, H, t207, heap; // insertando el tamanio del arreglo linealizado k
+, H, 1, H;
+, h, t207, h; // reservnado el espacio del arreglo k
// ----------------- Resolviendo acceso local 
+, P, 1, t208; // pos del objeto
=>, t208, t210, stack; //apuntador al heap del obejto
=>, t210, t211, heap; // recuperando pos incial del objeto
+, t211, 0, t210;
=>, t210, t212, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t213; // pos de k
<=, t213, t210, stack; // cosa de direccion arreglo
+, P, 2, t214;
=>, t214, t215, stack; 
=>, t215, t216, heap; 
=>, t216, t217, heap; // valor de size del arreglo k
+, t216, 1, t218; // apuntador donde inicia el arreglo k
=>, t218, t219, heap; // primer caracter del arreglo k
+, H, 0, t220;
+, H, 1, t221;
<=, t220, t221, heap; 
+, H, 1, H;
+, 0, 0, t222;
<=, H, t222, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L33:
jne, t219, 36, L34;
jmp, , , L35;
L34:
<=, H, t219, heap; // ingresando el caracter 
+, H, 1, H;
+, t222, 1, t222; // incrementando en uno el size de la nueva cadena
+, t218, 1, t218;
=>, t218, t219, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L33;
L35:
<=, t221, t222, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t220);
// Resolviendo una cadena 
+, H, 0, t223; //apuntaodr a cadena 
+, H, 1, t224; //apu donde inicia la cadena
<=, t223, t224, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 11, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t225; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 46, heap; //guardadndo .
+, H, 1, H;
<=, H, 60, heap; //guardadndo <
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 60, heap; //guardadndo <
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 2, t228; // pos del arreglo 
=>, t228, t229, stack; //apuntador al heap del arreglo
=>, t229, t230, heap; // apuntador del heap al heap donde inicia la cadena
=>, t230, t226, heap; // size del arreglo k
+, t230, 1, t227; // pos 0 donde inicia el arreglo k
=>, t223, t231, heap; // pos que apunta al size de la cadena
=>, t231, t232, heap; // size de la cadena
+, t231, 1, t233; // Pos 0 de la cadena
=>, t233, t234, heap; // sacandor el caracter del heap cadena
jle, t232, t226, L36;
jmp, , , L37;
jmp, , , L36;
L36:
jne, t234, 34, L38;
jmp, , , L39;
jmp, , , L38;
L38:
<=, t227, t234, heap; // guardando el caracter 
+, t227, 1, t227; // incremnetnado la pos del arreglo
+, t233, 1, t233; // incrementando la pos de la cadena
=>, t233, t234, heap; // sacandor el caracter del heap cadena
jmp, , , L36;
jmp, , , L39;
L39:
jmp, , , L37;
L37:
+, P, 2, t235;
=>, t235, t236, stack; 
=>, t236, t237, heap; 
=>, t237, t238, heap; // valor de size del arreglo k
+, t237, 1, t239; // apuntador donde inicia el arreglo k
=>, t239, t240, heap; // primer caracter del arreglo k
+, H, 0, t241;
+, H, 1, t242;
<=, t241, t242, heap; 
+, H, 1, H;
+, 0, 0, t243;
<=, H, t243, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L40:
jne, t240, 36, L41;
jmp, , , L42;
L41:
<=, H, t240, heap; // ingresando el caracter 
+, H, 1, H;
+, t243, 1, t243; // incrementando en uno el size de la nueva cadena
+, t239, 1, t239;
=>, t239, t240, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L40;
L42:
<=, t242, t243, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t241);
// ----------- Instancia a una variable local --------------
+, p, 3, t244; // pos de l
<=, t244, h, stack; //guardando referencia del heap para el objeto l
+, h, 1, t245; // guardo la posicion donde inicia el objeto 
<=, h, t245, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto l
//Ingresando referencia al this del objeto l
+, p, 3, t246; // pos de l
=>, t246, t247, stack; // obteniendo apuntador de l
+, p, 5, t248; // simulando cambio de ambito
+, t248, 0, t249; //pos del this de l
<=, t249, t247, stack; // insertando apuntador del heap al stack del obeto l
// Asignando parametros  
+, p, 5, t250; // size de funcion actual
+, t250, 1, t251; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t252; // pos del objeto
=>, t252, t254, stack; //apuntador al heap del obejto
=>, t254, t255, heap; // recuperando pos incial del objeto
+, t255, 1, t254;
=>, t254, t256, heap; // valor a retoranar del acceso
+, 12, t256, t257;
<=, t251, t257, stack; // asignado al stack el parametro
+, p, 5, t258; // size de funcion actual
+, t258, 2, t259; //pos del parametro 2
// declarando parametros  arreglo de tipo nom
// ------------------------ Creando arreglo local nom
+, P, t259, t260; //pos de arreglo nom
<=, t260, H, stack; // ingrensando al stack apunt del heap para nom
+, H, 1, t261;
<=, H, t261, heap; //insetnado donde inicia el arreglo nom
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t262; //calculando el n real
-, t262, 0, t263; //iReal columna 0
+, t263, 1, t263; //size del arreglo nom
<=, H, t263, heap; // insertando el tamanio del arreglo linealizado nom
+, H, 1, H;
+, h, t263, h; // reservnado el espacio del arreglo nom
+, P, 2, t264;
=>, t264, t265, stack; 
=>, t265, t266, heap; 
=>, t266, t267, heap; // valor de size del arreglo k
+, t266, 1, t268; // apuntador donde inicia el arreglo k
=>, t268, t269, heap; // primer caracter del arreglo k
+, H, 0, t270;
+, H, 1, t271;
<=, t270, t271, heap; 
+, H, 1, H;
+, 0, 0, t272;
<=, H, t272, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L43:
jne, t269, 36, L44;
jmp, , , L45;
L44:
<=, H, t269, heap; // ingresando el caracter 
+, H, 1, H;
+, t272, 1, t272; // incrementando en uno el size de la nueva cadena
+, t268, 1, t268;
=>, t268, t269, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L43;
L45:
<=, t271, t272, heap; // ingresando el size de la nueva cadena 
<=, H, 34, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, t259, t270, stack; // asignado al stack el parametro
+, p, 5, p; // simulando cambio de ambito
call, , , individuo_vacio_individuo_entero_caracter;
-, p, 5, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 3, t273; // pos del objeto
=>, t273, t275, stack; //apuntador al heap del obejto
=>, t275, t276, heap; // recuperando pos incial del objeto
+, t276, 1, t275;
=>, t275, t277, heap; // valor a retoranar del acceso
print("%d", t277);
// ----------------- Resolviendo acceso local 
+, P, 3, t278; // pos del objeto
=>, t278, t280, stack; //apuntador al heap del obejto
=>, t280, t281, heap; // recuperando pos incial del objeto
+, t281, 0, t280;
=>, t280, t282, heap; // valor a retoranar del acceso
print("%a", t280);
// ----------------- Resolviendo acceso local 
+, P, 1, t283; // pos del objeto
=>, t283, t285, stack; //apuntador al heap del obejto
=>, t285, t286, heap; // recuperando pos incial del objeto
+, t286, 2, t285;
=>, t285, t287, heap; // recuperando pos incial del objeto
+, t287, 0, t285;
=>, t285, t288, heap; // valor a retoranar del acceso
print("%a", t285);
// ----------------- Resolviendo acceso local 
+, P, 3, t289; // pos del objeto
=>, t289, t291, stack; //apuntador al heap del obejto
=>, t291, t292, heap; // recuperando pos incial del objeto
+, t292, 0, t291;
=>, t291, t293, heap; // valor a retoranar del acceso
// Resolviendo una cadena 
+, H, 0, t294; //apuntaodr a cadena 
+, H, 1, t295; //apu donde inicia la cadena
<=, t294, t295, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t296; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t291, t297, heap; 
=>, t297, t298, heap; // size arreglo heap a convertir a cadena
+, t297, 1, t299; // pos actual del arreglo a convertir a cadena
=>, t299, t300, heap; // caracter acutal del arreglo a convertir
+, 0, 0, t301;
// ------------------------------ Iniciando cadena de una arreglo a convertir ---------
+, H, 0, t302; // referencia de la cadena
+, H, 1, t303; // valor de la cadena
<=, t302, t303, heap; 
+, H, 1, H; 
+, H, 0, t304;
+, H, 1, H; 
L49:
jne, t300, 36, L50;
jmp, , , L51;
L50:
<=, H, t300, heap; // insertarndo caracter 
+, H, 1, H; 
+, t301, 1, t301; // incrementando en 1 el contador de la cadena 
+, t299, 1, t299; // incrementando en 1 la posicion acutal de la cadena 
=>, t299, t300, heap; // caracter acutal del arreglo a convertir
jmp, , , L49;
L51:
<=, H, 34, heap; // insertarndo caracter de escape
+, H, 1, H; 
<=, t304, t301, heap; // insertando el size de la cadena 
// ------------ Obtenieido suma de caracteres de una cadena --------
=>, t302, t305, heap; // apunt al heap donde inicia la cadena
+, t305, 1, t306; // pos donde incia la cadena
=>, t306, t307, heap; // valor caracter  de la cadena
+, 0, 0, t308; //acumulador de la cadena
jmp, , , L52;
L52: //etiquera ciclo suma cadena
jne, t307, 34, L53;
jmp, , , L54;
L53:
+, t308, t307, t308; // sumando los caracteres 
+, t306, 1, t306; // sumando una posicion
=>, t306, t307, heap; // obteniendo el valor del caracter 
jmp, , , L52;
L54:
// ------------ Obtenieido suma de caracteres de una cadena --------
=>, t294, t309, heap; // apunt al heap donde inicia la cadena
+, t309, 1, t310; // pos donde incia la cadena
=>, t310, t311, heap; // valor caracter  de la cadena
+, 0, 0, t312; //acumulador de la cadena
jmp, , , L55;
L55: //etiquera ciclo suma cadena
jne, t311, 34, L56;
jmp, , , L57;
L56:
+, t312, t311, t312; // sumando los caracteres 
+, t310, 1, t310; // sumando una posicion
=>, t310, t311, heap; // obteniendo el valor del caracter 
jmp, , , L55;
L57:
jne, t308, t312, L47;
jmp, , , L48;
L47:

// Resolviendo una cadena 
+, H, 0, t313; //apuntaodr a cadena 
+, H, 1, t314; //apu donde inicia la cadena
<=, t313, t314, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t315; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t313);
jmp, , , L46; // salida del if
L48:

// Resolviendo una cadena 
+, H, 0, t316; //apuntaodr a cadena 
+, H, 1, t317; //apu donde inicia la cadena
<=, t316, t317, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 18, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t318; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 102, heap; //guardadndo f
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t316);
L46:

L32:
end, , ejemplos_vacio_ejemplos_individuo


