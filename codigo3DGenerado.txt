

begin, , , llanta_vacio_llanta_entero_entero

// Asignando atributo valor1Llanta
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de valor1Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de val1
=>, t5, t6, stack; // valor de lo que trae en el stack val1
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo valor2Llanta
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de valor2Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t11; // pos de val2
=>, t11, t12, stack; // valor de lo que trae en el stack val2
<=, t10, t12, heap; //guardando en el heap el valor del atributo

L1:
end, , llanta_vacio_llanta_entero_entero




begin, , , llanta_vacio_mostrarVAlor1

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t13; // pos this 
=>, t13, t14, stack; // obtenido apuntador al heap 
=>, t14, t15, heap; // apuntador 
+, t15, 0, t16; // pos de valor1Llanta
=>, t16, t17, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t17);

L2:
end, , llanta_vacio_mostrarVAlor1




begin, , , llanta_vacio_mostrarVAlor2

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t18; // pos this 
=>, t18, t19, stack; // obtenido apuntador al heap 
=>, t19, t20, heap; // apuntador 
+, t20, 1, t21; // pos de valor2Llanta
=>, t21, t22, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t22);

L3:
end, , llanta_vacio_mostrarVAlor2




begin, , , carro_vacio_carro_caracter_entero

// Asignando atributo col
+, p, 0, t23; //pos this 
=>, t23, t24, stack; // apuntador al heap
=>, t24, t25, heap; // apuntador donde inicia el objeto
+, t25, 0, t26; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t27; // pos de color
=>, t27, t28, stack; // valor de lo que trae en el stack color
<=, t26, t28, heap; //guardando en el heap el valor del atributo
print("%c", 89);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t29; // pos de rinLlanta
=>, t29, t30, stack; // valor de lo que trae en el stack rinLlanta
print("%d", t30);
// Asignando atributo valorCarro
+, p, 0, t31; //pos this 
=>, t31, t32, stack; // apuntador al heap
=>, t32, t33, heap; // apuntador donde inicia el objeto
+, t33, 2, t34; // pos real  de valorCarro
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t35; // pos de rinLlanta
=>, t35, t36, stack; // valor de lo que trae en el stack rinLlanta
<=, t34, t36, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t37;// pos this de lla1
=>, t37, t38, stack; //apuntador del heap de lla1
=>, t38, t39, heap; //posicion real del heap donde inicia lla1
+, t39, 1, t40; //pos real del atributo lla1
<=, t40, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t41;
=>, t41, t42, stack; //apuntador al heap de lla1
=>, t42, t43, heap; //posicion real donde incia el objeto lla1
+, t43, 1, t44; // pos real donde incial el objeto lla1

+, p, 4, t45; // tamanho de la funcion actual carro_vacio_carro_caracter_entero
+, t45, 0, t46; // pos del this para la nueva instancia de lla1
<=, t46, t44, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 4, t47; // size de funcion actual
+, t47, 1, t48; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t49; // pos de rinLlanta
=>, t49, t50, stack; // valor de lo que trae en el stack rinLlanta
*, t50, 2, t51;
<=, t48, t51, stack; // asignado al stack el parametro
+, p, 4, t52; // size de funcion actual
+, t52, 2, t53; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t54; // pos de rinLlanta
=>, t54, t55, stack; // valor de lo que trae en el stack rinLlanta
*, t55, 3, t56;
<=, t53, t56, stack; // asignado al stack el parametro
+, p, 4, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 4, p; // regresando al ambito acutal


L4:
end, , carro_vacio_carro_caracter_entero




begin, , , carro_caracter_obtenerColor

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t57; // pos this 
=>, t57, t58, stack; // obtenido apuntador al heap 
=>, t58, t59, heap; // apuntador 
+, t59, 0, t60; // pos de col
=>, t60, t61, heap; // obtengo el valor que se encuentre en el heap 
+, P, 1, t62; // pos de retorno de a funcion carro_caracter_obtenerColor
<=, t62, t61, stack; //asignando el retorno con su valor
jmp, , , L5;

L5:
end, , carro_caracter_obtenerColor




begin, , , carro_entero_obtenerValor

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t63; // pos this 
=>, t63, t64, stack; // obtenido apuntador al heap 
=>, t64, t65, heap; // apuntador 
+, t65, 2, t66; // pos de valorCarro
=>, t66, t67, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t67);
print("%c", 76);
// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t68; // pos this 
=>, t68, t69, stack; // obtenido apuntador al heap 
=>, t69, t70, heap; // apuntador 
+, t70, 2, t71; // pos de valorCarro
=>, t71, t72, heap; // obtengo el valor que se encuentre en el heap 
*, t72, 5, t73;
+, P, 1, t74; // pos de retorno de a funcion carro_entero_obtenerValor
<=, t74, t73, stack; //asignando el retorno con su valor
jmp, , , L6;

L6:
end, , carro_entero_obtenerValor




begin, , , carro_vacio_carro_caracter

// Asignando atributo col
+, p, 0, t75; //pos this 
=>, t75, t76, stack; // apuntador al heap
=>, t76, t77, heap; // apuntador donde inicia el objeto
+, t77, 0, t78; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t79; // pos de n
=>, t79, t80, stack; // valor de lo que trae en el stack n
<=, t78, t80, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t81;// pos this de lla1
=>, t81, t82, stack; //apuntador del heap de lla1
=>, t82, t83, heap; //posicion real del heap donde inicia lla1
+, t83, 1, t84; //pos real del atributo lla1
<=, t84, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t85;
=>, t85, t86, stack; //apuntador al heap de lla1
=>, t86, t87, heap; //posicion real donde incia el objeto lla1
+, t87, 1, t88; // pos real donde incial el objeto lla1

+, p, 3, t89; // tamanho de la funcion actual carro_vacio_carro_caracter
+, t89, 0, t90; // pos del this para la nueva instancia de lla1
<=, t90, t88, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 3, t91; // size de funcion actual
+, t91, 1, t92; //pos del parametro 1
<=, t92, 10, stack; // asignado al stack el parametro
+, p, 3, t93; // size de funcion actual
+, t93, 2, t94; //pos del parametro 2
<=, t94, 20, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 3, p; // regresando al ambito acutal


L7:
end, , carro_vacio_carro_caracter




begin, , , carro_vacio_imprimir_Color

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t95; // pos this 
=>, t95, t96, stack; // obtenido apuntador al heap 
=>, t96, t97, heap; // apuntador 
+, t97, 0, t98; // pos de col
=>, t98, t99, heap; // obtengo el valor que se encuentre en el heap 
print("%c", t99);

L8:
end, , carro_vacio_imprimir_Color




begin, , , persona_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t100; // pos de p1
<=, t100, h, stack; //guardando referencia del heap para el objeto p1
+, h, 1, t101; // guardo la posicion donde inicia el objeto 
<=, h, t101, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto p1
//Ingresando referencia al this del objeto p1
+, p, 0, t102; // pos de p1
=>, t102, t103, stack; // obteniendo apuntador de p1
+, p, 2, t104; // simulando cambio de ambito
+, t104, 0, t105; //pos del this de p1
<=, t105, t103, stack; // insertando apuntador del heap al stack del obeto p1
// Asignando parametros  
+, p, 2, t106; // size de funcion actual
+, t106, 1, t107; //pos del parametro 1
<=, t107, 25, stack; // asignado al stack el parametro
+, p, 2, t108; // size de funcion actual
+, t108, 2, t109; //pos del parametro 2
<=, t109, 80, stack; // asignado al stack el parametro
+, p, 2, p; // simulando cambio de ambito
call, , , persona_vacio_persona_entero_caracter;
-, p, 2, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t110; // pos del objeto
=>, t110, t112, stack; //apuntador al heap del obejto
+, P, 2, t113;
+, t113, 0, t114;
<=, t114, t112, stack; // pasadon como refeenria el valor del this
+, P, 2, P;
call, , , persona_entero_incrementarEdad;
+, P, 1, t115;
=>, t115, t116, stack; // valor del return
-, P, 2, P;
=>, t115, t117, stack; // valor a retoranar del acceso
print("%d", t117);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t118; // pos de valor1
// ----------------- Resolviendo acceso local 
+, P, 0, t119; // pos del objeto
=>, t119, t121, stack; //apuntador al heap del obejto
+, P, 3, t122;
+, t122, 0, t123;
<=, t123, t121, stack; // pasadon como refeenria el valor del this
+, P, 3, P;
call, , , persona_carro_retornoCarro;
+, P, 2, t124;
=>, t124, t125, stack; // valor del return
-, P, 3, P;
=>, t124, t126, stack; // recuperando pos incial del objeto
=>, t126, t126, heap; // apuntador inciail del objeto 
+, t126, 2, t124;
=>, t124, t127, heap; // valor a retoranar del acceso
<=, t118, t127, stack; // asignando a valor1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t128; // pos de valor1
=>, t128, t129, stack; // valor de lo que trae en el stack valor1
print("%d", t129);

L9:
end, , persona_PRINCIPAL




begin, , , persona_vacio_molestar

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t130; // pos this 
=>, t130, t131, stack; // obtenido apuntador al heap 
=>, t131, t132, heap; // apuntador 
+, t132, 0, t133; // pos de edad
=>, t133, t134, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t134);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t135; // pos de a
<=, t135, 189, stack; // asignando a a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t136; // pos de a
=>, t136, t137, stack; // valor de lo que trae en el stack a
print("%d", t137);
// RESOLVIENDO UN RETORNO
jmp, , , L10;
print("%c", 84);

L10:
end, , persona_vacio_molestar




begin, , , persona_carro_obtenerCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t138; // pos de c
<=, t138, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t139; // guardo la posicion donde inicia el objeto 
<=, h, t139, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t140; // pos de c
=>, t140, t141, stack; // obteniendo apuntador de c
+, p, 3, t142; // simulando cambio de ambito
+, t142, 0, t143; //pos del this de c
<=, t143, t141, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t144; // size de funcion actual
+, t144, 1, t145; //pos del parametro 1
<=, t145, 72, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t146; // pos de c
=>, t146, t147, stack; // valor de lo que trae en el stack c
+, P, 2, t148; // pos de retorno de a funcion persona_carro_obtenerCarro
<=, t148, t147, stack; //asignando el retorno con su valor
jmp, , , L11;

L11:
end, , persona_carro_obtenerCarro




begin, , , persona_entero_obtenernUmero

// RESOLVIENDO UN RETORNO
*, 5, 8, t149;
+, P, 1, t150; // pos de retorno de a funcion persona_entero_obtenernUmero
<=, t150, t149, stack; //asignando el retorno con su valor
jmp, , , L12;

L12:
end, , persona_entero_obtenernUmero




begin, , , persona_vacio_persona_entero_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t151; //pos this del arreglo
=>, t151, t152, stack; //obteniendo apuntador de arreglo en eel heap
=>, t152, t153, heap;//apuntando donde en verdad inicia el arreglo
+, t153, 2, t154; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t154, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t155; //calculando el n real
-, t155, 0, t156; //iReal columna 0
+, t156, 1, t156; //size del arreglo nombre
<=, H, t156, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t156, 0, t157; // anhadiendo una posicion mas
+, h, t157, h; // reservnado el espacio del arreglo nombre
+, P, 0, t160; // pos this del objeto 
=>, t160, t161, stack; // apuntador al heap del objeto 
=>, t161, t162, heap; // apunt al heap donde inica el objeto
+, t162, 2, t163; //apuntador a posicion donde incia el arreglo
=>, t163, t164, heap; // inicia el arreglo
=>, t164, t158, heap; // size del arreglo nombre
+, t164, 1, t159; //Pos 0 del arreglo
// Resolviendo una cadena 
+, H, 0, t165; //apuntaodr a cadena 
+, H, 1, t166; //apu donde inicia la cadena
<=, t165, t166, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 20, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t167; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 85, heap; //guardadndo U
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t165, t168, heap; // pos que apunta al size de la cadena
=>, t168, t169, heap; // size de la cadena
+, t168, 1, t170; // Pos 0 de la cadena
=>, t170, t171, heap; // sacandor el caracter del heap cadena
jle, t169, t158, L14;
jmp, , , L15;
jmp, , , L14;
L14:
jne, t171, 34, L16;
jmp, , , L17;
jmp, , , L16;
L16:
<=, t159, t171, heap; // guardando el caracter 
+, t159, 1, t159; // incremnetnado la pos del arreglo
+, t170, 1, t170; // incrementando la pos de la cadena
=>, t170, t171, heap; // sacandor el caracter del heap cadena
jmp, , , L14;
jmp, , , L17;
L17:
jmp, , , L15;
L15:
// Asignando atributo edad
+, p, 0, t172; //pos this 
=>, t172, t173, stack; // apuntador al heap
=>, t173, t174, heap; // apuntador donde inicia el objeto
+, t174, 0, t175; // pos real  de edad
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t176; // pos de val
=>, t176, t177, stack; // valor de lo que trae en el stack val
<=, t175, t177, heap; //guardando en el heap el valor del atributo
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t178; // pos this 
=>, t178, t179, stack; // obtenido apuntador al heap 
=>, t179, t180, heap; // apuntador 
+, t180, 0, t181; // pos de edad
=>, t181, t182, heap; // obtengo el valor que se encuentre en el heap 
+, t182, 10, t183;
print("%d", t183);
// ----------- Instancia a un atributo --------------
+, p, 0, t184;// pos this de car
=>, t184, t185, stack; //apuntador del heap de car
=>, t185, t186, heap; //posicion real del heap donde inicia car
+, t186, 1, t187; //pos real del atributo car
<=, t187, h, heap; //guardando la pos real donde inicia el objeto car
+, h, 3, h; // reservando el espacio de memoria para el nuevo objeto car

// Guardando la referencia al this del objeto para la llamada al constructor car
+, p, 0, t188;
=>, t188, t189, stack; //apuntador al heap de car
=>, t189, t190, heap; //posicion real donde incia el objeto car
+, t190, 1, t191; // pos real donde incial el objeto car

+, p, 7, t192; // tamanho de la funcion actual persona_vacio_persona_entero_caracter
+, t192, 0, t193; // pos del this para la nueva instancia de car
<=, t193, t191, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 7, t194; // size de funcion actual
+, t194, 1, t195; //pos del parametro 1
<=, t195, 70, stack; // asignado al stack el parametro
+, p, 7, t196; // size de funcion actual
+, t196, 2, t197; //pos del parametro 2
<=, t197, 126, stack; // asignado al stack el parametro
+, p, 7, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter_entero;
-, p, 7, p; // regresando al ambito acutal

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t198; // pos de color
// Resolviendo un acceso para un atrinuto
+, P, 0, t199; 
=>, t199, t200, stack; // apuntador al heap
=>, t200, t201, heap;
+, t201, 1, t203; 
+, P, 2, t204;
+, t204, 0, t205;
<=, t205, t203, stack; // pasadon como refeenria el valor del this
+, P, 2, P;
call, , , carro_caracter_obtenerColor;
+, P, 1, t206;
=>, t206, t207, stack; // valor del return
-, P, 2, P;
=>, t206, t208, stack; // valor a retoranar del acceso
<=, t198, t208, stack; // asignando a color
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t209; // pos de color
=>, t209, t210, stack; // valor de lo que trae en el stack color
print("%c", t210);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t211; // pos de i
<=, t211, 0, stack; // asignando a i
// Resolviendo un repetur mientras
jmp, , ,L18; //regresando a la etiqueral del ciclo repetir- mientras
L18:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t212; // pos de i
=>, t212, t213, stack; // valor de lo que trae en el stack i
// Resolviendo un acceso para un atrinuto
+, P, 0, t214; 
=>, t214, t215, stack; // apuntador al heap
=>, t215, t216, heap;
+, t216, 2, t218; 
=>, t218, t219, heap; // recuperando pos incial del objeto
=>, t219, t220, heap; // obteneindio el size del arreglo 
jl, t213, t220, L19;
jmp, , , L20;
L19:

//------------- Asignancio posicion de un arreglo Atributo  nombre
+, P, 0, t221; // pos this del objeto 
=>, t221, t222, stack; // apunt del heap para le objeto
=>, t222, t223, heap; // apunt donde inicia el objeto
+, t223, 2, t224; // pos del arreglo dentro del heap 
=>, t224, t225, heap; // apuntador donde inicia el arreglo
=>, t225, t226, heap; // size del arreglo nombre
+, t225, 1, t227; //pos 0 del arreglo nombre
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t228; // pos de i
=>, t228, t229, stack; // valor de lo que trae en el stack i
// ----------- Calculo de iReal para el arreglo nombre
-, t229, 0, t230; //calculando el n real ()
-, t230, 0, t231; //iReal columna 0
+, t227, t231, t232; // pos buscade del arreglo atributo nombre
=>, t232, t233, heap; //valor que trae el objeto
print("%c", t233);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t234; // pos de i
=>, t234, t235, stack; //obtenidoe el valor de i
+, t235, 1, t236;
<=, t234, t236, stack; // asignando a i
jmp, , ,L18; //regresando a la etiqueral del ciclo repetir mientras
L20:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 5, t237; // pos de g
+, P, 0, t238;
=>, t238, t239, stack; 
+, P, 7, t240;
+, t239, 0, t241;
<=, t240, t239, stack; 
+, P, 7, P;
call, , , persona_caracter_obtenerChar;
+, P, 1, t242;
=>, t242, t243, stack; // valor del return
-, P, 7, P;
<=, t237, t243, stack; // asignando a g
// -------------- Resolviendo para un ID (var local) ------------
+, p, 5, t244; // pos de g
=>, t244, t245, stack; // valor de lo que trae en el stack g
print("%c", t245);

L13:
end, , persona_vacio_persona_entero_caracter




begin, , , persona_caracter_obtenerChar

// RESOLVIENDO UN RETORNO
+, P, 1, t246; // pos de retorno de a funcion persona_caracter_obtenerChar
<=, t246, 75, stack; //asignando el retorno con su valor
jmp, , , L21;

L21:
end, , persona_caracter_obtenerChar




begin, , , persona_carro_retornoCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t247; // pos de c
<=, t247, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t248; // guardo la posicion donde inicia el objeto 
<=, h, t248, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t249; // pos de c
=>, t249, t250, stack; // obteniendo apuntador de c
+, p, 3, t251; // simulando cambio de ambito
+, t251, 0, t252; //pos del this de c
<=, t252, t250, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t253; // size de funcion actual
+, t253, 1, t254; //pos del parametro 1
<=, t254, 82, stack; // asignado al stack el parametro
+, 5, 5, t257;
*, t257, 2, t258;
+, p, 3, t255; // size de funcion actual
+, t255, 2, t256; //pos del parametro 2
<=, t256, t258, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter_entero;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t259; // pos de c
=>, t259, t260, stack; // valor de lo que trae en el stack c
+, P, 2, t261; // pos de retorno de a funcion persona_carro_retornoCarro
<=, t261, t260, stack; //asignando el retorno con su valor
jmp, , , L22;

L22:
end, , persona_carro_retornoCarro




begin, , , persona_entero_incrementarEdad

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t262; // pos this 
=>, t262, t263, stack; // obtenido apuntador al heap 
=>, t263, t264, heap; // apuntador 
+, t264, 0, t265; // pos de edad
=>, t265, t266, heap; // obtengo el valor que se encuentre en el heap 
+, t266, 1, t267;
+, P, 1, t268; // pos de retorno de a funcion persona_entero_incrementarEdad
<=, t268, t267, stack; //asignando el retorno con su valor
jmp, , , L23;

L23:
end, , persona_entero_incrementarEdad


