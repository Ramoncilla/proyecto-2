

begin, , , carro_vacio_carro

// ------------------------ Instanciando una nueva lista atributo --------------------
+, P, 0, t1; //pos this
=>, t1, t2, stack; // obtenienido apuntador al heap para la lista
=>, t2, t3, heap; //apauntador al heap para el objeto
+, t3, 0, t4; // pos donde inicia la lista
<=, t4, H, heap;
<=, H, -1, heap; // ingresando el size de la lista
+, H, 1, H;
<=, H, -1, heap; // ingresando el apuntador nulo a la lista
+, H, 3, H;

end, , carro_vacio_carro




begin, , , persona_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t5; // pos de p
<=, t5, h, stack; //guardando referencia del heap para el objeto p
+, h, 1, t6; // guardo la posicion donde inicia el objeto 
<=, h, t6, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 1, h; // reservando espacio para el objeto p
//Ingresando referencia al this del objeto p
+, p, 0, t7; // pos de p
=>, t7, t8, stack; // obteniendo apuntador de p
+, p, 1, t9; // simulando cambio de ambito
+, t9, 0, t10; //pos del this de p
<=, t10, t8, stack; // insertando apuntador del heap al stack del obeto p
// No posee parametros 
+, p, 1, p; // simulando cambio de ambito
call, , , persona_vacio_persona;
-, p, 1, p; // regresando al ambito acutal


end, , persona_PRINCIPAL




begin, , , persona_vacio_persona

// ----------- Instancia a un atributo --------------
+, p, 0, t11;// pos this de c
=>, t11, t12, stack; //apuntador del heap de c
=>, t12, t13, heap; //posicion real del heap donde inicia c
+, t13, 0, t14; //pos real del atributo c
<=, t14, h, heap; //guardando la pos real donde inicia el objeto c
+, h, 1, h; // reservando el espacio de memoria para el nuevo objeto c

// Guardando la referencia al this del objeto para la llamada al constructor c
+, p, 0, t15;
=>, t15, t16, stack; //apuntador al heap de c
=>, t16, t17, heap; //posicion real donde incia el objeto c
+, t17, 0, t18; // pos real donde incial el objeto c

+, p, 2, t19; // tamanho de la funcion actual persona_vacio_persona
+, t19, 0, t20; // pos del this para la nueva instancia de c
<=, t20, t18, stack; //guaradndo el puntero del this en el stack 

// No posee parametros 
+, p, 2, p; // simulando cambio de ambito
call, , , carro_vacio_carro;
-, p, 2, p; // regresando al ambito acutal

// Resolviendo un acceso para un atrinuto
+, P, 0, t21; 
=>, t21, t22, stack; // apuntador al heap
=>, t22, t23, heap;
+, t23, 0, t24; 
=>, t24, t25, heap; // recuperando pos incial del objeto
+, t25, 0, t26;
=>, t26, t25, heap; // pos inicial de otro objeto o valor de una vairble comun 
//-------------- Apiladndo elemento 
+, t25, 0, t27; // posicion de; size de una lista
=>, t27, t28, heap; // valor del size de una lista
+, t27, 1, t29; // pos de puntero
=>, t29, t30, heap; //valor del puntero
+, t29, 1, t31; // pos del indice
+, t31, 1, t32; // pos del valor
jmp, , , L1;
L1:
je, t30, -1, L2;
jmp, , , L3;
jmp, , ,L2;
L2:
+, t28, 1, t28; // incrementandor en uno el size de la lista
<=, t27, t28, heap; // guarnado el size de la lista
<=, t29, H, heap; // guardando el nuevo apuntador 
<=, t31, t28, heap; // guarando el indice del nuevo elemento
<=, t32, 100, heap; // guardando el valor del nuevo insert en la lista
<=, H, -1, heap; // ingresando el nulo del atributo siguiente
+, H, 3, H; // incrementado el h
jmp, , , L4;
jmp, , , L3;
L3:
+, t30, 0, t29; // pos del apuntador
=>, t29, t30, heap; // valor del apuntador
+, t29, 1, t31; // pos del indice
+, t31, 1, t32; //pos valor 
jmp, , , L1;
jmp, , , L4;
L4:
print("%d", t28);
// Resolviendo un acceso para un atrinuto
+, P, 0, t33; 
=>, t33, t34, stack; // apuntador al heap
=>, t34, t35, heap;
+, t35, 0, t36; 
=>, t36, t37, heap; // recuperando pos incial del objeto
+, t37, 0, t38;
=>, t38, t37, heap; // pos inicial de otro objeto o valor de una vairble comun 
//-------------- Apiladndo elemento 
+, t37, 0, t39; // posicion de; size de una lista
=>, t39, t40, heap; // valor del size de una lista
+, t39, 1, t41; // pos de puntero
=>, t41, t42, heap; //valor del puntero
+, t41, 1, t43; // pos del indice
+, t43, 1, t44; // pos del valor
jmp, , , L5;
L5:
je, t42, -1, L6;
jmp, , , L7;
jmp, , ,L6;
L6:
+, t40, 1, t40; // incrementandor en uno el size de la lista
<=, t39, t40, heap; // guarnado el size de la lista
<=, t41, H, heap; // guardando el nuevo apuntador 
<=, t43, t40, heap; // guarando el indice del nuevo elemento
<=, t44, 200, heap; // guardando el valor del nuevo insert en la lista
<=, H, -1, heap; // ingresando el nulo del atributo siguiente
+, H, 3, H; // incrementado el h
jmp, , , L8;
jmp, , , L7;
L7:
+, t42, 0, t41; // pos del apuntador
=>, t41, t42, heap; // valor del apuntador
+, t41, 1, t43; // pos del indice
+, t43, 1, t44; //pos valor 
jmp, , , L5;
jmp, , , L8;
L8:
print("%d", t40);
// Resolviendo un acceso para un atrinuto
+, P, 0, t45; 
=>, t45, t46, stack; // apuntador al heap
=>, t46, t47, heap;
+, t47, 0, t48; 
=>, t48, t49, heap; // recuperando pos incial del objeto
+, t49, 0, t50;
=>, t50, t49, heap; // pos inicial de otro objeto o valor de una vairble comun 
//-------------- Apiladndo elemento 
+, t49, 0, t51; // posicion de; size de una lista
=>, t51, t52, heap; // valor del size de una lista
+, t51, 1, t53; // pos de puntero
=>, t53, t54, heap; //valor del puntero
+, t53, 1, t55; // pos del indice
+, t55, 1, t56; // pos del valor
jmp, , , L9;
L9:
je, t54, -1, L10;
jmp, , , L11;
jmp, , ,L10;
L10:
+, t52, 1, t52; // incrementandor en uno el size de la lista
<=, t51, t52, heap; // guarnado el size de la lista
<=, t53, H, heap; // guardando el nuevo apuntador 
<=, t55, t52, heap; // guarando el indice del nuevo elemento
<=, t56, 300, heap; // guardando el valor del nuevo insert en la lista
<=, H, -1, heap; // ingresando el nulo del atributo siguiente
+, H, 3, H; // incrementado el h
jmp, , , L12;
jmp, , , L11;
L11:
+, t54, 0, t53; // pos del apuntador
=>, t53, t54, heap; // valor del apuntador
+, t53, 1, t55; // pos del indice
+, t55, 1, t56; //pos valor 
jmp, , , L9;
jmp, , , L12;
L12:
print("%d", t52);
// Resolviendo un acceso para un atrinuto
+, P, 0, t57; 
=>, t57, t58, stack; // apuntador al heap
=>, t58, t59, heap;
+, t59, 0, t60; 
=>, t60, t61, heap; // recuperando pos incial del objeto
+, t61, 0, t62;
=>, t62, t61, heap; // pos inicial de otro objeto o valor de una vairble comun 
+, t61, 0, t63; // posicion de; size de una lista
=>, t63, t64, heap; // valor del size de una lista
+, t63, 1, t65; // pos de puntero
=>, t65, t66, heap; //valor del puntero
+, t65, 1, t67; // pos del indice
+, t67, 1, t68; // pos del valor
=>, t67, t69, heap; // valor del indice actual
-, t64, 1, t72; // siguiente poscions a la que apuntara la cabeza de la pila
// ------ funcion desapilar de una pila  ---
jge, t72, 0, L13;
jmp, , , L14;
jmp, , , L13;
L13:
je, t72, t69, L15;
jmp, , , L16;
jmp, , , L15;
L15:
+, t65, 0, t71; // pos del puntero donde insertarmemos un nulo
+, t66, 0, t65;
=>, t65, t66, heap; // val del punteor del siguiente elmento
+, t65, 1, t67;
+, t67, 1, t68;
=>, t67, t69, heap; //valor del proximo indice
<=, t71, -1, heap; // direccionando a nulo (nueva cabeza de al pila)
jmp, , , L13;
jmp, , , L16;
L16:
je, t64, t69, L17;
jmp, , , L18;
jmp, , , L17;
L17:
=>, t68, t61, heap; // valor de la posicion que saldra de la pila
<=, t63, t72, heap; // cambiando el size de la pila
jmp, , , L19;
jmp, , , L18;
L18:
+, t66, 0, t65;
=>, t65, t66, heap; // val del punteor del siguiente elmento
+, t65, 1, t67;
+, t67, 1, t68;
=>, t67, t69, heap; //valor del proximo indice
jmp, , , L13;
jmp, , , L19;
L19:
jmp, , , L14;
L14:
print("%d", t61);
// Resolviendo un acceso para un atrinuto
+, P, 0, t73; 
=>, t73, t74, stack; // apuntador al heap
=>, t74, t75, heap;
+, t75, 0, t76; 
=>, t76, t77, heap; // recuperando pos incial del objeto
+, t77, 0, t78;
=>, t78, t77, heap; // pos inicial de otro objeto o valor de una vairble comun 
+, t77, 0, t79; // posicion de; size de una lista
=>, t79, t80, heap; // valor del size de una lista
+, t79, 1, t81; // pos de puntero
=>, t81, t82, heap; //valor del puntero
+, t81, 1, t83; // pos del indice
+, t83, 1, t84; // pos del valor
=>, t83, t85, heap; // valor del indice actual
-, t80, 1, t88; // siguiente poscions a la que apuntara la cabeza de la pila
// ------ funcion desapilar de una pila  ---
jge, t88, 0, L20;
jmp, , , L21;
jmp, , , L20;
L20:
je, t88, t85, L22;
jmp, , , L23;
jmp, , , L22;
L22:
+, t81, 0, t87; // pos del puntero donde insertarmemos un nulo
+, t82, 0, t81;
=>, t81, t82, heap; // val del punteor del siguiente elmento
+, t81, 1, t83;
+, t83, 1, t84;
=>, t83, t85, heap; //valor del proximo indice
<=, t87, -1, heap; // direccionando a nulo (nueva cabeza de al pila)
jmp, , , L20;
jmp, , , L23;
L23:
je, t80, t85, L24;
jmp, , , L25;
jmp, , , L24;
L24:
=>, t84, t77, heap; // valor de la posicion que saldra de la pila
<=, t79, t88, heap; // cambiando el size de la pila
jmp, , , L26;
jmp, , , L25;
L25:
+, t82, 0, t81;
=>, t81, t82, heap; // val del punteor del siguiente elmento
+, t81, 1, t83;
+, t83, 1, t84;
=>, t83, t85, heap; //valor del proximo indice
jmp, , , L20;
jmp, , , L26;
L26:
jmp, , , L21;
L21:
print("%d", t77);

end, , persona_vacio_persona


