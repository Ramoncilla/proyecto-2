

begin, , , Operaciones_vacio_cantar

// Resolviendo una cadena 
+, H, 0, t1; //apuntaodr a cadena 
+, H, 1, t2; //apu donde inicia la cadena
<=, t1, t2, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 9, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t3; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t1);

L1:
end, , Operaciones_vacio_cantar




begin, , , Operaciones_vacio_operaciones


L2:
end, , Operaciones_vacio_operaciones




begin, , , Operaciones_vacio_aritmeticas

// Resolviendo una cadena 
+, H, 0, t4; //apuntaodr a cadena 
+, H, 1, t5; //apu donde inicia la cadena
<=, t4, t5, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 36, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t6; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t4);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t7; // pos de temp1
*, 3, 7, t8;
/, 8, 2, t9;
-, t8, t9, t10;
-, 5, 10, t11;
*, 8, t11, t12;
-, t10, t12, t13;
<=, t7, t13, stack; // asignando a temp1
// ------------------------ Creando arreglo local texto
+, P, 2, t14; //pos de arreglo texto
<=, t14, H, stack; // ingrensando al stack apunt del heap para texto
+, H, 1, t15;
<=, H, t15, heap; //insetnado donde inicia el arreglo texto
+, H, 1, H;
// calculando el tamanho del arreglo
-, 50, 1, t16; //calculando el n real
-, t16, 0, t17; //iReal columna 0
+, t17, 1, t17; //size del arreglo texto
<=, H, t17, heap; // insertando el tamanio del arreglo linealizado texto
+, H, 1, H;
+, h, t17, h; // reservnado el espacio del arreglo texto
+, P, 2, t20; // pos del arreglo 
=>, t20, t21, stack; //apuntador al heap del arreglo
=>, t21, t22, heap; // apuntador del heap al heap donde inicia la cadena
=>, t22, t18, heap; // size del arreglo texto
+, t22, 1, t19; // pos 0 donde inicia el arreglo texto
// Resolviendo una cadena 
+, H, 0, t23; //apuntaodr a cadena 
+, H, 1, t24; //apu donde inicia la cadena
<=, t23, t24, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 13, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t25; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 46, heap; //guardadndo .
+, H, 1, H;
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 51, heap; //guardadndo 3
+, H, 1, H;
<=, H, 48, heap; //guardadndo 0
+, H, 1, H;
<=, H, 37, heap; //guardadndo %
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t23, t26, heap; // pos que apunta al size de la cadena
=>, t26, t27, heap; // size de la cadena
+, t26, 1, t28; // Pos 0 de la cadena
=>, t28, t29, heap; // sacandor el caracter del heap cadena
jle, t27, t18, L4;
jmp, , , L5;
jmp, , , L4;
L4:
jne, t29, 36, L6;
jmp, , , L7;
jmp, , , L6;
L6:
<=, t19, t29, heap; // guardando el caracter 
+, t19, 1, t19; // incremnetnado la pos del arreglo
+, t28, 1, t28; // incrementando la pos de la cadena
=>, t28, t29, heap; // sacandor el caracter del heap cadena
jmp, , , L4;
jmp, , , L7;
L7:
jmp, , , L5;
L5:
+, P, 2, t30;
=>, t30, t31, stack; 
=>, t31, t32, heap; 
=>, t32, t33, heap; // valor de size del arreglo texto
+, t32, 1, t34; // apuntador donde inicia el arreglo texto
=>, t34, t35, heap; // primer caracter del arreglo texto
+, H, 0, t36;
+, H, 1, t37;
<=, t36, t37, heap; 
+, H, 1, H;
+, 0, 0, t38;
<=, H, t38, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L8:
jne, t35, 36, L9;
jmp, , , L10;
L9:
<=, H, t35, heap; // ingresando el caracter 
+, H, 1, H;
+, t38, 1, t38; // incrementando en uno el size de la nueva cadena
+, t34, 1, t34;
=>, t34, t35, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L8;
L10:
<=, t37, t38, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t39; // pos de temp1
=>, t39, t40, stack; // valor de lo que trae en el stack temp1
// Resolviendo una cadena 
+, H, 0, t41; //apuntaodr a cadena 
+, H, 1, t42; //apu donde inicia la cadena
<=, t41, t42, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t43; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t44; //apuntaodr a cadena 
+, H, 1, t45; //apu donde inicia la cadena
<=, t44, t45, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t46; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// ---------------------------  Convertir a caden aun decimal ----
%#, t40, 0, t47; // parte entera del numero t40
!#, t40, 0, t48; // parte decimal del numero t40
// ---------------------------- Convertir parte entera a cadena ----------------
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t49; // inicio cad1 (inversa)
+, H, 1, t50;
<=, t49, t50, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t47, 0, t51;
+, 0, 0, t52;
+, 0, 0, t53;
+, 0, 0, t54;
+, t47, 0, t55;
L11:
jl, t52, t51, L12;
jmp, , , L13;
L12:
%%, t55, 0, t53;
+, t53, 48, t56;
<=, H, t56, heap;
+, H, 1, H; 
##, t55, 0, t55;
+, t52, 1, t52;
jmp, , , L11;
L13:
<=, H, 36, heap; 
+, H, 1, H;
<=, t50, t51, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t51, 0, t57;
+, t57, 0, t58;
+, t50, t57, t59; // pos inicial del primero caracter de la cadena
=>, t59, t60, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t61;
+, H, 1, t62;
<=, t61, t62, heap; 
+, H, 1, H;
+, H, 1, H;
L14:
jl, 0, t58, L15;
jmp, , , L16;
L15:
<=, H, t60, heap; // guardando caracterr actual
+, H, 1, H;
-, t59, 1, t59;
=>, t59, t60, heap;
-, t58, 1, t58;
jmp, , , L14;
L16:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t62, t57, heap;
// ----------------------  Crear cadena para el punto ------------------
+, H, 0, t63; //apuntador de cadena
+, H, 1, t64; // posicion donde iniciara la cadena
<=, t63, t64, heap; //insertando apuntador del heap donde incia la cadena
+, H, 1, H; // incrementando h
<=, H, 1, heap; //ingrensado el tamanho de la cadena nueva 
+, H, 1, H; // incrementando h
<=, H, 46, heap; // ingresnado caracter al heap
+, H, 1, H; // incrementando h
<=, H, 36, heap; //caracter de escape de la nueva cadena
+, H, 1, H; // incrementando h
// ----------------------- Concatenar parte entera con punto -----------------------
//Iniciando a concatnar cadenas 
=>, t61, t65, heap;
=>, t65, t66, heap; // size cadena1
+, t65, 1, t67; // pos 0 de la cadena 1
=>, t63, t68, heap;
=>, t68, t69, heap; // size cadena2
+, t68, 1, t70; // pos 0 de la cadena 2
+, t66, t69, t71; // size de la nueva cadena
=>, t67, t72, heap; // primer caracter de la cadena 1
=>, t70, t73, heap; // primer caracter de la cadena 2
+, H, 0, t74; // posicion de retorno de la cadena
+, H, 1, t75;
<=, t74, t75, heap;
+, H, 1, H;
<=, H, t71, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L17;
L17:
jne, t72, 36, L18;
jmp, , , L19;
jmp, , , L18;
L18:
<=, H, t72, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t67, 1, t67;
=>, t67, t72, heap;
jmp, , , L17;
jmp, , , L19;
L19:
jmp, , , L20;
L20:
jne, t73, 36, L21;
jmp, , , L22;
jmp, , , L21;
L21:
<=, H, t73, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t70, 1, t70;
=>, t70, t73, heap;
jmp, , , L20;
jmp, , , L22;
L22:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
// ------------------------------ Crear Cadena para parte decimal -------------------------
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t76; // inicio cad1 (inversa)
+, H, 1, t77;
<=, t76, t77, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t48, 0, t78;
+, 0, 0, t79;
+, 0, 0, t80;
+, 0, 0, t81;
+, t48, 0, t82;
L23:
jl, t79, t78, L24;
jmp, , , L25;
L24:
%%, t82, 0, t80;
+, t80, 48, t83;
<=, H, t83, heap;
+, H, 1, H; 
##, t82, 0, t82;
+, t79, 1, t79;
jmp, , , L23;
L25:
<=, H, 36, heap; 
+, H, 1, H;
<=, t77, t78, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t78, 0, t84;
+, t84, 0, t85;
+, t77, t84, t86; // pos inicial del primero caracter de la cadena
=>, t86, t87, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t88;
+, H, 1, t89;
<=, t88, t89, heap; 
+, H, 1, H;
+, H, 1, H;
L26:
jl, 0, t85, L27;
jmp, , , L28;
L27:
<=, H, t87, heap; // guardando caracterr actual
+, H, 1, H;
-, t86, 1, t86;
=>, t86, t87, heap;
-, t85, 1, t85;
jmp, , , L26;
L28:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t89, t84, heap;
// -------------------------- Concatenar parte entera con punto y parte decimal --------------------
//Iniciando a concatnar cadenas 
=>, t74, t90, heap;
=>, t90, t91, heap; // size cadena1
+, t90, 1, t92; // pos 0 de la cadena 1
=>, t88, t93, heap;
=>, t93, t94, heap; // size cadena2
+, t93, 1, t95; // pos 0 de la cadena 2
+, t91, t94, t96; // size de la nueva cadena
=>, t92, t97, heap; // primer caracter de la cadena 1
=>, t95, t98, heap; // primer caracter de la cadena 2
+, H, 0, t99; // posicion de retorno de la cadena
+, H, 1, t100;
<=, t99, t100, heap;
+, H, 1, H;
<=, H, t96, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L29;
L29:
jne, t97, 36, L30;
jmp, , , L31;
jmp, , , L30;
L30:
<=, H, t97, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t92, 1, t92;
=>, t92, t97, heap;
jmp, , , L29;
jmp, , , L31;
L31:
jmp, , , L32;
L32:
jne, t98, 36, L33;
jmp, , , L34;
jmp, , , L33;
L33:
<=, H, t98, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t95, 1, t95;
=>, t95, t98, heap;
jmp, , , L32;
jmp, , , L34;
L34:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t41, t101, heap;
=>, t101, t102, heap; // size cadena1
+, t101, 1, t103; // pos 0 de la cadena 1
=>, t99, t104, heap;
=>, t104, t105, heap; // size cadena2
+, t104, 1, t106; // pos 0 de la cadena 2
+, t102, t105, t107; // size de la nueva cadena
=>, t103, t108, heap; // primer caracter de la cadena 1
=>, t106, t109, heap; // primer caracter de la cadena 2
+, H, 0, t110; // posicion de retorno de la cadena
+, H, 1, t111;
<=, t110, t111, heap;
+, H, 1, H;
<=, H, t107, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L35;
L35:
jne, t108, 36, L36;
jmp, , , L37;
jmp, , , L36;
L36:
<=, H, t108, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t103, 1, t103;
=>, t103, t108, heap;
jmp, , , L35;
jmp, , , L37;
L37:
jmp, , , L38;
L38:
jne, t109, 36, L39;
jmp, , , L40;
jmp, , , L39;
L39:
<=, H, t109, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t106, 1, t106;
=>, t106, t109, heap;
jmp, , , L38;
jmp, , , L40;
L40:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t110, t112, heap;
=>, t112, t113, heap; // size cadena1
+, t112, 1, t114; // pos 0 de la cadena 1
=>, t44, t115, heap;
=>, t115, t116, heap; // size cadena2
+, t115, 1, t117; // pos 0 de la cadena 2
+, t113, t116, t118; // size de la nueva cadena
=>, t114, t119, heap; // primer caracter de la cadena 1
=>, t117, t120, heap; // primer caracter de la cadena 2
+, H, 0, t121; // posicion de retorno de la cadena
+, H, 1, t122;
<=, t121, t122, heap;
+, H, 1, H;
<=, H, t118, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L41;
L41:
jne, t119, 36, L42;
jmp, , , L43;
jmp, , , L42;
L42:
<=, H, t119, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t114, 1, t114;
=>, t114, t119, heap;
jmp, , , L41;
jmp, , , L43;
L43:
jmp, , , L44;
L44:
jne, t120, 36, L45;
jmp, , , L46;
jmp, , , L45;
L45:
<=, H, t120, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t117, 1, t117;
=>, t117, t120, heap;
jmp, , , L44;
jmp, , , L46;
L46:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t36, t123, heap;
=>, t123, t124, heap; // size cadena1
+, t123, 1, t125; // pos 0 de la cadena 1
=>, t121, t126, heap;
=>, t126, t127, heap; // size cadena2
+, t126, 1, t128; // pos 0 de la cadena 2
+, t124, t127, t129; // size de la nueva cadena
=>, t125, t130, heap; // primer caracter de la cadena 1
=>, t128, t131, heap; // primer caracter de la cadena 2
+, H, 0, t132; // posicion de retorno de la cadena
+, H, 1, t133;
<=, t132, t133, heap;
+, H, 1, H;
<=, H, t129, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L47;
L47:
jne, t130, 36, L48;
jmp, , , L49;
jmp, , , L48;
L48:
<=, H, t130, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t125, 1, t125;
=>, t125, t130, heap;
jmp, , , L47;
jmp, , , L49;
L49:
jmp, , , L50;
L50:
jne, t131, 36, L51;
jmp, , , L52;
jmp, , , L51;
L51:
<=, H, t131, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t128, 1, t128;
=>, t128, t131, heap;
jmp, , , L50;
jmp, , , L52;
L52:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t136; // pos del arreglo 
=>, t136, t137, stack; //apuntador al heap del arreglo
=>, t137, t138, heap; // apuntador del heap al heap donde inicia la cadena
=>, t138, t134, heap; // size del arreglo texto
+, t138, 1, t135; // pos 0 donde inicia el arreglo texto
=>, t132, t139, heap; // pos que apunta al size de la cadena
=>, t139, t140, heap; // size de la cadena
+, t139, 1, t141; // Pos 0 de la cadena
=>, t141, t142, heap; // sacandor el caracter del heap cadena
jle, t140, t134, L53;
jmp, , , L54;
jmp, , , L53;
L53:
jne, t142, 36, L55;
jmp, , , L56;
jmp, , , L55;
L55:
<=, t135, t142, heap; // guardando el caracter 
+, t135, 1, t135; // incremnetnado la pos del arreglo
+, t141, 1, t141; // incrementando la pos de la cadena
=>, t141, t142, heap; // sacandor el caracter del heap cadena
jmp, , , L53;
jmp, , , L56;
L56:
<= , t135, 36, heap; // extraaaaaaaaaaa
jmp, , , L54;
L54:
+, P, 2, t143;
=>, t143, t144, stack; 
=>, t144, t145, heap; 
=>, t145, t146, heap; // valor de size del arreglo texto
+, t145, 1, t147; // apuntador donde inicia el arreglo texto
=>, t147, t148, heap; // primer caracter del arreglo texto
+, H, 0, t149;
+, H, 1, t150;
<=, t149, t150, heap; 
+, H, 1, H;
+, 0, 0, t151;
<=, H, t151, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L57:
jne, t148, 36, L58;
jmp, , , L59;
L58:
<=, H, t148, heap; // ingresando el caracter 
+, H, 1, H;
+, t151, 1, t151; // incrementando en uno el size de la nueva cadena
+, t147, 1, t147;
=>, t147, t148, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L57;
L59:
<=, t150, t151, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t149);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t152; // pos de temp2
*, 3, 9, t153;
+, 0, t153, t154;
-, t154, 18, t155;
^, 3, 3, t156;
+, t155, t156, t157;
<=, t152, t157, stack; // asignando a temp2
// Resolviendo una cadena 
+, H, 0, t158; //apuntaodr a cadena 
+, H, 1, t159; //apu donde inicia la cadena
<=, t158, t159, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 13, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t160; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 46, heap; //guardadndo .
+, H, 1, H;
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 51, heap; //guardadndo 3
+, H, 1, H;
<=, H, 48, heap; //guardadndo 0
+, H, 1, H;
<=, H, 37, heap; //guardadndo %
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 2, t163; // pos del arreglo 
=>, t163, t164, stack; //apuntador al heap del arreglo
=>, t164, t165, heap; // apuntador del heap al heap donde inicia la cadena
=>, t165, t161, heap; // size del arreglo texto
+, t165, 1, t162; // pos 0 donde inicia el arreglo texto
=>, t158, t166, heap; // pos que apunta al size de la cadena
=>, t166, t167, heap; // size de la cadena
+, t166, 1, t168; // Pos 0 de la cadena
=>, t168, t169, heap; // sacandor el caracter del heap cadena
jle, t167, t161, L60;
jmp, , , L61;
jmp, , , L60;
L60:
jne, t169, 36, L62;
jmp, , , L63;
jmp, , , L62;
L62:
<=, t162, t169, heap; // guardando el caracter 
+, t162, 1, t162; // incremnetnado la pos del arreglo
+, t168, 1, t168; // incrementando la pos de la cadena
=>, t168, t169, heap; // sacandor el caracter del heap cadena
jmp, , , L60;
jmp, , , L63;
L63:
<= , t162, 36, heap; // extraaaaaaaaaaa
jmp, , , L61;
L61:
+, P, 2, t170;
=>, t170, t171, stack; 
=>, t171, t172, heap; 
=>, t172, t173, heap; // valor de size del arreglo texto
+, t172, 1, t174; // apuntador donde inicia el arreglo texto
=>, t174, t175, heap; // primer caracter del arreglo texto
+, H, 0, t176;
+, H, 1, t177;
<=, t176, t177, heap; 
+, H, 1, H;
+, 0, 0, t178;
<=, H, t178, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L64:
jne, t175, 36, L65;
jmp, , , L66;
L65:
<=, H, t175, heap; // ingresando el caracter 
+, H, 1, H;
+, t178, 1, t178; // incrementando en uno el size de la nueva cadena
+, t174, 1, t174;
=>, t174, t175, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L64;
L66:
<=, t177, t178, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t179; // pos de temp2
=>, t179, t180, stack; // valor de lo que trae en el stack temp2
// Resolviendo una cadena 
+, H, 0, t181; //apuntaodr a cadena 
+, H, 1, t182; //apu donde inicia la cadena
<=, t181, t182, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t183; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t184; //apuntaodr a cadena 
+, H, 1, t185; //apu donde inicia la cadena
<=, t184, t185, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t186; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t187; // inicio cad1 (inversa)
+, H, 1, t188;
<=, t187, t188, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t180, 0, t189;
+, 0, 0, t190;
+, 0, 0, t191;
+, 0, 0, t192;
+, t180, 0, t193;
L67:
jl, t190, t189, L68;
jmp, , , L69;
L68:
%%, t193, 0, t191;
+, t191, 48, t194;
<=, H, t194, heap;
+, H, 1, H; 
##, t193, 0, t193;
+, t190, 1, t190;
jmp, , , L67;
L69:
<=, H, 36, heap; 
+, H, 1, H;
<=, t188, t189, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t189, 0, t195;
+, t195, 0, t196;
+, t188, t195, t197; // pos inicial del primero caracter de la cadena
=>, t197, t198, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t199;
+, H, 1, t200;
<=, t199, t200, heap; 
+, H, 1, H;
+, H, 1, H;
L70:
jl, 0, t196, L71;
jmp, , , L72;
L71:
<=, H, t198, heap; // guardando caracterr actual
+, H, 1, H;
-, t197, 1, t197;
=>, t197, t198, heap;
-, t196, 1, t196;
jmp, , , L70;
L72:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t200, t195, heap;
//Iniciando a concatnar cadenas 
=>, t181, t201, heap;
=>, t201, t202, heap; // size cadena1
+, t201, 1, t203; // pos 0 de la cadena 1
=>, t199, t204, heap;
=>, t204, t205, heap; // size cadena2
+, t204, 1, t206; // pos 0 de la cadena 2
+, t202, t205, t207; // size de la nueva cadena
=>, t203, t208, heap; // primer caracter de la cadena 1
=>, t206, t209, heap; // primer caracter de la cadena 2
+, H, 0, t210; // posicion de retorno de la cadena
+, H, 1, t211;
<=, t210, t211, heap;
+, H, 1, H;
<=, H, t207, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L73;
L73:
jne, t208, 36, L74;
jmp, , , L75;
jmp, , , L74;
L74:
<=, H, t208, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t203, 1, t203;
=>, t203, t208, heap;
jmp, , , L73;
jmp, , , L75;
L75:
jmp, , , L76;
L76:
jne, t209, 36, L77;
jmp, , , L78;
jmp, , , L77;
L77:
<=, H, t209, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t206, 1, t206;
=>, t206, t209, heap;
jmp, , , L76;
jmp, , , L78;
L78:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t210, t212, heap;
=>, t212, t213, heap; // size cadena1
+, t212, 1, t214; // pos 0 de la cadena 1
=>, t184, t215, heap;
=>, t215, t216, heap; // size cadena2
+, t215, 1, t217; // pos 0 de la cadena 2
+, t213, t216, t218; // size de la nueva cadena
=>, t214, t219, heap; // primer caracter de la cadena 1
=>, t217, t220, heap; // primer caracter de la cadena 2
+, H, 0, t221; // posicion de retorno de la cadena
+, H, 1, t222;
<=, t221, t222, heap;
+, H, 1, H;
<=, H, t218, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L79;
L79:
jne, t219, 36, L80;
jmp, , , L81;
jmp, , , L80;
L80:
<=, H, t219, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t214, 1, t214;
=>, t214, t219, heap;
jmp, , , L79;
jmp, , , L81;
L81:
jmp, , , L82;
L82:
jne, t220, 36, L83;
jmp, , , L84;
jmp, , , L83;
L83:
<=, H, t220, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t217, 1, t217;
=>, t217, t220, heap;
jmp, , , L82;
jmp, , , L84;
L84:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t176, t223, heap;
=>, t223, t224, heap; // size cadena1
+, t223, 1, t225; // pos 0 de la cadena 1
=>, t221, t226, heap;
=>, t226, t227, heap; // size cadena2
+, t226, 1, t228; // pos 0 de la cadena 2
+, t224, t227, t229; // size de la nueva cadena
=>, t225, t230, heap; // primer caracter de la cadena 1
=>, t228, t231, heap; // primer caracter de la cadena 2
+, H, 0, t232; // posicion de retorno de la cadena
+, H, 1, t233;
<=, t232, t233, heap;
+, H, 1, H;
<=, H, t229, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L85;
L85:
jne, t230, 36, L86;
jmp, , , L87;
jmp, , , L86;
L86:
<=, H, t230, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t225, 1, t225;
=>, t225, t230, heap;
jmp, , , L85;
jmp, , , L87;
L87:
jmp, , , L88;
L88:
jne, t231, 36, L89;
jmp, , , L90;
jmp, , , L89;
L89:
<=, H, t231, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t228, 1, t228;
=>, t228, t231, heap;
jmp, , , L88;
jmp, , , L90;
L90:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t236; // pos del arreglo 
=>, t236, t237, stack; //apuntador al heap del arreglo
=>, t237, t238, heap; // apuntador del heap al heap donde inicia la cadena
=>, t238, t234, heap; // size del arreglo texto
+, t238, 1, t235; // pos 0 donde inicia el arreglo texto
=>, t232, t239, heap; // pos que apunta al size de la cadena
=>, t239, t240, heap; // size de la cadena
+, t239, 1, t241; // Pos 0 de la cadena
=>, t241, t242, heap; // sacandor el caracter del heap cadena
jle, t240, t234, L91;
jmp, , , L92;
jmp, , , L91;
L91:
jne, t242, 36, L93;
jmp, , , L94;
jmp, , , L93;
L93:
<=, t235, t242, heap; // guardando el caracter 
+, t235, 1, t235; // incremnetnado la pos del arreglo
+, t241, 1, t241; // incrementando la pos de la cadena
=>, t241, t242, heap; // sacandor el caracter del heap cadena
jmp, , , L91;
jmp, , , L94;
L94:
<= , t235, 36, heap; // extraaaaaaaaaaa
jmp, , , L92;
L92:
+, P, 2, t243;
=>, t243, t244, stack; 
=>, t244, t245, heap; 
=>, t245, t246, heap; // valor de size del arreglo texto
+, t245, 1, t247; // apuntador donde inicia el arreglo texto
=>, t247, t248, heap; // primer caracter del arreglo texto
+, H, 0, t249;
+, H, 1, t250;
<=, t249, t250, heap; 
+, H, 1, H;
+, 0, 0, t251;
<=, H, t251, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L95:
jne, t248, 36, L96;
jmp, , , L97;
L96:
<=, H, t248, heap; // ingresando el caracter 
+, H, 1, H;
+, t251, 1, t251; // incrementando en uno el size de la nueva cadena
+, t247, 1, t247;
=>, t247, t248, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L95;
L97:
<=, t250, t251, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t249);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t252; // pos de temp3
-, 8, 8, t253;
^, 2, 3, t254;
/, t254, 4, t255;
+, t253, t255, t256;
*, t256, 4, t257;
<=, t252, t257, stack; // asignando a temp3
// Resolviendo una cadena 
+, H, 0, t258; //apuntaodr a cadena 
+, H, 1, t259; //apu donde inicia la cadena
<=, t258, t259, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 13, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t260; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 46, heap; //guardadndo .
+, H, 1, H;
<=, H, 51, heap; //guardadndo 3
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 48, heap; //guardadndo 0
+, H, 1, H;
<=, H, 37, heap; //guardadndo %
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 2, t263; // pos del arreglo 
=>, t263, t264, stack; //apuntador al heap del arreglo
=>, t264, t265, heap; // apuntador del heap al heap donde inicia la cadena
=>, t265, t261, heap; // size del arreglo texto
+, t265, 1, t262; // pos 0 donde inicia el arreglo texto
=>, t258, t266, heap; // pos que apunta al size de la cadena
=>, t266, t267, heap; // size de la cadena
+, t266, 1, t268; // Pos 0 de la cadena
=>, t268, t269, heap; // sacandor el caracter del heap cadena
jle, t267, t261, L98;
jmp, , , L99;
jmp, , , L98;
L98:
jne, t269, 36, L100;
jmp, , , L101;
jmp, , , L100;
L100:
<=, t262, t269, heap; // guardando el caracter 
+, t262, 1, t262; // incremnetnado la pos del arreglo
+, t268, 1, t268; // incrementando la pos de la cadena
=>, t268, t269, heap; // sacandor el caracter del heap cadena
jmp, , , L98;
jmp, , , L101;
L101:
<= , t262, 36, heap; // extraaaaaaaaaaa
jmp, , , L99;
L99:
+, P, 2, t270;
=>, t270, t271, stack; 
=>, t271, t272, heap; 
=>, t272, t273, heap; // valor de size del arreglo texto
+, t272, 1, t274; // apuntador donde inicia el arreglo texto
=>, t274, t275, heap; // primer caracter del arreglo texto
+, H, 0, t276;
+, H, 1, t277;
<=, t276, t277, heap; 
+, H, 1, H;
+, 0, 0, t278;
<=, H, t278, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L102:
jne, t275, 36, L103;
jmp, , , L104;
L103:
<=, H, t275, heap; // ingresando el caracter 
+, H, 1, H;
+, t278, 1, t278; // incrementando en uno el size de la nueva cadena
+, t274, 1, t274;
=>, t274, t275, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L102;
L104:
<=, t277, t278, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t279; // pos de temp3
=>, t279, t280, stack; // valor de lo que trae en el stack temp3
// Resolviendo una cadena 
+, H, 0, t281; //apuntaodr a cadena 
+, H, 1, t282; //apu donde inicia la cadena
<=, t281, t282, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t283; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t284; //apuntaodr a cadena 
+, H, 1, t285; //apu donde inicia la cadena
<=, t284, t285, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t286; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// ---------------------------  Convertir a caden aun decimal ----
%#, t280, 0, t287; // parte entera del numero t280
!#, t280, 0, t288; // parte decimal del numero t280
// ---------------------------- Convertir parte entera a cadena ----------------
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t289; // inicio cad1 (inversa)
+, H, 1, t290;
<=, t289, t290, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t287, 0, t291;
+, 0, 0, t292;
+, 0, 0, t293;
+, 0, 0, t294;
+, t287, 0, t295;
L105:
jl, t292, t291, L106;
jmp, , , L107;
L106:
%%, t295, 0, t293;
+, t293, 48, t296;
<=, H, t296, heap;
+, H, 1, H; 
##, t295, 0, t295;
+, t292, 1, t292;
jmp, , , L105;
L107:
<=, H, 36, heap; 
+, H, 1, H;
<=, t290, t291, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t291, 0, t297;
+, t297, 0, t298;
+, t290, t297, t299; // pos inicial del primero caracter de la cadena
=>, t299, t300, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t301;
+, H, 1, t302;
<=, t301, t302, heap; 
+, H, 1, H;
+, H, 1, H;
L108:
jl, 0, t298, L109;
jmp, , , L110;
L109:
<=, H, t300, heap; // guardando caracterr actual
+, H, 1, H;
-, t299, 1, t299;
=>, t299, t300, heap;
-, t298, 1, t298;
jmp, , , L108;
L110:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t302, t297, heap;
// ----------------------  Crear cadena para el punto ------------------
+, H, 0, t303; //apuntador de cadena
+, H, 1, t304; // posicion donde iniciara la cadena
<=, t303, t304, heap; //insertando apuntador del heap donde incia la cadena
+, H, 1, H; // incrementando h
<=, H, 1, heap; //ingrensado el tamanho de la cadena nueva 
+, H, 1, H; // incrementando h
<=, H, 46, heap; // ingresnado caracter al heap
+, H, 1, H; // incrementando h
<=, H, 36, heap; //caracter de escape de la nueva cadena
+, H, 1, H; // incrementando h
// ----------------------- Concatenar parte entera con punto -----------------------
//Iniciando a concatnar cadenas 
=>, t301, t305, heap;
=>, t305, t306, heap; // size cadena1
+, t305, 1, t307; // pos 0 de la cadena 1
=>, t303, t308, heap;
=>, t308, t309, heap; // size cadena2
+, t308, 1, t310; // pos 0 de la cadena 2
+, t306, t309, t311; // size de la nueva cadena
=>, t307, t312, heap; // primer caracter de la cadena 1
=>, t310, t313, heap; // primer caracter de la cadena 2
+, H, 0, t314; // posicion de retorno de la cadena
+, H, 1, t315;
<=, t314, t315, heap;
+, H, 1, H;
<=, H, t311, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L111;
L111:
jne, t312, 36, L112;
jmp, , , L113;
jmp, , , L112;
L112:
<=, H, t312, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t307, 1, t307;
=>, t307, t312, heap;
jmp, , , L111;
jmp, , , L113;
L113:
jmp, , , L114;
L114:
jne, t313, 36, L115;
jmp, , , L116;
jmp, , , L115;
L115:
<=, H, t313, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t310, 1, t310;
=>, t310, t313, heap;
jmp, , , L114;
jmp, , , L116;
L116:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
// ------------------------------ Crear Cadena para parte decimal -------------------------
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t316; // inicio cad1 (inversa)
+, H, 1, t317;
<=, t316, t317, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t288, 0, t318;
+, 0, 0, t319;
+, 0, 0, t320;
+, 0, 0, t321;
+, t288, 0, t322;
L117:
jl, t319, t318, L118;
jmp, , , L119;
L118:
%%, t322, 0, t320;
+, t320, 48, t323;
<=, H, t323, heap;
+, H, 1, H; 
##, t322, 0, t322;
+, t319, 1, t319;
jmp, , , L117;
L119:
<=, H, 36, heap; 
+, H, 1, H;
<=, t317, t318, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t318, 0, t324;
+, t324, 0, t325;
+, t317, t324, t326; // pos inicial del primero caracter de la cadena
=>, t326, t327, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t328;
+, H, 1, t329;
<=, t328, t329, heap; 
+, H, 1, H;
+, H, 1, H;
L120:
jl, 0, t325, L121;
jmp, , , L122;
L121:
<=, H, t327, heap; // guardando caracterr actual
+, H, 1, H;
-, t326, 1, t326;
=>, t326, t327, heap;
-, t325, 1, t325;
jmp, , , L120;
L122:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t329, t324, heap;
// -------------------------- Concatenar parte entera con punto y parte decimal --------------------
//Iniciando a concatnar cadenas 
=>, t314, t330, heap;
=>, t330, t331, heap; // size cadena1
+, t330, 1, t332; // pos 0 de la cadena 1
=>, t328, t333, heap;
=>, t333, t334, heap; // size cadena2
+, t333, 1, t335; // pos 0 de la cadena 2
+, t331, t334, t336; // size de la nueva cadena
=>, t332, t337, heap; // primer caracter de la cadena 1
=>, t335, t338, heap; // primer caracter de la cadena 2
+, H, 0, t339; // posicion de retorno de la cadena
+, H, 1, t340;
<=, t339, t340, heap;
+, H, 1, H;
<=, H, t336, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L123;
L123:
jne, t337, 36, L124;
jmp, , , L125;
jmp, , , L124;
L124:
<=, H, t337, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t332, 1, t332;
=>, t332, t337, heap;
jmp, , , L123;
jmp, , , L125;
L125:
jmp, , , L126;
L126:
jne, t338, 36, L127;
jmp, , , L128;
jmp, , , L127;
L127:
<=, H, t338, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t335, 1, t335;
=>, t335, t338, heap;
jmp, , , L126;
jmp, , , L128;
L128:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t281, t341, heap;
=>, t341, t342, heap; // size cadena1
+, t341, 1, t343; // pos 0 de la cadena 1
=>, t339, t344, heap;
=>, t344, t345, heap; // size cadena2
+, t344, 1, t346; // pos 0 de la cadena 2
+, t342, t345, t347; // size de la nueva cadena
=>, t343, t348, heap; // primer caracter de la cadena 1
=>, t346, t349, heap; // primer caracter de la cadena 2
+, H, 0, t350; // posicion de retorno de la cadena
+, H, 1, t351;
<=, t350, t351, heap;
+, H, 1, H;
<=, H, t347, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L129;
L129:
jne, t348, 36, L130;
jmp, , , L131;
jmp, , , L130;
L130:
<=, H, t348, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t343, 1, t343;
=>, t343, t348, heap;
jmp, , , L129;
jmp, , , L131;
L131:
jmp, , , L132;
L132:
jne, t349, 36, L133;
jmp, , , L134;
jmp, , , L133;
L133:
<=, H, t349, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t346, 1, t346;
=>, t346, t349, heap;
jmp, , , L132;
jmp, , , L134;
L134:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t350, t352, heap;
=>, t352, t353, heap; // size cadena1
+, t352, 1, t354; // pos 0 de la cadena 1
=>, t284, t355, heap;
=>, t355, t356, heap; // size cadena2
+, t355, 1, t357; // pos 0 de la cadena 2
+, t353, t356, t358; // size de la nueva cadena
=>, t354, t359, heap; // primer caracter de la cadena 1
=>, t357, t360, heap; // primer caracter de la cadena 2
+, H, 0, t361; // posicion de retorno de la cadena
+, H, 1, t362;
<=, t361, t362, heap;
+, H, 1, H;
<=, H, t358, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L135;
L135:
jne, t359, 36, L136;
jmp, , , L137;
jmp, , , L136;
L136:
<=, H, t359, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t354, 1, t354;
=>, t354, t359, heap;
jmp, , , L135;
jmp, , , L137;
L137:
jmp, , , L138;
L138:
jne, t360, 36, L139;
jmp, , , L140;
jmp, , , L139;
L139:
<=, H, t360, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t357, 1, t357;
=>, t357, t360, heap;
jmp, , , L138;
jmp, , , L140;
L140:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t276, t363, heap;
=>, t363, t364, heap; // size cadena1
+, t363, 1, t365; // pos 0 de la cadena 1
=>, t361, t366, heap;
=>, t366, t367, heap; // size cadena2
+, t366, 1, t368; // pos 0 de la cadena 2
+, t364, t367, t369; // size de la nueva cadena
=>, t365, t370, heap; // primer caracter de la cadena 1
=>, t368, t371, heap; // primer caracter de la cadena 2
+, H, 0, t372; // posicion de retorno de la cadena
+, H, 1, t373;
<=, t372, t373, heap;
+, H, 1, H;
<=, H, t369, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L141;
L141:
jne, t370, 36, L142;
jmp, , , L143;
jmp, , , L142;
L142:
<=, H, t370, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t365, 1, t365;
=>, t365, t370, heap;
jmp, , , L141;
jmp, , , L143;
L143:
jmp, , , L144;
L144:
jne, t371, 36, L145;
jmp, , , L146;
jmp, , , L145;
L145:
<=, H, t371, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t368, 1, t368;
=>, t368, t371, heap;
jmp, , , L144;
jmp, , , L146;
L146:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t376; // pos del arreglo 
=>, t376, t377, stack; //apuntador al heap del arreglo
=>, t377, t378, heap; // apuntador del heap al heap donde inicia la cadena
=>, t378, t374, heap; // size del arreglo texto
+, t378, 1, t375; // pos 0 donde inicia el arreglo texto
=>, t372, t379, heap; // pos que apunta al size de la cadena
=>, t379, t380, heap; // size de la cadena
+, t379, 1, t381; // Pos 0 de la cadena
=>, t381, t382, heap; // sacandor el caracter del heap cadena
jle, t380, t374, L147;
jmp, , , L148;
jmp, , , L147;
L147:
jne, t382, 36, L149;
jmp, , , L150;
jmp, , , L149;
L149:
<=, t375, t382, heap; // guardando el caracter 
+, t375, 1, t375; // incremnetnado la pos del arreglo
+, t381, 1, t381; // incrementando la pos de la cadena
=>, t381, t382, heap; // sacandor el caracter del heap cadena
jmp, , , L147;
jmp, , , L150;
L150:
<= , t375, 36, heap; // extraaaaaaaaaaa
jmp, , , L148;
L148:
+, P, 2, t383;
=>, t383, t384, stack; 
=>, t384, t385, heap; 
=>, t385, t386, heap; // valor de size del arreglo texto
+, t385, 1, t387; // apuntador donde inicia el arreglo texto
=>, t387, t388, heap; // primer caracter del arreglo texto
+, H, 0, t389;
+, H, 1, t390;
<=, t389, t390, heap; 
+, H, 1, H;
+, 0, 0, t391;
<=, H, t391, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L151:
jne, t388, 36, L152;
jmp, , , L153;
L152:
<=, H, t388, heap; // ingresando el caracter 
+, H, 1, H;
+, t391, 1, t391; // incrementando en uno el size de la nueva cadena
+, t387, 1, t387;
=>, t387, t388, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L151;
L153:
<=, t390, t391, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t389);

L3:
end, , Operaciones_vacio_aritmeticas




begin, , , Operaciones_vacio_operaciones_relacionales

// Resolviendo una cadena 
+, H, 0, t392; //apuntaodr a cadena 
+, H, 1, t393; //apu donde inicia la cadena
<=, t392, t393, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 36, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t394; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t392);
-, 2, 10, t395;
jge, t395, 0, L156;
jmp, , , L157;
L156:

// Resolviendo una cadena 
+, H, 0, t396; //apuntaodr a cadena 
+, H, 1, t397; //apu donde inicia la cadena
<=, t396, t397, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t398; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t396);
jmp, , , L155; // salida del if
L157:

+, 15, 8, t399;
-, t399, 12, t400;
-, 22, 12, t401;
*, 5, 2, t402;
+, t401, t402, t403;
-, t403, 9, t404;
je, t400, t404, L159;
jmp, , , L160;
L159:

-, 11, 2, t405;
jne, 10, t405, L162;
jmp, , , L163;
L162:

// Resolviendo una cadena 
+, H, 0, t406; //apuntaodr a cadena 
+, H, 1, t407; //apu donde inicia la cadena
<=, t406, t407, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 17, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t408; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 69, heap; //guardadndo E
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 84, heap; //guardadndo T
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t406);
jmp, , , L161; // salida del if
L163:

// Resolviendo una cadena 
+, H, 0, t409; //apuntaodr a cadena 
+, H, 1, t410; //apu donde inicia la cadena
<=, t409, t410, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t411; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t409);
L161:
jmp, , , L158; // salida del if
L160:

je, 1, 1, L165;
jmp, , , L166;
L165:

// Resolviendo una cadena 
+, H, 0, t412; //apuntaodr a cadena 
+, H, 1, t413; //apu donde inicia la cadena
<=, t412, t413, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t414; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t412);
jmp, , , L164; // salida del if
L166:

// Resolviendo una cadena 
+, H, 0, t415; //apuntaodr a cadena 
+, H, 1, t416; //apu donde inicia la cadena
<=, t415, t416, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t417; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t415);
L164:
L158:
L155:

L154:
end, , Operaciones_vacio_operaciones_relacionales




begin, , , Operaciones_vacio_operaciones_logicas

// Resolviendo una cadena 
+, H, 0, t418; //apuntaodr a cadena 
+, H, 1, t419; //apu donde inicia la cadena
<=, t418, t419, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 32, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t420; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 54, heap; //guardadndo 6
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 76, heap; //guardadndo L
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 103, heap; //guardadndo g
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t418);
*, 15, 2, t421;
/, 98, 2, t424;
-, 6, 1, t425;
je, 15, 14, L169;
jmp, , , L170;
L170:

jge, t421, 15, L171;
jmp, , , L172;
L171:

+, 1, 0, t422;
jmp, , , L176;
L172:

+, 0, 0, t422;
jmp, , , L176;
jmp, , , L176;
L176:
jl, 12, 24, L173;
jmp, , , L174;
L173:

+, 1, 0, t423;
jmp, , , L177;
L174:

+, 0, 0, t423;
jmp, , , L177;
jmp, , , L177;
L177:
jne, t422, t423, L178;jmp, , , L179;
L179:

je, t424, 15, L180;
jmp, , , L181;
L181:

jne, 15, t425, L182;
jmp, , , L183;



L169:
L178:
L180:
L183:

// Resolviendo una cadena 
+, H, 0, t426; //apuntaodr a cadena 
+, H, 1, t427; //apu donde inicia la cadena
<=, t426, t427, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 17, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t428; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 69, heap; //guardadndo E
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 84, heap; //guardadndo T
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t426);
jmp, , , L168; // salida del if
L182:

// Resolviendo una cadena 
+, H, 0, t429; //apuntaodr a cadena 
+, H, 1, t430; //apu donde inicia la cadena
<=, t429, t430, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t431; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t429);
L168:

L167:
end, , Operaciones_vacio_operaciones_logicas




begin, , , Operaciones_vacio_operaciones_conjuntas

// Resolviendo una cadena 
+, H, 0, t432; //apuntaodr a cadena 
+, H, 1, t433; //apu donde inicia la cadena
<=, t432, t433, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 24, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t434; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 55, heap; //guardadndo 7
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 106, heap; //guardadndo j
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t432);
*, 5, 3, t435;
-, t435, 1, t436;
-, 6, 1, t437;
je, t436, 14, L186;
jmp, , , L187;
L187:

je, 15, t437, L188;
jmp, , , L189;

L188:

// Resolviendo una cadena 
+, H, 0, t438; //apuntaodr a cadena 
+, H, 1, t439; //apu donde inicia la cadena
<=, t438, t439, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t440; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t438);
jmp, , , L185; // salida del if
L186:
L189:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t441; // pos de var
<=, t441, 41, stack; // asignando a var
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t442; // pos de var2
<=, t442, 954, stack; // asignando a var2
// ------------------------ Creando arreglo local salida
+, P, 3, t443; //pos de arreglo salida
<=, t443, H, stack; // ingrensando al stack apunt del heap para salida
+, H, 1, t444;
<=, H, t444, heap; //insetnado donde inicia el arreglo salida
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t445; //calculando el n real
-, t445, 0, t446; //iReal columna 0
+, t446, 1, t446; //size del arreglo salida
<=, H, t446, heap; // insertando el tamanio del arreglo linealizado salida
+, H, 1, H;
+, h, t446, h; // reservnado el espacio del arreglo salida
+, P, 3, t449; // pos del arreglo 
=>, t449, t450, stack; //apuntador al heap del arreglo
=>, t450, t451, heap; // apuntador del heap al heap donde inicia la cadena
=>, t451, t447, heap; // size del arreglo salida
+, t451, 1, t448; // pos 0 donde inicia el arreglo salida
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t452; // pos de var
=>, t452, t453, stack; // valor de lo que trae en el stack var
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t454; // inicio cad1 (inversa)
+, H, 1, t455;
<=, t454, t455, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t453, 0, t456;
+, 0, 0, t457;
+, 0, 0, t458;
+, 0, 0, t459;
+, t453, 0, t460;
L190:
jl, t457, t456, L191;
jmp, , , L192;
L191:
%%, t460, 0, t458;
+, t458, 48, t461;
<=, H, t461, heap;
+, H, 1, H; 
##, t460, 0, t460;
+, t457, 1, t457;
jmp, , , L190;
L192:
<=, H, 36, heap; 
+, H, 1, H;
<=, t455, t456, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t456, 0, t462;
+, t462, 0, t463;
+, t455, t462, t464; // pos inicial del primero caracter de la cadena
=>, t464, t465, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t466;
+, H, 1, t467;
<=, t466, t467, heap; 
+, H, 1, H;
+, H, 1, H;
L193:
jl, 0, t463, L194;
jmp, , , L195;
L194:
<=, H, t465, heap; // guardando caracterr actual
+, H, 1, H;
-, t464, 1, t464;
=>, t464, t465, heap;
-, t463, 1, t463;
jmp, , , L193;
L195:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t467, t462, heap;
=>, t466, t468, heap; // pos que apunta al size de la cadena
=>, t468, t469, heap; // size de la cadena
+, t468, 1, t470; // Pos 0 de la cadena
=>, t470, t471, heap; // sacandor el caracter del heap cadena
jle, t469, t447, L196;
jmp, , , L197;
jmp, , , L196;
L196:
jne, t471, 36, L198;
jmp, , , L199;
jmp, , , L198;
L198:
<=, t448, t471, heap; // guardando el caracter 
+, t448, 1, t448; // incremnetnado la pos del arreglo
+, t470, 1, t470; // incrementando la pos de la cadena
=>, t470, t471, heap; // sacandor el caracter del heap cadena
jmp, , , L196;
jmp, , , L199;
L199:
jmp, , , L197;
L197:
+, P, 3, t472;
=>, t472, t473, stack; 
=>, t473, t474, heap; 
=>, t474, t475, heap; // valor de size del arreglo salida
+, t474, 1, t476; // apuntador donde inicia el arreglo salida
=>, t476, t477, heap; // primer caracter del arreglo salida
+, H, 0, t478;
+, H, 1, t479;
<=, t478, t479, heap; 
+, H, 1, H;
+, 0, 0, t480;
<=, H, t480, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L200:
jne, t477, 36, L201;
jmp, , , L202;
L201:
<=, H, t477, heap; // ingresando el caracter 
+, H, 1, H;
+, t480, 1, t480; // incrementando en uno el size de la nueva cadena
+, t476, 1, t476;
=>, t476, t477, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L200;
L202:
<=, t479, t480, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t481; // pos de var2
=>, t481, t482, stack; // valor de lo que trae en el stack var2
// Resolviendo una cadena 
+, H, 0, t483; //apuntaodr a cadena 
+, H, 1, t484; //apu donde inicia la cadena
<=, t483, t484, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t485; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t486; //apuntaodr a cadena 
+, H, 1, t487; //apu donde inicia la cadena
<=, t486, t487, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t488; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t489; // inicio cad1 (inversa)
+, H, 1, t490;
<=, t489, t490, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t482, 0, t491;
+, 0, 0, t492;
+, 0, 0, t493;
+, 0, 0, t494;
+, t482, 0, t495;
L203:
jl, t492, t491, L204;
jmp, , , L205;
L204:
%%, t495, 0, t493;
+, t493, 48, t496;
<=, H, t496, heap;
+, H, 1, H; 
##, t495, 0, t495;
+, t492, 1, t492;
jmp, , , L203;
L205:
<=, H, 36, heap; 
+, H, 1, H;
<=, t490, t491, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t491, 0, t497;
+, t497, 0, t498;
+, t490, t497, t499; // pos inicial del primero caracter de la cadena
=>, t499, t500, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t501;
+, H, 1, t502;
<=, t501, t502, heap; 
+, H, 1, H;
+, H, 1, H;
L206:
jl, 0, t498, L207;
jmp, , , L208;
L207:
<=, H, t500, heap; // guardando caracterr actual
+, H, 1, H;
-, t499, 1, t499;
=>, t499, t500, heap;
-, t498, 1, t498;
jmp, , , L206;
L208:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t502, t497, heap;
//Iniciando a concatnar cadenas 
=>, t483, t503, heap;
=>, t503, t504, heap; // size cadena1
+, t503, 1, t505; // pos 0 de la cadena 1
=>, t501, t506, heap;
=>, t506, t507, heap; // size cadena2
+, t506, 1, t508; // pos 0 de la cadena 2
+, t504, t507, t509; // size de la nueva cadena
=>, t505, t510, heap; // primer caracter de la cadena 1
=>, t508, t511, heap; // primer caracter de la cadena 2
+, H, 0, t512; // posicion de retorno de la cadena
+, H, 1, t513;
<=, t512, t513, heap;
+, H, 1, H;
<=, H, t509, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L209;
L209:
jne, t510, 36, L210;
jmp, , , L211;
jmp, , , L210;
L210:
<=, H, t510, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t505, 1, t505;
=>, t505, t510, heap;
jmp, , , L209;
jmp, , , L211;
L211:
jmp, , , L212;
L212:
jne, t511, 36, L213;
jmp, , , L214;
jmp, , , L213;
L213:
<=, H, t511, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t508, 1, t508;
=>, t508, t511, heap;
jmp, , , L212;
jmp, , , L214;
L214:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t512, t514, heap;
=>, t514, t515, heap; // size cadena1
+, t514, 1, t516; // pos 0 de la cadena 1
=>, t486, t517, heap;
=>, t517, t518, heap; // size cadena2
+, t517, 1, t519; // pos 0 de la cadena 2
+, t515, t518, t520; // size de la nueva cadena
=>, t516, t521, heap; // primer caracter de la cadena 1
=>, t519, t522, heap; // primer caracter de la cadena 2
+, H, 0, t523; // posicion de retorno de la cadena
+, H, 1, t524;
<=, t523, t524, heap;
+, H, 1, H;
<=, H, t520, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L215;
L215:
jne, t521, 36, L216;
jmp, , , L217;
jmp, , , L216;
L216:
<=, H, t521, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t516, 1, t516;
=>, t516, t521, heap;
jmp, , , L215;
jmp, , , L217;
L217:
jmp, , , L218;
L218:
jne, t522, 36, L219;
jmp, , , L220;
jmp, , , L219;
L219:
<=, H, t522, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t519, 1, t519;
=>, t519, t522, heap;
jmp, , , L218;
jmp, , , L220;
L220:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t478, t525, heap;
=>, t525, t526, heap; // size cadena1
+, t525, 1, t527; // pos 0 de la cadena 1
=>, t523, t528, heap;
=>, t528, t529, heap; // size cadena2
+, t528, 1, t530; // pos 0 de la cadena 2
+, t526, t529, t531; // size de la nueva cadena
=>, t527, t532, heap; // primer caracter de la cadena 1
=>, t530, t533, heap; // primer caracter de la cadena 2
+, H, 0, t534; // posicion de retorno de la cadena
+, H, 1, t535;
<=, t534, t535, heap;
+, H, 1, H;
<=, H, t531, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L221;
L221:
jne, t532, 36, L222;
jmp, , , L223;
jmp, , , L222;
L222:
<=, H, t532, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t527, 1, t527;
=>, t527, t532, heap;
jmp, , , L221;
jmp, , , L223;
L223:
jmp, , , L224;
L224:
jne, t533, 36, L225;
jmp, , , L226;
jmp, , , L225;
L225:
<=, H, t533, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t530, 1, t530;
=>, t530, t533, heap;
jmp, , , L224;
jmp, , , L226;
L226:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 3, t538; // pos del arreglo 
=>, t538, t539, stack; //apuntador al heap del arreglo
=>, t539, t540, heap; // apuntador del heap al heap donde inicia la cadena
=>, t540, t536, heap; // size del arreglo salida
+, t540, 1, t537; // pos 0 donde inicia el arreglo salida
=>, t534, t541, heap; // pos que apunta al size de la cadena
=>, t541, t542, heap; // size de la cadena
+, t541, 1, t543; // Pos 0 de la cadena
=>, t543, t544, heap; // sacandor el caracter del heap cadena
jle, t542, t536, L227;
jmp, , , L228;
jmp, , , L227;
L227:
jne, t544, 36, L229;
jmp, , , L230;
jmp, , , L229;
L229:
<=, t537, t544, heap; // guardando el caracter 
+, t537, 1, t537; // incremnetnado la pos del arreglo
+, t543, 1, t543; // incrementando la pos de la cadena
=>, t543, t544, heap; // sacandor el caracter del heap cadena
jmp, , , L227;
jmp, , , L230;
L230:
<= , t537, 36, heap; // extraaaaaaaaaaa
jmp, , , L228;
L228:
+, P, 3, t545;
=>, t545, t546, stack; 
=>, t546, t547, heap; 
=>, t547, t548, heap; // valor de size del arreglo salida
+, t547, 1, t549; // apuntador donde inicia el arreglo salida
=>, t549, t550, heap; // primer caracter del arreglo salida
+, H, 0, t551;
+, H, 1, t552;
<=, t551, t552, heap; 
+, H, 1, H;
+, 0, 0, t553;
<=, H, t553, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L231:
jne, t550, 36, L232;
jmp, , , L233;
L232:
<=, H, t550, heap; // ingresando el caracter 
+, H, 1, H;
+, t553, 1, t553; // incrementando en uno el size de la nueva cadena
+, t549, 1, t549;
=>, t549, t550, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L231;
L233:
<=, t552, t553, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t551);
+, P, 3, t554;
=>, t554, t555, stack; 
=>, t555, t556, heap; 
=>, t556, t557, heap; // valor de size del arreglo salida
+, t556, 1, t558; // apuntador donde inicia el arreglo salida
=>, t558, t559, heap; // primer caracter del arreglo salida
+, H, 0, t560;
+, H, 1, t561;
<=, t560, t561, heap; 
+, H, 1, H;
+, 0, 0, t562;
<=, H, t562, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L235:
jne, t559, 36, L236;
jmp, , , L237;
L236:
<=, H, t559, heap; // ingresando el caracter 
+, H, 1, H;
+, t562, 1, t562; // incrementando en uno el size de la nueva cadena
+, t558, 1, t558;
=>, t558, t559, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L235;
L237:
<=, t561, t562, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t563; //apuntaodr a cadena 
+, H, 1, t564; //apu donde inicia la cadena
<=, t563, t564, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t565; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 57, heap; //guardadndo 9
+, H, 1, H;
<=, H, 53, heap; //guardadndo 5
+, H, 1, H;
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// ------------ Obtenieido suma de caracteres de una cadena --------
=>, t563, t566, heap; // apunt al heap donde inicia la cadena
+, t566, 1, t567; // pos donde incia la cadena
=>, t567, t568, heap; // valor caracter  de la cadena
+, 0, 0, t569; //acumulador de la cadena
jmp, , , L240;
L240: //etiquera ciclo suma cadena
jne, t568, 36, L241;
jmp, , , L242;
L241:
+, t569, t568, t569; // sumando los caracteres 
+, t567, 1, t567; // sumando una posicion
=>, t567, t568, heap; // obteniendo el valor del caracter 
jmp, , , L240;
L242:
// ------------ Obtenieido suma de caracteres de una cadena --------
=>, t560, t570, heap; // apunt al heap donde inicia la cadena
+, t570, 1, t571; // pos donde incia la cadena
=>, t571, t572, heap; // valor caracter  de la cadena
+, 0, 0, t573; //acumulador de la cadena
jmp, , , L243;
L243: //etiquera ciclo suma cadena
jne, t572, 36, L244;
jmp, , , L245;
L244:
+, t573, t572, t573; // sumando los caracteres 
+, t571, 1, t571; // sumando una posicion
=>, t571, t572, heap; // obteniendo el valor del caracter 
jmp, , , L243;
L245:
je, t573, t569, L238;
jmp, , , L239;
L238:

// Resolviendo una cadena 
+, H, 0, t574; //apuntaodr a cadena 
+, H, 1, t575; //apu donde inicia la cadena
<=, t574, t575, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 16, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t576; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 57, heap; //guardadndo 9
+, H, 1, H;
<=, H, 53, heap; //guardadndo 5
+, H, 1, H;
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t574);
jmp, , , L234; // salida del if
L239:

// Resolviendo una cadena 
+, H, 0, t577; //apuntaodr a cadena 
+, H, 1, t578; //apu donde inicia la cadena
<=, t577, t578, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t579; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t577);
L234:
L185:

L184:
end, , Operaciones_vacio_operaciones_conjuntas




begin, , , Inicio_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t580; // pos de op
<=, t580, h, stack; //guardando referencia del heap para el objeto op
+, h, 1, t581; // guardo la posicion donde inicia el objeto 
<=, h, t581, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 0, h; // reservando espacio para el objeto op
//Ingresando referencia al this del objeto op
+, p, 0, t582; // pos de op
=>, t582, t583, stack; // obteniendo apuntador de op
+, p, 2, t584; // simulando cambio de ambito
+, t584, 0, t585; //pos del this de op
<=, t585, t583, stack; // insertando apuntador del heap al stack del obeto op
// No posee parametros 
+, p, 2, p; // simulando cambio de ambito
call, , , Operaciones_vacio_operaciones;
-, p, 2, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t586; // pos del objeto
=>, t586, t588, stack; //apuntador al heap del obejto
+, P, 6, t589;
+, t589, 0, t590;
<=, t590, t588, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 6, P;
call, , , Operaciones_vacio_aritmeticas;
+, P, 5, t591;
=>, t591, t592, stack; // valor del return
-, P, 6, P;
=>, t591, t593, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 0, t594; // pos del objeto
=>, t594, t596, stack; //apuntador al heap del obejto
+, P, 2, t597;
+, t597, 0, t598;
<=, t598, t596, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 2, P;
call, , , Operaciones_vacio_operaciones_relacionales;
+, P, 1, t599;
=>, t599, t600, stack; // valor del return
-, P, 2, P;
=>, t599, t601, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 0, t602; // pos del objeto
=>, t602, t604, stack; //apuntador al heap del obejto
+, P, 2, t605;
+, t605, 0, t606;
<=, t606, t604, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 2, P;
call, , , Operaciones_vacio_operaciones_logicas;
+, P, 1, t607;
=>, t607, t608, stack; // valor del return
-, P, 2, P;
=>, t607, t609, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 0, t610; // pos del objeto
=>, t610, t612, stack; //apuntador al heap del obejto
+, P, 5, t613;
+, t613, 0, t614;
<=, t614, t612, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 5, P;
call, , , Operaciones_vacio_operaciones_conjuntas;
+, P, 4, t615;
=>, t615, t616, stack; // valor del return
-, P, 5, P;
=>, t615, t617, stack; // valor a retoranar del acceso
// ----------- Instancia a una variable local --------------
+, p, 1, t618; // pos de fun
<=, t618, h, stack; //guardando referencia del heap para el objeto fun
+, h, 1, t619; // guardo la posicion donde inicia el objeto 
<=, h, t619, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 0, h; // reservando espacio para el objeto fun
//Ingresando referencia al this del objeto fun
+, p, 1, t620; // pos de fun
=>, t620, t621, stack; // obteniendo apuntador de fun
+, p, 2, t622; // simulando cambio de ambito
+, t622, 0, t623; //pos del this de fun
<=, t623, t621, stack; // insertando apuntador del heap al stack del obeto fun
// No posee parametros 
+, p, 2, p; // simulando cambio de ambito
call, , , Funciones_vacio_funciones;
-, p, 2, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 1, t624; // pos del objeto
=>, t624, t626, stack; //apuntador al heap del obejto
+, P, 3, t627;
+, t627, 0, t628;
<=, t628, t626, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 3, P;
call, , , Funciones_vacio_saludo;
+, P, 2, t629;
=>, t629, t630, stack; // valor del return
-, P, 3, P;
=>, t629, t631, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 1, t632; // pos del objeto
=>, t632, t634, stack; //apuntador al heap del obejto
+, P, 7, t635;
+, t635, 0, t636;
<=, t636, t634, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 7, P;
call, , , Funciones_vacio_ciclo_vida;
+, P, 6, t637;
=>, t637, t638, stack; // valor del return
-, P, 7, P;
=>, t637, t639, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 1, t640; // pos del objeto
=>, t640, t642, stack; //apuntador al heap del obejto
+, P, 4, t643;
+, t643, 0, t644;
<=, t644, t642, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 4, t645; // size de funcion actual
+, t645, 1, t646; //pos del parametro 1
<=, t646, 10, stack; // asignado al stack el parametro
+, P, 4, P;
call, , , Funciones_decimal_factorial2_entero;
+, P, 3, t647;
=>, t647, t648, stack; // valor del return
-, P, 4, P;
=>, t647, t649, stack; // valor a retoranar del acceso
print("%f", t649);

L246:
end, , Inicio_PRINCIPAL




begin, , , Funciones_vacio_funciones


L247:
end, , Funciones_vacio_funciones




begin, , , Funciones_decimal_factorial2_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t650; // pos de n
=>, t650, t651, stack; // valor de lo que trae en el stack n
je, t651, 0, L250;
jmp, , , L251;
L250:

// RESOLVIENDO UN RETORNO
+, P, 3, t652; // pos de retorno de a funcion Funciones_decimal_factorial2_entero
<=, t652, 1, stack; //asignando el retorno con su valor
jmp, , , L248;
jmp, , , L249; // salida del if
L251:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t653; // pos de i
+, P, 0, t654;
=>, t654, t655, stack; 
+, P, 4, t656;
+, t655, 0, t657;
<=, t656, t655, stack; 
// Asignando parametros de llamada a funcion  
+, p, 4, t658; // size de funcion actual
+, t658, 1, t659; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t660; // pos de n
=>, t660, t661, stack; // valor de lo que trae en el stack n
-, t661, 1, t662;
<=, t659, t662, stack; // asignado al stack el parametro
+, P, 4, P;
call, , , Funciones_decimal_factorial2_entero;
+, P, 3, t663;
=>, t663, t664, stack; // valor del return
-, P, 4, P;
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t665; // pos de n
=>, t665, t666, stack; // valor de lo que trae en el stack n
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t667; // pos de i
=>, t667, t668, stack; // valor de lo que trae en el stack i
*, t666, t668, t669;
L249:

L248:
end, , Funciones_decimal_factorial2_entero




begin, , , Funciones_decimal_factorial_entero

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t670; // pos de fact
<=, t670, 1, stack; // asignando a fact
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t671; // pos de n
=>, t671, t672, stack; // valor de lo que trae en el stack n
je, t672, 0, L254;
jmp, , , L255;
L254:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t673; // pos de fact
<=, t673, 1, stack; // asignando a fact
jmp, , , L253; // salida del if
L255:

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t674; // pos de n
=>, t674, t675, stack; // valor de lo que trae en el stack n
 // ------------------ Inicio ciclo repetir contando -----------------
+, P, 4, t676; // pos de k
<=, t676, 1, stack; // asignando con el valor de desde la vairable k
=>, t676, t677, stack; // obteniendo el valor de  desde k
jne, t677, t675, L256;
jmp, , , L257;
L256:
jl, t677, t675, L258;
jmp, , , L259;
L258:
+, 1, 0, t678;
jmp, , , L260;
L259:
+, -1, 0, t678;
jmp, , , L260;
L260:
-, t675, t677, t679;
*, t679, t678, t679;
+, 0, 0, t680; // iniciando la viairrble pivote del ciclo repetir contando
L261:
jle, t680, t679, L262;
jmp, , , L263;
L262:
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t681; // pos de fact
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t682; // pos de fact
=>, t682, t683, stack; // valor de lo que trae en el stack fact
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t684; // pos de k
=>, t684, t685, stack; // valor de lo que trae en el stack k
*, t683, t685, t686;
<=, t681, t686, stack; // asignando a fact
L264:
+, t677, t678, t677; // nuevo valor de la variable del ciclo k
+, t680, 1, t680;
<=, t676, t677, stack; // asignando a k
jmp, , , L261;
L263:
L257:
L265:
 // ------------------ Fin ciclo repetir contando-----------------
L253:
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t687; // pos de fact
=>, t687, t688, stack; // valor de lo que trae en el stack fact
+, P, 5, t689; // pos de retorno de a funcion Funciones_decimal_factorial_entero
<=, t689, t688, stack; //asignando el retorno con su valor
jmp, , , L252;

L252:
end, , Funciones_decimal_factorial_entero




begin, , , Funciones_vacio_saludo

// Resolviendo una cadena 
+, H, 0, t690; //apuntaodr a cadena 
+, H, 1, t691; //apu donde inicia la cadena
<=, t690, t691, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 10, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t692; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 48, heap; //guardadndo 0
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t690);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t693; // pos de conta
<=, t693, 0, stack; // asignando a conta
// ---------- Resolver Hacer Mientras ----------- 
L267:
// --------------------- Inicio evaluar_si --------------------------
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t694; // pos de conta
=>, t694, t695, stack; // valor de lo que trae en el stack conta
je, t695, 0, L271; // verdadero del caso 1
jmp, , , L275; // falsa del caso 1
L275:
je, t695, 1, L272; // verdadero del caso 2
jmp, , , L276; // falsa del caso 2
L276:
je, t695, 2, L273; // verdadero del caso 3
jmp, , , L277; // falsa del caso 3
L277:
je, t695, 3, L274; // verdadero del caso 4
jmp, , , L278; // falsa del caso 4
L278:
jmp, , , L279; // ir al por defecto
L271:
// Resolviendo una cadena 
+, H, 0, t696; //apuntaodr a cadena 
+, H, 1, t697; //apu donde inicia la cadena
<=, t696, t697, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t698; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 69, heap; //guardadndo E
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t696);
jmp, , , L270; // haciendo un romper 
L272:
// Resolviendo una cadena 
+, H, 0, t699; //apuntaodr a cadena 
+, H, 1, t700; //apu donde inicia la cadena
<=, t699, t700, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 7, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t701; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t699);
jmp, , , L270; // haciendo un romper 
L273:
// Resolviendo una cadena 
+, H, 0, t702; //apuntaodr a cadena 
+, H, 1, t703; //apu donde inicia la cadena
<=, t702, t703, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 3, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t704; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t702);
jmp, , , L270; // haciendo un romper 
L274:
// Resolviendo una cadena 
+, H, 0, t705; //apuntaodr a cadena 
+, H, 1, t706; //apu donde inicia la cadena
<=, t705, t706, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 11, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t707; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 69, heap; //guardadndo E
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 84, heap; //guardadndo T
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t705);
jmp, , , L270; // haciendo un romper 
L279:
// Resolviendo una cadena 
+, H, 0, t708; //apuntaodr a cadena 
+, H, 1, t709; //apu donde inicia la cadena
<=, t708, t709, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 20, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t710; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t708);
L270: // break de evaluar _si
// --------------------- Fin evaluar_si --------------------------
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t711; // pos de conta
=>, t711, t712, stack; // valor de lo que trae en el stack conta
+, t712, 1, t713;
<=, t711, t713, STACK; // asignando operaicon con unario
L269: //etiqueta del conituar
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t714; // pos de conta
=>, t714, t715, stack; // valor de lo que trae en el stack conta
jl, t715, 4, L280;
jmp, , , L281;
L280:

jmp, , , L267;
L281:

L268:

L266:
end, , Funciones_vacio_saludo




begin, , , Funciones_vacio_ciclo_vida

// Resolviendo una cadena 
+, H, 0, t716; //apuntaodr a cadena 
+, H, 1, t717; //apu donde inicia la cadena
<=, t716, t717, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 14, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t718; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 95, heap; //guardadndo _
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t716);
// ----------- Instancia a una variable local --------------
+, p, 1, t719; // pos de carlos
<=, t719, h, stack; //guardando referencia del heap para el objeto carlos
+, h, 1, t720; // guardo la posicion donde inicia el objeto 
<=, h, t720, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 5, h; // reservando espacio para el objeto carlos
//Ingresando referencia al this del objeto carlos
+, p, 1, t721; // pos de carlos
=>, t721, t722, stack; // obteniendo apuntador de carlos
+, p, 7, t723; // simulando cambio de ambito
+, t723, 0, t724; //pos del this de carlos
<=, t724, t722, stack; // insertando apuntador del heap al stack del obeto carlos
// Asignando parametros  
+, p, 7, t725; // size de funcion actual
+, t725, 1, t726; //pos del parametro 1
<=, t726, 16, stack; // asignado al stack el parametro
+, p, 7, t727; // size de funcion actual
+, t727, 2, t728; //pos del parametro 2
// declarando parametros  arreglo de tipo nombre2
// ------------------------ Creando arreglo local nombre2
+, P, t728, t729; //pos de arreglo nombre2
<=, t729, H, stack; // ingrensando al stack apunt del heap para nombre2
+, H, 1, t730;
<=, H, t730, heap; //insetnado donde inicia el arreglo nombre2
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t731; //calculando el n real
-, t731, 0, t732; //iReal columna 0
+, t732, 1, t732; //size del arreglo nombre2
<=, H, t732, heap; // insertando el tamanio del arreglo linealizado nombre2
+, H, 1, H;
+, h, t732, h; // reservnado el espacio del arreglo nombre2
// Resolviendo una cadena 
+, H, 0, t733; //apuntaodr a cadena 
+, H, 1, t734; //apu donde inicia la cadena
<=, t733, t734, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t735; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 74, heap; //guardadndo J
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t728, t733, stack; // asignado al stack el parametro
+, p, 7, t736; // size de funcion actual
+, t736, 3, t737; //pos del parametro 3
// declarando parametros  arreglo de tipo apellido2
// ------------------------ Creando arreglo local apellido2
+, P, t737, t738; //pos de arreglo apellido2
<=, t738, H, stack; // ingrensando al stack apunt del heap para apellido2
+, H, 1, t739;
<=, H, t739, heap; //insetnado donde inicia el arreglo apellido2
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t740; //calculando el n real
-, t740, 0, t741; //iReal columna 0
+, t741, 1, t741; //size del arreglo apellido2
<=, H, t741, heap; // insertando el tamanio del arreglo linealizado apellido2
+, H, 1, H;
+, h, t741, h; // reservnado el espacio del arreglo apellido2
// Resolviendo una cadena 
+, H, 0, t742; //apuntaodr a cadena 
+, H, 1, t743; //apu donde inicia la cadena
<=, t742, t743, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t744; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 77, heap; //guardadndo M
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t737, t742, stack; // asignado al stack el parametro
+, p, 7, t745; // size de funcion actual
+, t745, 4, t746; //pos del parametro 4
<=, t746, 77, stack; // asignado al stack el parametro
+, p, 7, p; // simulando cambio de ambito
call, , , Persona_vacio_Persona_entero_caracter_caracter_caracter;
-, p, 7, p; // regresando al ambito acutal

// ----------- Instancia a una variable local --------------
+, p, 2, t747; // pos de Josefina
<=, t747, h, stack; //guardando referencia del heap para el objeto Josefina
+, h, 1, t748; // guardo la posicion donde inicia el objeto 
<=, h, t748, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 5, h; // reservando espacio para el objeto Josefina
//Ingresando referencia al this del objeto Josefina
+, p, 2, t749; // pos de Josefina
=>, t749, t750, stack; // obteniendo apuntador de Josefina
+, p, 7, t751; // simulando cambio de ambito
+, t751, 0, t752; //pos del this de Josefina
<=, t752, t750, stack; // insertando apuntador del heap al stack del obeto Josefina
// Asignando parametros  
+, p, 7, t753; // size de funcion actual
+, t753, 1, t754; //pos del parametro 1
<=, t754, 15, stack; // asignado al stack el parametro
+, p, 7, t755; // size de funcion actual
+, t755, 2, t756; //pos del parametro 2
// declarando parametros  arreglo de tipo nombre2
// ------------------------ Creando arreglo local nombre2
+, P, t756, t757; //pos de arreglo nombre2
<=, t757, H, stack; // ingrensando al stack apunt del heap para nombre2
+, H, 1, t758;
<=, H, t758, heap; //insetnado donde inicia el arreglo nombre2
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t759; //calculando el n real
-, t759, 0, t760; //iReal columna 0
+, t760, 1, t760; //size del arreglo nombre2
<=, H, t760, heap; // insertando el tamanio del arreglo linealizado nombre2
+, H, 1, H;
+, h, t760, h; // reservnado el espacio del arreglo nombre2
// Resolviendo una cadena 
+, H, 0, t761; //apuntaodr a cadena 
+, H, 1, t762; //apu donde inicia la cadena
<=, t761, t762, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t763; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 76, heap; //guardadndo L
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t756, t761, stack; // asignado al stack el parametro
+, p, 7, t764; // size de funcion actual
+, t764, 3, t765; //pos del parametro 3
// declarando parametros  arreglo de tipo apellido2
// ------------------------ Creando arreglo local apellido2
+, P, t765, t766; //pos de arreglo apellido2
<=, t766, H, stack; // ingrensando al stack apunt del heap para apellido2
+, H, 1, t767;
<=, H, t767, heap; //insetnado donde inicia el arreglo apellido2
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t768; //calculando el n real
-, t768, 0, t769; //iReal columna 0
+, t769, 1, t769; //size del arreglo apellido2
<=, H, t769, heap; // insertando el tamanio del arreglo linealizado apellido2
+, H, 1, H;
+, h, t769, h; // reservnado el espacio del arreglo apellido2
// Resolviendo una cadena 
+, H, 0, t770; //apuntaodr a cadena 
+, H, 1, t771; //apu donde inicia la cadena
<=, t770, t771, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t772; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 84, heap; //guardadndo T
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t765, t770, stack; // asignado al stack el parametro
+, p, 7, t773; // size de funcion actual
+, t773, 4, t774; //pos del parametro 4
<=, t774, 70, stack; // asignado al stack el parametro
+, p, 7, p; // simulando cambio de ambito
call, , , Persona_vacio_Persona_entero_caracter_caracter_caracter;
-, p, 7, p; // regresando al ambito acutal

// ----------- Instancia a una variable local --------------
+, p, 3, t775; // pos de Carlitos
<=, t775, h, stack; //guardando referencia del heap para el objeto Carlitos
+, h, 1, t776; // guardo la posicion donde inicia el objeto 
<=, h, t776, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 5, h; // reservando espacio para el objeto Carlitos
//Ingresando referencia al this del objeto Carlitos
+, p, 3, t777; // pos de Carlitos
=>, t777, t778, stack; // obteniendo apuntador de Carlitos
+, p, 7, t779; // simulando cambio de ambito
+, t779, 0, t780; //pos del this de Carlitos
<=, t780, t778, stack; // insertando apuntador del heap al stack del obeto Carlitos
// No posee parametros 
+, p, 7, p; // simulando cambio de ambito
call, , , Persona_vacio_Persona;
-, p, 7, p; // regresando al ambito acutal

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t781; // pos de cont
<=, t781, 0, stack; // asignando a cont
// Resolviendo un repetur mientras
jmp, , ,L283; //regresando a la etiqueral del ciclo repetir- mientras
L283:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t782; // pos de cont
=>, t782, t783, stack; // valor de lo que trae en el stack cont
jl, t783, 4, L284;
jmp, , , L285;
L284:

// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t784; // pos de cont
=>, t784, t785, stack; // valor de lo que trae en el stack cont
+, t785, 1, t786;
<=, t784, t786, STACK; // asignando operaicon con unario
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t787; // pos de cont
=>, t787, t788, stack; // valor de lo que trae en el stack cont
je, t788, 4, L287;
jmp, , , L288;
L287:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t789; // pos de Carlitos
// ----------------- Resolviendo acceso local 
+, P, 1, t790; // pos del objeto
=>, t790, t792, stack; //apuntador al heap del obejto
+, P, 6, t793;
+, t793, 0, t794;
<=, t794, t792, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 6, t795; // size de funcion actual
+, t795, 1, t796; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t797; // pos de Josefina
=>, t797, t798, stack; // valor de lo que trae en el stack Josefina
<=, t796, t798, stack; // asignado al stack el parametro
+, p, 6, t799; // size de funcion actual
+, t799, 2, t800; //pos del parametro 2
// declarando parametros  arreglo de tipo nombre
// ------------------------ Creando arreglo local nombre
+, P, t800, t801; //pos de arreglo nombre
<=, t801, H, stack; // ingrensando al stack apunt del heap para nombre
+, H, 1, t802;
<=, H, t802, heap; //insetnado donde inicia el arreglo nombre
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t803; //calculando el n real
-, t803, 0, t804; //iReal columna 0
+, t804, 1, t804; //size del arreglo nombre
<=, H, t804, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, h, t804, h; // reservnado el espacio del arreglo nombre
// Resolviendo una cadena 
+, H, 0, t805; //apuntaodr a cadena 
+, H, 1, t806; //apu donde inicia la cadena
<=, t805, t806, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t807; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t800, t805, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Persona_Persona_reproducir_Persona_caracter;
+, P, 5, t808;
=>, t808, t809, stack; // valor del return
-, P, 6, P;
=>, t808, t810, stack; // valor a retoranar del acceso
<=, t789, t810, stack; // asignando a Carlitos
// ----------------- Resolviendo acceso local 
+, P, 2, t811; // pos del objeto
=>, t811, t813, stack; //apuntador al heap del obejto
+, P, 4, t814;
+, t814, 0, t815;
<=, t815, t813, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 4, t816; // size de funcion actual
+, t816, 1, t817; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t818; // pos de Carlos
=>, t818, t819, stack; // valor de lo que trae en el stack Carlos
<=, t817, t819, stack; // asignado al stack el parametro
+, P, 4, P;
call, , , Persona_vacio_matrimonio_Persona;
+, P, 3, t820;
=>, t820, t821, stack; // valor del return
-, P, 4, P;
=>, t820, t822, stack; // valor a retoranar del acceso
// ------------------------ Creando arreglo local text
+, P, 5, t823; //pos de arreglo text
<=, t823, H, stack; // ingrensando al stack apunt del heap para text
+, H, 1, t824;
<=, H, t824, heap; //insetnado donde inicia el arreglo text
+, H, 1, H;
// calculando el tamanho del arreglo
-, 80, 1, t825; //calculando el n real
-, t825, 0, t826; //iReal columna 0
+, t826, 1, t826; //size del arreglo text
<=, H, t826, heap; // insertando el tamanio del arreglo linealizado text
+, H, 1, H;
+, h, t826, h; // reservnado el espacio del arreglo text
+, P, 5, t829; // pos del arreglo 
=>, t829, t830, stack; //apuntador al heap del arreglo
=>, t830, t831, heap; // apuntador del heap al heap donde inicia la cadena
=>, t831, t827, heap; // size del arreglo text
+, t831, 1, t828; // pos 0 donde inicia el arreglo text
// Resolviendo una cadena 
+, H, 0, t832; //apuntaodr a cadena 
+, H, 1, t833; //apu donde inicia la cadena
<=, t832, t833, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 13, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t834; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 78, heap; //guardadndo N
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 72, heap; //guardadndo H
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 106, heap; //guardadndo j
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t832, t835, heap; // pos que apunta al size de la cadena
=>, t835, t836, heap; // size de la cadena
+, t835, 1, t837; // Pos 0 de la cadena
=>, t837, t838, heap; // sacandor el caracter del heap cadena
jle, t836, t827, L289;
jmp, , , L290;
jmp, , , L289;
L289:
jne, t838, 36, L291;
jmp, , , L292;
jmp, , , L291;
L291:
<=, t828, t838, heap; // guardando el caracter 
+, t828, 1, t828; // incremnetnado la pos del arreglo
+, t837, 1, t837; // incrementando la pos de la cadena
=>, t837, t838, heap; // sacandor el caracter del heap cadena
jmp, , , L289;
jmp, , , L292;
L292:
jmp, , , L290;
L290:
// ----------------- Resolviendo acceso local 
+, P, 3, t839; // pos del objeto
=>, t839, t841, stack; //apuntador al heap del obejto
=>, t841, t842, heap; // recuperando pos incial del objeto
+, t842, 0, t841;
=>, t841, t843, heap; // valor a retoranar del acceso
print("%a", t841);
+, P, 5, t844;
=>, t844, t845, stack; 
=>, t845, t846, heap; 
=>, t846, t847, heap; // valor de size del arreglo text
+, t846, 1, t848; // apuntador donde inicia el arreglo text
=>, t848, t849, heap; // primer caracter del arreglo text
+, H, 0, t850;
+, H, 1, t851;
<=, t850, t851, heap; 
+, H, 1, H;
+, 0, 0, t852;
<=, H, t852, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L293:
jne, t849, 36, L294;
jmp, , , L295;
L294:
<=, H, t849, heap; // ingresando el caracter 
+, H, 1, H;
+, t852, 1, t852; // incrementando en uno el size de la nueva cadena
+, t848, 1, t848;
=>, t848, t849, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L293;
L295:
<=, t851, t852, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 3, t853; // pos del objeto
=>, t853, t855, stack; //apuntador al heap del obejto
=>, t855, t856, heap; // recuperando pos incial del objeto
+, t856, 0, t855;
=>, t855, t857, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t858;
+, H, 1, t859;
<=, t858, t859, heap;
+, H, 1, H;
+, H, 1, H;
=>, t855, t860, heap; 
+, t860, 1, t861;
=>, t861, t862, heap; // caracter actual
+, 0, 0, t863;
L296:
jne, t862, 36, L297;
jmp, , , L298;
L297:
+, t863, 1, t863;
<=, H, t862, heap;
+, H, 1, H;
+, t861, 1, t861;
=>, t861, t862, heap; // caracter actual
jmp, , , L296;
L298:
<=, H, 36, heap;
+, H, 1, H;
<=, t859, t863, heap;
//Iniciando a concatnar cadenas 
=>, t850, t864, heap;
=>, t864, t865, heap; // size cadena1
+, t864, 1, t866; // pos 0 de la cadena 1
=>, t858, t867, heap;
=>, t867, t868, heap; // size cadena2
+, t867, 1, t869; // pos 0 de la cadena 2
+, t865, t868, t870; // size de la nueva cadena
=>, t866, t871, heap; // primer caracter de la cadena 1
=>, t869, t872, heap; // primer caracter de la cadena 2
+, H, 0, t873; // posicion de retorno de la cadena
+, H, 1, t874;
<=, t873, t874, heap;
+, H, 1, H;
<=, H, t870, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L299;
L299:
jne, t871, 36, L300;
jmp, , , L301;
jmp, , , L300;
L300:
<=, H, t871, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t866, 1, t866;
=>, t866, t871, heap;
jmp, , , L299;
jmp, , , L301;
L301:
jmp, , , L302;
L302:
jne, t872, 36, L303;
jmp, , , L304;
jmp, , , L303;
L303:
<=, H, t872, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t869, 1, t869;
=>, t869, t872, heap;
jmp, , , L302;
jmp, , , L304;
L304:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 5, t877; // pos del arreglo 
=>, t877, t878, stack; //apuntador al heap del arreglo
=>, t878, t879, heap; // apuntador del heap al heap donde inicia la cadena
=>, t879, t875, heap; // size del arreglo text
+, t879, 1, t876; // pos 0 donde inicia el arreglo text
=>, t873, t880, heap; // pos que apunta al size de la cadena
=>, t880, t881, heap; // size de la cadena
+, t880, 1, t882; // Pos 0 de la cadena
=>, t882, t883, heap; // sacandor el caracter del heap cadena
jle, t881, t875, L305;
jmp, , , L306;
jmp, , , L305;
L305:
jne, t883, 36, L307;
jmp, , , L308;
jmp, , , L307;
L307:
<=, t876, t883, heap; // guardando el caracter 
+, t876, 1, t876; // incremnetnado la pos del arreglo
+, t882, 1, t882; // incrementando la pos de la cadena
=>, t882, t883, heap; // sacandor el caracter del heap cadena
jmp, , , L305;
jmp, , , L308;
L308:
<= , t876, 36, heap; // extraaaaaaaaaaa
jmp, , , L306;
L306:
+, P, 5, t884;
=>, t884, t885, stack; 
=>, t885, t886, heap; 
=>, t886, t887, heap; // valor de size del arreglo text
+, t886, 1, t888; // apuntador donde inicia el arreglo text
=>, t888, t889, heap; // primer caracter del arreglo text
+, H, 0, t890;
+, H, 1, t891;
<=, t890, t891, heap; 
+, H, 1, H;
+, 0, 0, t892;
<=, H, t892, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L309:
jne, t889, 36, L310;
jmp, , , L311;
L310:
<=, H, t889, heap; // ingresando el caracter 
+, H, 1, H;
+, t892, 1, t892; // incrementando en uno el size de la nueva cadena
+, t888, 1, t888;
=>, t888, t889, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L309;
L311:
<=, t891, t892, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 3, t893; // pos del objeto
=>, t893, t895, stack; //apuntador al heap del obejto
=>, t895, t896, heap; // recuperando pos incial del objeto
+, t896, 4, t895;
=>, t895, t897, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t898;
+, H, 1, t899;
<=, t898, t899, heap;
+, H, 1, H;
+, H, 1, H;
=>, t895, t900, heap; 
+, t900, 1, t901;
=>, t901, t902, heap; // caracter actual
+, 0, 0, t903;
L312:
jne, t902, 36, L313;
jmp, , , L314;
L313:
+, t903, 1, t903;
<=, H, t902, heap;
+, H, 1, H;
+, t901, 1, t901;
=>, t901, t902, heap; // caracter actual
jmp, , , L312;
L314:
<=, H, 36, heap;
+, H, 1, H;
<=, t899, t903, heap;
//Iniciando a concatnar cadenas 
=>, t890, t904, heap;
=>, t904, t905, heap; // size cadena1
+, t904, 1, t906; // pos 0 de la cadena 1
=>, t898, t907, heap;
=>, t907, t908, heap; // size cadena2
+, t907, 1, t909; // pos 0 de la cadena 2
+, t905, t908, t910; // size de la nueva cadena
=>, t906, t911, heap; // primer caracter de la cadena 1
=>, t909, t912, heap; // primer caracter de la cadena 2
+, H, 0, t913; // posicion de retorno de la cadena
+, H, 1, t914;
<=, t913, t914, heap;
+, H, 1, H;
<=, H, t910, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L315;
L315:
jne, t911, 36, L316;
jmp, , , L317;
jmp, , , L316;
L316:
<=, H, t911, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t906, 1, t906;
=>, t906, t911, heap;
jmp, , , L315;
jmp, , , L317;
L317:
jmp, , , L318;
L318:
jne, t912, 36, L319;
jmp, , , L320;
jmp, , , L319;
L319:
<=, H, t912, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t909, 1, t909;
=>, t909, t912, heap;
jmp, , , L318;
jmp, , , L320;
L320:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 5, t917; // pos del arreglo 
=>, t917, t918, stack; //apuntador al heap del arreglo
=>, t918, t919, heap; // apuntador del heap al heap donde inicia la cadena
=>, t919, t915, heap; // size del arreglo text
+, t919, 1, t916; // pos 0 donde inicia el arreglo text
=>, t913, t920, heap; // pos que apunta al size de la cadena
=>, t920, t921, heap; // size de la cadena
+, t920, 1, t922; // Pos 0 de la cadena
=>, t922, t923, heap; // sacandor el caracter del heap cadena
jle, t921, t915, L321;
jmp, , , L322;
jmp, , , L321;
L321:
jne, t923, 36, L323;
jmp, , , L324;
jmp, , , L323;
L323:
<=, t916, t923, heap; // guardando el caracter 
+, t916, 1, t916; // incremnetnado la pos del arreglo
+, t922, 1, t922; // incrementando la pos de la cadena
=>, t922, t923, heap; // sacandor el caracter del heap cadena
jmp, , , L321;
jmp, , , L324;
L324:
<= , t916, 36, heap; // extraaaaaaaaaaa
jmp, , , L322;
L322:
+, P, 5, t924;
=>, t924, t925, stack; 
=>, t925, t926, heap; 
=>, t926, t927, heap; // valor de size del arreglo text
+, t926, 1, t928; // apuntador donde inicia el arreglo text
=>, t928, t929, heap; // primer caracter del arreglo text
+, H, 0, t930;
+, H, 1, t931;
<=, t930, t931, heap; 
+, H, 1, H;
+, 0, 0, t932;
<=, H, t932, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L325:
jne, t929, 36, L326;
jmp, , , L327;
L326:
<=, H, t929, heap; // ingresando el caracter 
+, H, 1, H;
+, t932, 1, t932; // incrementando en uno el size de la nueva cadena
+, t928, 1, t928;
=>, t928, t929, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L325;
L327:
<=, t931, t932, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t930);
// Resolviendo una cadena 
+, H, 0, t933; //apuntaodr a cadena 
+, H, 1, t934; //apu donde inicia la cadena
<=, t933, t934, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 15, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t935; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 78, heap; //guardadndo N
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 5, t938; // pos del arreglo 
=>, t938, t939, stack; //apuntador al heap del arreglo
=>, t939, t940, heap; // apuntador del heap al heap donde inicia la cadena
=>, t940, t936, heap; // size del arreglo text
+, t940, 1, t937; // pos 0 donde inicia el arreglo text
=>, t933, t941, heap; // pos que apunta al size de la cadena
=>, t941, t942, heap; // size de la cadena
+, t941, 1, t943; // Pos 0 de la cadena
=>, t943, t944, heap; // sacandor el caracter del heap cadena
jle, t942, t936, L328;
jmp, , , L329;
jmp, , , L328;
L328:
jne, t944, 36, L330;
jmp, , , L331;
jmp, , , L330;
L330:
<=, t937, t944, heap; // guardando el caracter 
+, t937, 1, t937; // incremnetnado la pos del arreglo
+, t943, 1, t943; // incrementando la pos de la cadena
=>, t943, t944, heap; // sacandor el caracter del heap cadena
jmp, , , L328;
jmp, , , L331;
L331:
<= , t937, 36, heap; // extraaaaaaaaaaa
jmp, , , L329;
L329:
// ----------------- Resolviendo acceso local 
+, P, 2, t945; // pos del objeto
=>, t945, t947, stack; //apuntador al heap del obejto
=>, t947, t948, heap; // recuperando pos incial del objeto
+, t948, 0, t947;
=>, t947, t949, heap; // valor a retoranar del acceso
print("%a", t947);
+, P, 5, t950;
=>, t950, t951, stack; 
=>, t951, t952, heap; 
=>, t952, t953, heap; // valor de size del arreglo text
+, t952, 1, t954; // apuntador donde inicia el arreglo text
=>, t954, t955, heap; // primer caracter del arreglo text
+, H, 0, t956;
+, H, 1, t957;
<=, t956, t957, heap; 
+, H, 1, H;
+, 0, 0, t958;
<=, H, t958, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L332:
jne, t955, 36, L333;
jmp, , , L334;
L333:
<=, H, t955, heap; // ingresando el caracter 
+, H, 1, H;
+, t958, 1, t958; // incrementando en uno el size de la nueva cadena
+, t954, 1, t954;
=>, t954, t955, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L332;
L334:
<=, t957, t958, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 2, t959; // pos del objeto
=>, t959, t961, stack; //apuntador al heap del obejto
=>, t961, t962, heap; // recuperando pos incial del objeto
+, t962, 0, t961;
=>, t961, t963, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t964;
+, H, 1, t965;
<=, t964, t965, heap;
+, H, 1, H;
+, H, 1, H;
=>, t961, t966, heap; 
+, t966, 1, t967;
=>, t967, t968, heap; // caracter actual
+, 0, 0, t969;
L335:
jne, t968, 36, L336;
jmp, , , L337;
L336:
+, t969, 1, t969;
<=, H, t968, heap;
+, H, 1, H;
+, t967, 1, t967;
=>, t967, t968, heap; // caracter actual
jmp, , , L335;
L337:
<=, H, 36, heap;
+, H, 1, H;
<=, t965, t969, heap;
//Iniciando a concatnar cadenas 
=>, t956, t970, heap;
=>, t970, t971, heap; // size cadena1
+, t970, 1, t972; // pos 0 de la cadena 1
=>, t964, t973, heap;
=>, t973, t974, heap; // size cadena2
+, t973, 1, t975; // pos 0 de la cadena 2
+, t971, t974, t976; // size de la nueva cadena
=>, t972, t977, heap; // primer caracter de la cadena 1
=>, t975, t978, heap; // primer caracter de la cadena 2
+, H, 0, t979; // posicion de retorno de la cadena
+, H, 1, t980;
<=, t979, t980, heap;
+, H, 1, H;
<=, H, t976, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L338;
L338:
jne, t977, 36, L339;
jmp, , , L340;
jmp, , , L339;
L339:
<=, H, t977, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t972, 1, t972;
=>, t972, t977, heap;
jmp, , , L338;
jmp, , , L340;
L340:
jmp, , , L341;
L341:
jne, t978, 36, L342;
jmp, , , L343;
jmp, , , L342;
L342:
<=, H, t978, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t975, 1, t975;
=>, t975, t978, heap;
jmp, , , L341;
jmp, , , L343;
L343:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 5, t983; // pos del arreglo 
=>, t983, t984, stack; //apuntador al heap del arreglo
=>, t984, t985, heap; // apuntador del heap al heap donde inicia la cadena
=>, t985, t981, heap; // size del arreglo text
+, t985, 1, t982; // pos 0 donde inicia el arreglo text
=>, t979, t986, heap; // pos que apunta al size de la cadena
=>, t986, t987, heap; // size de la cadena
+, t986, 1, t988; // Pos 0 de la cadena
=>, t988, t989, heap; // sacandor el caracter del heap cadena
jle, t987, t981, L344;
jmp, , , L345;
jmp, , , L344;
L344:
jne, t989, 36, L346;
jmp, , , L347;
jmp, , , L346;
L346:
<=, t982, t989, heap; // guardando el caracter 
+, t982, 1, t982; // incremnetnado la pos del arreglo
+, t988, 1, t988; // incrementando la pos de la cadena
=>, t988, t989, heap; // sacandor el caracter del heap cadena
jmp, , , L344;
jmp, , , L347;
L347:
<= , t982, 36, heap; // extraaaaaaaaaaa
jmp, , , L345;
L345:
+, P, 5, t990;
=>, t990, t991, stack; 
=>, t991, t992, heap; 
=>, t992, t993, heap; // valor de size del arreglo text
+, t992, 1, t994; // apuntador donde inicia el arreglo text
=>, t994, t995, heap; // primer caracter del arreglo text
+, H, 0, t996;
+, H, 1, t997;
<=, t996, t997, heap; 
+, H, 1, H;
+, 0, 0, t998;
<=, H, t998, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L348:
jne, t995, 36, L349;
jmp, , , L350;
L349:
<=, H, t995, heap; // ingresando el caracter 
+, H, 1, H;
+, t998, 1, t998; // incrementando en uno el size de la nueva cadena
+, t994, 1, t994;
=>, t994, t995, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L348;
L350:
<=, t997, t998, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 2, t999; // pos del objeto
=>, t999, t1001, stack; //apuntador al heap del obejto
=>, t1001, t1002, heap; // recuperando pos incial del objeto
+, t1002, 4, t1001;
=>, t1001, t1003, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t1004;
+, H, 1, t1005;
<=, t1004, t1005, heap;
+, H, 1, H;
+, H, 1, H;
=>, t1001, t1006, heap; 
+, t1006, 1, t1007;
=>, t1007, t1008, heap; // caracter actual
+, 0, 0, t1009;
L351:
jne, t1008, 36, L352;
jmp, , , L353;
L352:
+, t1009, 1, t1009;
<=, H, t1008, heap;
+, H, 1, H;
+, t1007, 1, t1007;
=>, t1007, t1008, heap; // caracter actual
jmp, , , L351;
L353:
<=, H, 36, heap;
+, H, 1, H;
<=, t1005, t1009, heap;
//Iniciando a concatnar cadenas 
=>, t996, t1010, heap;
=>, t1010, t1011, heap; // size cadena1
+, t1010, 1, t1012; // pos 0 de la cadena 1
=>, t1004, t1013, heap;
=>, t1013, t1014, heap; // size cadena2
+, t1013, 1, t1015; // pos 0 de la cadena 2
+, t1011, t1014, t1016; // size de la nueva cadena
=>, t1012, t1017, heap; // primer caracter de la cadena 1
=>, t1015, t1018, heap; // primer caracter de la cadena 2
+, H, 0, t1019; // posicion de retorno de la cadena
+, H, 1, t1020;
<=, t1019, t1020, heap;
+, H, 1, H;
<=, H, t1016, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L354;
L354:
jne, t1017, 36, L355;
jmp, , , L356;
jmp, , , L355;
L355:
<=, H, t1017, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1012, 1, t1012;
=>, t1012, t1017, heap;
jmp, , , L354;
jmp, , , L356;
L356:
jmp, , , L357;
L357:
jne, t1018, 36, L358;
jmp, , , L359;
jmp, , , L358;
L358:
<=, H, t1018, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1015, 1, t1015;
=>, t1015, t1018, heap;
jmp, , , L357;
jmp, , , L359;
L359:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 5, t1023; // pos del arreglo 
=>, t1023, t1024, stack; //apuntador al heap del arreglo
=>, t1024, t1025, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1025, t1021, heap; // size del arreglo text
+, t1025, 1, t1022; // pos 0 donde inicia el arreglo text
=>, t1019, t1026, heap; // pos que apunta al size de la cadena
=>, t1026, t1027, heap; // size de la cadena
+, t1026, 1, t1028; // Pos 0 de la cadena
=>, t1028, t1029, heap; // sacandor el caracter del heap cadena
jle, t1027, t1021, L360;
jmp, , , L361;
jmp, , , L360;
L360:
jne, t1029, 36, L362;
jmp, , , L363;
jmp, , , L362;
L362:
<=, t1022, t1029, heap; // guardando el caracter 
+, t1022, 1, t1022; // incremnetnado la pos del arreglo
+, t1028, 1, t1028; // incrementando la pos de la cadena
=>, t1028, t1029, heap; // sacandor el caracter del heap cadena
jmp, , , L360;
jmp, , , L363;
L363:
<= , t1022, 36, heap; // extraaaaaaaaaaa
jmp, , , L361;
L361:
+, P, 5, t1030;
=>, t1030, t1031, stack; 
=>, t1031, t1032, heap; 
=>, t1032, t1033, heap; // valor de size del arreglo text
+, t1032, 1, t1034; // apuntador donde inicia el arreglo text
=>, t1034, t1035, heap; // primer caracter del arreglo text
+, H, 0, t1036;
+, H, 1, t1037;
<=, t1036, t1037, heap; 
+, H, 1, H;
+, 0, 0, t1038;
<=, H, t1038, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L364:
jne, t1035, 36, L365;
jmp, , , L366;
L365:
<=, H, t1035, heap; // ingresando el caracter 
+, H, 1, H;
+, t1038, 1, t1038; // incrementando en uno el size de la nueva cadena
+, t1034, 1, t1034;
=>, t1034, t1035, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L364;
L366:
<=, t1037, t1038, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t1036);
jmp, , , L286; // salida del if
L288:

L286:
jmp, , ,L283; //regresando a la etiqueral del ciclo repetir mientras
L285:


L282:
end, , Funciones_vacio_ciclo_vida




begin, , , Funciones_entero_fibonacci_recursivo_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1039; // pos de n
=>, t1039, t1040, stack; // valor de lo que trae en el stack n
je, t1040, 0, L369;
jmp, , , L370;
L369:

// RESOLVIENDO UN RETORNO
+, P, 2, t1041; // pos de retorno de a funcion Funciones_entero_fibonacci_recursivo_entero
<=, t1041, 0, stack; //asignando el retorno con su valor
jmp, , , L367;
jmp, , , L368; // salida del if
L370:

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1042; // pos de n
=>, t1042, t1043, stack; // valor de lo que trae en el stack n
je, t1043, 1, L372;
jmp, , , L373;
L372:

// RESOLVIENDO UN RETORNO
+, P, 2, t1044; // pos de retorno de a funcion Funciones_entero_fibonacci_recursivo_entero
<=, t1044, 1, stack; //asignando el retorno con su valor
jmp, , , L367;
jmp, , , L371; // salida del if
L373:

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1045; // pos de n
=>, t1045, t1046, stack; // valor de lo que trae en el stack n
jg, t1046, 1, L375;
jmp, , , L376;
L375:

// RESOLVIENDO UN RETORNO
+, P, 0, t1047;
=>, t1047, t1048, stack; 
+, P, 3, t1049;
+, t1048, 0, t1050;
<=, t1049, t1048, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t1051; // size de funcion actual
+, t1051, 1, t1052; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1053; // pos de n
=>, t1053, t1054, stack; // valor de lo que trae en el stack n
-, t1054, 1, t1055;
<=, t1052, t1055, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Funciones_entero_fibonacci_recursivo_entero;
+, P, 2, t1056;
=>, t1056, t1057, stack; // valor del return
-, P, 3, P;
+, P, 0, t1058;
=>, t1058, t1059, stack; 
+, P, 3, t1060;
+, t1059, 0, t1061;
<=, t1060, t1059, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t1062; // size de funcion actual
+, t1062, 1, t1063; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1064; // pos de n
=>, t1064, t1065, stack; // valor de lo que trae en el stack n
-, t1065, 2, t1066;
<=, t1063, t1066, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Funciones_entero_fibonacci_recursivo_entero;
+, P, 2, t1067;
=>, t1067, t1068, stack; // valor del return
-, P, 3, P;
+, t1057, t1068, t1069;
+, P, 2, t1070; // pos de retorno de a funcion Funciones_entero_fibonacci_recursivo_entero
<=, t1070, t1069, stack; //asignando el retorno con su valor
jmp, , , L367;
jmp, , , L374; // salida del if
L376:

L374:
L371:
L368:
// RESOLVIENDO UN RETORNO
*, 1, -1, t1071;
+, P, 2, t1072; // pos de retorno de a funcion Funciones_entero_fibonacci_recursivo_entero
<=, t1072, t1071, stack; //asignando el retorno con su valor
jmp, , , L367;

L367:
end, , Funciones_entero_fibonacci_recursivo_entero




begin, , , Funciones_vacio_pedir_num

// Resolviendo una cadena 
+, H, 0, t1073; //apuntaodr a cadena 
+, H, 1, t1074; //apu donde inicia la cadena
<=, t1073, t1074, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 9, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1075; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t1073);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t1076; // pos de num
<=, t1076, 0, stack; // asignando a num
// ---------- Resolver Hacer Mientras ----------- 
L378:
L380: //etiqueta del conituar
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1077; // pos de num
=>, t1077, t1078, stack; // valor de lo que trae en el stack num
je, t1078, 7, L381;
jmp, , , L382;
L382:

jmp, , , L378;
L381:

L379:

L377:
end, , Funciones_vacio_pedir_num




begin, , , Humano_vacio_nacer

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1079; // pos this 
=>, t1079, t1080, stack; // obtenido apuntador al heap 
=>, t1080, t1081, heap; // apuntador 
+, t1081, 0, t1082; // pos de edad
=>, t1082, t1083, heap; // obtengo el valor que se encuentre en el heap 
<=, t1082, 0, HEAP; // asignando variable 
// Resolviendo una cadena 
+, H, 0, t1084; //apuntaodr a cadena 
+, H, 1, t1085; //apu donde inicia la cadena
<=, t1084, t1085, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 14, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1086; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 121, heap; //guardadndo y
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t1084);

L383:
end, , Humano_vacio_nacer




begin, , , Persona_vacio_Persona

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t1087; //pos this del arreglo
=>, t1087, t1088, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1088, t1089, heap;//apuntando donde en verdad inicia el arreglo
+, t1089, 0, t1090; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t1090, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1091; //calculando el n real
-, t1091, 0, t1092; //iReal columna 0
+, t1092, 1, t1092; //size del arreglo nombre
<=, H, t1092, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t1092, 0, t1093; // anhadiendo una posicion mas
+, h, t1093, h; // reservnado el espacio del arreglo nombre
// ----------------------- Creando arreglo atributo DPI
+, P, 0, t1094; //pos this del arreglo
=>, t1094, t1095, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1095, t1096, heap;//apuntando donde en verdad inicia el arreglo
+, t1096, 3, t1097; //pos del heap que guarda apuntador del heap para el arreglo DPI
<=, t1097, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1098; //calculando el n real
-, t1098, 0, t1099; //iReal columna 0
+, t1099, 1, t1099; //size del arreglo DPI
<=, H, t1099, heap; // insertando el tamanio del arreglo linealizado DPI
+, H, 1, H;
+, t1099, 0, t1100; // anhadiendo una posicion mas
+, h, t1100, h; // reservnado el espacio del arreglo DPI
// ----------------------- Creando arreglo atributo apellido
+, P, 0, t1101; //pos this del arreglo
=>, t1101, t1102, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1102, t1103, heap;//apuntando donde en verdad inicia el arreglo
+, t1103, 4, t1104; //pos del heap que guarda apuntador del heap para el arreglo apellido
<=, t1104, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1105; //calculando el n real
-, t1105, 0, t1106; //iReal columna 0
+, t1106, 1, t1106; //size del arreglo apellido
<=, H, t1106, heap; // insertando el tamanio del arreglo linealizado apellido
+, H, 1, H;
+, t1106, 0, t1107; // anhadiendo una posicion mas
+, h, t1107, h; // reservnado el espacio del arreglo apellido
+, P, 0, t1108;
=>, t1108, t1109, stack; 
+, P, 2, t1110;
+, t1109, 0, t1111;
<=, t1110, t1109, stack; 
// No posee parametros 
+, P, 2, P;
call, , , Persona_vacio_nacer;
+, P, 1, t1112;
=>, t1112, t1113, stack; // valor del return
-, P, 2, P;
// Resolviendo una cadena 
+, H, 0, t1114; //apuntaodr a cadena 
+, H, 1, t1115; //apu donde inicia la cadena
<=, t1114, t1115, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1116; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 0, t1119; // pos this del objeto 
=>, t1119, t1120, stack; // apuntador al heap del objeto 
=>, t1120, t1121, heap; // apunt al heap donde inica el objeto
+, t1121, 0, t1122; //apuntador a posicion donde incia el arreglo
=>, t1122, t1123, heap; // inicia el arreglo
=>, t1123, t1117, heap; // size del arreglo nombre
+, t1123, 1, t1118; //Pos 0 del arreglo
=>, t1114, t1124, heap; // pos que apunta al size de la cadena
=>, t1124, t1125, heap; // size de la cadena
+, t1124, 1, t1126; // Pos 0 de la cadena
=>, t1126, t1127, heap; // sacandor el caracter del heap cadena
jle, t1125, t1117, L385;
jmp, , , L386;
jmp, , , L385;
L385:
jne, t1127, 36, L387;
jmp, , , L388;
jmp, , , L387;
L387:
<=, t1118, t1127, heap; // guardando el caracter 
+, t1118, 1, t1118; // incremnetnado la pos del arreglo
+, t1126, 1, t1126; // incrementando la pos de la cadena
=>, t1126, t1127, heap; // sacandor el caracter del heap cadena
jmp, , , L385;
jmp, , , L388;
L388:
<= , t1118, 36, heap; // extraaaaaaaaaaa
jmp, , , L386;
L386:
// Asignando atributo genero
+, p, 0, t1128; //pos this 
=>, t1128, t1129, stack; // apuntador al heap
=>, t1129, t1130, heap; // apuntador donde inicia el objeto
+, t1130, 2, t1131; // pos real  de genero
<=, t1131, 77, heap; //guardando en el heap el valor del atributo

L384:
end, , Persona_vacio_Persona




begin, , , Persona_vacio_Persona_entero_caracter_caracter_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t1132; //pos this del arreglo
=>, t1132, t1133, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1133, t1134, heap;//apuntando donde en verdad inicia el arreglo
+, t1134, 0, t1135; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t1135, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1136; //calculando el n real
-, t1136, 0, t1137; //iReal columna 0
+, t1137, 1, t1137; //size del arreglo nombre
<=, H, t1137, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t1137, 0, t1138; // anhadiendo una posicion mas
+, h, t1138, h; // reservnado el espacio del arreglo nombre
// ----------------------- Creando arreglo atributo DPI
+, P, 0, t1139; //pos this del arreglo
=>, t1139, t1140, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1140, t1141, heap;//apuntando donde en verdad inicia el arreglo
+, t1141, 3, t1142; //pos del heap que guarda apuntador del heap para el arreglo DPI
<=, t1142, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1143; //calculando el n real
-, t1143, 0, t1144; //iReal columna 0
+, t1144, 1, t1144; //size del arreglo DPI
<=, H, t1144, heap; // insertando el tamanio del arreglo linealizado DPI
+, H, 1, H;
+, t1144, 0, t1145; // anhadiendo una posicion mas
+, h, t1145, h; // reservnado el espacio del arreglo DPI
// ----------------------- Creando arreglo atributo apellido
+, P, 0, t1146; //pos this del arreglo
=>, t1146, t1147, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1147, t1148, heap;//apuntando donde en verdad inicia el arreglo
+, t1148, 4, t1149; //pos del heap que guarda apuntador del heap para el arreglo apellido
<=, t1149, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1150; //calculando el n real
-, t1150, 0, t1151; //iReal columna 0
+, t1151, 1, t1151; //size del arreglo apellido
<=, H, t1151, heap; // insertando el tamanio del arreglo linealizado apellido
+, H, 1, H;
+, t1151, 0, t1152; // anhadiendo una posicion mas
+, h, t1152, h; // reservnado el espacio del arreglo apellido
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1153; // pos this 
=>, t1153, t1154, stack; // obtenido apuntador al heap 
=>, t1154, t1155, heap; // apuntador 
+, t1155, 1, t1156; // pos de edad
=>, t1156, t1157, heap; // obtengo el valor que se encuentre en el heap 
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1158; // pos de edad
=>, t1158, t1159, stack; // valor de lo que trae en el stack edad
<=, t1156, t1159, HEAP; // asignando variable 
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1160; // pos this 
=>, t1160, t1161, stack; // obtenido apuntador al heap 
=>, t1161, t1162, heap; // apuntador 
+, t1162, 0, t1163; // pos de nombre
=>, t1163, t1164, heap; // obtengo el valor que se encuentre en el heap 
+, P, 2, t1165;
=>, t1165, t1166, stack; 
=>, t1166, t1167, heap; 
=>, t1167, t1168, heap; // valor de size del arreglo nombre2
+, t1167, 1, t1169; // apuntador donde inicia el arreglo nombre2
=>, t1169, t1170, heap; // primer caracter del arreglo nombre2
+, H, 0, t1171;
+, H, 1, t1172;
<=, t1171, t1172, heap; 
+, H, 1, H;
+, 0, 0, t1173;
<=, H, t1173, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L390:
jne, t1170, 36, L391;
jmp, , , L392;
L391:
<=, H, t1170, heap; // ingresando el caracter 
+, H, 1, H;
+, t1173, 1, t1173; // incrementando en uno el size de la nueva cadena
+, t1169, 1, t1169;
=>, t1169, t1170, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L390;
L392:
<=, t1172, t1173, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t1163, 1, t1174;
// -------------------- Arreglo global asignar :) 
=>, t1163, t1175, heap; // inicia el arreglo
=>, t1175, t1176, heap; // size del arreglo 
+, t1175, 1, t1177; //Pos 0 del arreglo
=>, t1171, t1178, heap; // pos que apunta al size de la cadena
=>, t1178, t1179, heap; // size de la cadena
+, t1178, 1, t1180; // Pos 0 de la cadena
=>, t1180, t1181, heap; // sacandor el caracter del heap cadena
jle, t1179, t1176, L393;
jmp, , , L394;
jmp, , , L393;
L393:
jne, t1181, 36, L395;
jmp, , , L396;
jmp, , , L395;
L395:
<=, t1177, t1181, heap; // guardando el caracter 
+, t1177, 1, t1177; // incremnetnado la pos del arreglo
+, t1180, 1, t1180; // incrementando la pos de la cadena
=>, t1180, t1181, heap; // sacandor el caracter del heap cadena
jmp, , , L393;
jmp, , , L396;
L396:
<= , t1177, 36, heap; // extraaaaaaaaaaa
jmp, , , L394;
L394:
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1182; // pos this 
=>, t1182, t1183, stack; // obtenido apuntador al heap 
=>, t1183, t1184, heap; // apuntador 
+, t1184, 4, t1185; // pos de apellido
=>, t1185, t1186, heap; // obtengo el valor que se encuentre en el heap 
+, P, 3, t1187;
=>, t1187, t1188, stack; 
=>, t1188, t1189, heap; 
=>, t1189, t1190, heap; // valor de size del arreglo apellido2
+, t1189, 1, t1191; // apuntador donde inicia el arreglo apellido2
=>, t1191, t1192, heap; // primer caracter del arreglo apellido2
+, H, 0, t1193;
+, H, 1, t1194;
<=, t1193, t1194, heap; 
+, H, 1, H;
+, 0, 0, t1195;
<=, H, t1195, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L397:
jne, t1192, 36, L398;
jmp, , , L399;
L398:
<=, H, t1192, heap; // ingresando el caracter 
+, H, 1, H;
+, t1195, 1, t1195; // incrementando en uno el size de la nueva cadena
+, t1191, 1, t1191;
=>, t1191, t1192, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L397;
L399:
<=, t1194, t1195, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t1185, 1, t1196;
// -------------------- Arreglo global asignar :) 
=>, t1185, t1197, heap; // inicia el arreglo
=>, t1197, t1198, heap; // size del arreglo 
+, t1197, 1, t1199; //Pos 0 del arreglo
=>, t1193, t1200, heap; // pos que apunta al size de la cadena
=>, t1200, t1201, heap; // size de la cadena
+, t1200, 1, t1202; // Pos 0 de la cadena
=>, t1202, t1203, heap; // sacandor el caracter del heap cadena
jle, t1201, t1198, L400;
jmp, , , L401;
jmp, , , L400;
L400:
jne, t1203, 36, L402;
jmp, , , L403;
jmp, , , L402;
L402:
<=, t1199, t1203, heap; // guardando el caracter 
+, t1199, 1, t1199; // incremnetnado la pos del arreglo
+, t1202, 1, t1202; // incrementando la pos de la cadena
=>, t1202, t1203, heap; // sacandor el caracter del heap cadena
jmp, , , L400;
jmp, , , L403;
L403:
<= , t1199, 36, heap; // extraaaaaaaaaaa
jmp, , , L401;
L401:
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1204; // pos this 
=>, t1204, t1205, stack; // obtenido apuntador al heap 
=>, t1205, t1206, heap; // apuntador 
+, t1206, 2, t1207; // pos de genero
=>, t1207, t1208, heap; // obtengo el valor que se encuentre en el heap 
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t1209; // pos de genero
=>, t1209, t1210, stack; // valor de lo que trae en el stack genero
<=, t1207, t1210, HEAP; // asignando variable 

L389:
end, , Persona_vacio_Persona_entero_caracter_caracter_caracter




begin, , , Persona_caracter_concat_caracter_caracter

// ------------------------ Creando arreglo local ret
+, P, 3, t1211; //pos de arreglo ret
<=, t1211, H, stack; // ingrensando al stack apunt del heap para ret
+, H, 1, t1212;
<=, H, t1212, heap; //insetnado donde inicia el arreglo ret
+, H, 1, H;
// calculando el tamanho del arreglo
-, 60, 1, t1213; //calculando el n real
-, t1213, 0, t1214; //iReal columna 0
+, t1214, 1, t1214; //size del arreglo ret
<=, H, t1214, heap; // insertando el tamanio del arreglo linealizado ret
+, H, 1, H;
+, h, t1214, h; // reservnado el espacio del arreglo ret
+, P, 3, t1217; // pos del arreglo 
=>, t1217, t1218, stack; //apuntador al heap del arreglo
=>, t1218, t1219, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1219, t1215, heap; // size del arreglo ret
+, t1219, 1, t1216; // pos 0 donde inicia el arreglo ret
+, P, 0, t1220;
=>, t1220, t1221, stack; 
=>, t1221, t1222, heap; 
+, t1222, 0, t1223;
=>, t1223, t1224, heap; 
=>, t1224, t1225, heap; 
+, t1224, 1, t1226; 
=>, t1226, t1227, heap; // primer caracter del arreglo nombre
+, H, 0, t1228;
+, H, 1, t1229;
<=, t1228, t1229, heap; 
+, H, 1, H;
+, 0, 0, t1230;
<=, H, t1230, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L405:
jne, t1227, 36, L406;
jmp, , , L407;
L406:
<=, H, t1227, heap; // ingresando el caracter 
+, H, 1, H;
+, t1230, 1, t1230; // incrementando en uno el size de la nueva cadena
+, t1226, 1, t1226;
=>, t1226, t1227, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L405;
L407:
<=, t1229, t1230, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
=>, t1228, t1231, heap; // pos que apunta al size de la cadena
=>, t1231, t1232, heap; // size de la cadena
+, t1231, 1, t1233; // Pos 0 de la cadena
=>, t1233, t1234, heap; // sacandor el caracter del heap cadena
jle, t1232, t1215, L408;
jmp, , , L409;
jmp, , , L408;
L408:
jne, t1234, 36, L410;
jmp, , , L411;
jmp, , , L410;
L410:
<=, t1216, t1234, heap; // guardando el caracter 
+, t1216, 1, t1216; // incremnetnado la pos del arreglo
+, t1233, 1, t1233; // incrementando la pos de la cadena
=>, t1233, t1234, heap; // sacandor el caracter del heap cadena
jmp, , , L408;
jmp, , , L411;
L411:
jmp, , , L409;
L409:
+, P, 3, t1235;
=>, t1235, t1236, stack; 
=>, t1236, t1237, heap; 
=>, t1237, t1238, heap; // valor de size del arreglo ret
+, t1237, 1, t1239; // apuntador donde inicia el arreglo ret
=>, t1239, t1240, heap; // primer caracter del arreglo ret
+, H, 0, t1241;
+, H, 1, t1242;
<=, t1241, t1242, heap; 
+, H, 1, H;
+, 0, 0, t1243;
<=, H, t1243, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L412:
jne, t1240, 36, L413;
jmp, , , L414;
L413:
<=, H, t1240, heap; // ingresando el caracter 
+, H, 1, H;
+, t1243, 1, t1243; // incrementando en uno el size de la nueva cadena
+, t1239, 1, t1239;
=>, t1239, t1240, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L412;
L414:
<=, t1242, t1243, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t1244; //apuntaodr a cadena 
+, H, 1, t1245; //apu donde inicia la cadena
<=, t1244, t1245, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1246; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
//Iniciando a concatnar cadenas 
=>, t1241, t1247, heap;
=>, t1247, t1248, heap; // size cadena1
+, t1247, 1, t1249; // pos 0 de la cadena 1
=>, t1244, t1250, heap;
=>, t1250, t1251, heap; // size cadena2
+, t1250, 1, t1252; // pos 0 de la cadena 2
+, t1248, t1251, t1253; // size de la nueva cadena
=>, t1249, t1254, heap; // primer caracter de la cadena 1
=>, t1252, t1255, heap; // primer caracter de la cadena 2
+, H, 0, t1256; // posicion de retorno de la cadena
+, H, 1, t1257;
<=, t1256, t1257, heap;
+, H, 1, H;
<=, H, t1253, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L415;
L415:
jne, t1254, 36, L416;
jmp, , , L417;
jmp, , , L416;
L416:
<=, H, t1254, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1249, 1, t1249;
=>, t1249, t1254, heap;
jmp, , , L415;
jmp, , , L417;
L417:
jmp, , , L418;
L418:
jne, t1255, 36, L419;
jmp, , , L420;
jmp, , , L419;
L419:
<=, H, t1255, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1252, 1, t1252;
=>, t1252, t1255, heap;
jmp, , , L418;
jmp, , , L420;
L420:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 3, t1260; // pos del arreglo 
=>, t1260, t1261, stack; //apuntador al heap del arreglo
=>, t1261, t1262, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1262, t1258, heap; // size del arreglo ret
+, t1262, 1, t1259; // pos 0 donde inicia el arreglo ret
=>, t1256, t1263, heap; // pos que apunta al size de la cadena
=>, t1263, t1264, heap; // size de la cadena
+, t1263, 1, t1265; // Pos 0 de la cadena
=>, t1265, t1266, heap; // sacandor el caracter del heap cadena
jle, t1264, t1258, L421;
jmp, , , L422;
jmp, , , L421;
L421:
jne, t1266, 36, L423;
jmp, , , L424;
jmp, , , L423;
L423:
<=, t1259, t1266, heap; // guardando el caracter 
+, t1259, 1, t1259; // incremnetnado la pos del arreglo
+, t1265, 1, t1265; // incrementando la pos de la cadena
=>, t1265, t1266, heap; // sacandor el caracter del heap cadena
jmp, , , L421;
jmp, , , L424;
L424:
<= , t1259, 36, heap; // extraaaaaaaaaaa
jmp, , , L422;
L422:
+, P, 3, t1267;
=>, t1267, t1268, stack; 
=>, t1268, t1269, heap; 
=>, t1269, t1270, heap; // valor de size del arreglo ret
+, t1269, 1, t1271; // apuntador donde inicia el arreglo ret
=>, t1271, t1272, heap; // primer caracter del arreglo ret
+, H, 0, t1273;
+, H, 1, t1274;
<=, t1273, t1274, heap; 
+, H, 1, H;
+, 0, 0, t1275;
<=, H, t1275, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L425:
jne, t1272, 36, L426;
jmp, , , L427;
L426:
<=, H, t1272, heap; // ingresando el caracter 
+, H, 1, H;
+, t1275, 1, t1275; // incrementando en uno el size de la nueva cadena
+, t1271, 1, t1271;
=>, t1271, t1272, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L425;
L427:
<=, t1274, t1275, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
+, P, 2, t1276;
=>, t1276, t1277, stack; 
=>, t1277, t1278, heap; 
=>, t1278, t1279, heap; // valor de size del arreglo apellidos
+, t1278, 1, t1280; // apuntador donde inicia el arreglo apellidos
=>, t1280, t1281, heap; // primer caracter del arreglo apellidos
+, H, 0, t1282;
+, H, 1, t1283;
<=, t1282, t1283, heap; 
+, H, 1, H;
+, 0, 0, t1284;
<=, H, t1284, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L428:
jne, t1281, 36, L429;
jmp, , , L430;
L429:
<=, H, t1281, heap; // ingresando el caracter 
+, H, 1, H;
+, t1284, 1, t1284; // incrementando en uno el size de la nueva cadena
+, t1280, 1, t1280;
=>, t1280, t1281, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L428;
L430:
<=, t1283, t1284, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
//Iniciando a concatnar cadenas 
=>, t1273, t1285, heap;
=>, t1285, t1286, heap; // size cadena1
+, t1285, 1, t1287; // pos 0 de la cadena 1
=>, t1282, t1288, heap;
=>, t1288, t1289, heap; // size cadena2
+, t1288, 1, t1290; // pos 0 de la cadena 2
+, t1286, t1289, t1291; // size de la nueva cadena
=>, t1287, t1292, heap; // primer caracter de la cadena 1
=>, t1290, t1293, heap; // primer caracter de la cadena 2
+, H, 0, t1294; // posicion de retorno de la cadena
+, H, 1, t1295;
<=, t1294, t1295, heap;
+, H, 1, H;
<=, H, t1291, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L431;
L431:
jne, t1292, 36, L432;
jmp, , , L433;
jmp, , , L432;
L432:
<=, H, t1292, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1287, 1, t1287;
=>, t1287, t1292, heap;
jmp, , , L431;
jmp, , , L433;
L433:
jmp, , , L434;
L434:
jne, t1293, 36, L435;
jmp, , , L436;
jmp, , , L435;
L435:
<=, H, t1293, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1290, 1, t1290;
=>, t1290, t1293, heap;
jmp, , , L434;
jmp, , , L436;
L436:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 3, t1298; // pos del arreglo 
=>, t1298, t1299, stack; //apuntador al heap del arreglo
=>, t1299, t1300, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1300, t1296, heap; // size del arreglo ret
+, t1300, 1, t1297; // pos 0 donde inicia el arreglo ret
=>, t1294, t1301, heap; // pos que apunta al size de la cadena
=>, t1301, t1302, heap; // size de la cadena
+, t1301, 1, t1303; // Pos 0 de la cadena
=>, t1303, t1304, heap; // sacandor el caracter del heap cadena
jle, t1302, t1296, L437;
jmp, , , L438;
jmp, , , L437;
L437:
jne, t1304, 36, L439;
jmp, , , L440;
jmp, , , L439;
L439:
<=, t1297, t1304, heap; // guardando el caracter 
+, t1297, 1, t1297; // incremnetnado la pos del arreglo
+, t1303, 1, t1303; // incrementando la pos de la cadena
=>, t1303, t1304, heap; // sacandor el caracter del heap cadena
jmp, , , L437;
jmp, , , L440;
L440:
<= , t1297, 36, heap; // extraaaaaaaaaaa
jmp, , , L438;
L438:
// RESOLVIENDO UN RETORNO
+, P, 3, t1305;
=>, t1305, t1306, stack; 
=>, t1306, t1307, heap; 
=>, t1307, t1308, heap; // valor de size del arreglo ret
+, t1307, 1, t1309; // apuntador donde inicia el arreglo ret
=>, t1309, t1310, heap; // primer caracter del arreglo ret
+, H, 0, t1311;
+, H, 1, t1312;
<=, t1311, t1312, heap; 
+, H, 1, H;
+, 0, 0, t1313;
<=, H, t1313, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L441:
jne, t1310, 36, L442;
jmp, , , L443;
L442:
<=, H, t1310, heap; // ingresando el caracter 
+, H, 1, H;
+, t1313, 1, t1313; // incrementando en uno el size de la nueva cadena
+, t1309, 1, t1309;
=>, t1309, t1310, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L441;
L443:
<=, t1312, t1313, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;

L404:
end, , Persona_caracter_concat_caracter_caracter




begin, , , Persona_Persona_reproducir_Persona_caracter

+, P, 2, t1314;
=>, t1314, t1315, stack; 
=>, t1315, t1316, heap; 
=>, t1316, t1317, heap; // valor de size del arreglo nombre
+, t1316, 1, t1318; // apuntador donde inicia el arreglo nombre
=>, t1318, t1319, heap; // primer caracter del arreglo nombre
+, H, 0, t1320;
+, H, 1, t1321;
<=, t1320, t1321, heap; 
+, H, 1, H;
+, 0, 0, t1322;
<=, H, t1322, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L445:
jne, t1319, 36, L446;
jmp, , , L447;
L446:
<=, H, t1319, heap; // ingresando el caracter 
+, H, 1, H;
+, t1322, 1, t1322; // incrementando en uno el size de la nueva cadena
+, t1318, 1, t1318;
=>, t1318, t1319, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L445;
L447:
<=, t1321, t1322, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t1320);
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1323; // pos this 
=>, t1323, t1324, stack; // obtenido apuntador al heap 
=>, t1324, t1325, heap; // apuntador 
+, t1325, 2, t1326; // pos de genero
=>, t1326, t1327, heap; // obtengo el valor que se encuentre en el heap 
// ----------------- Resolviendo acceso local 
+, P, 1, t1328; // pos del objeto
=>, t1328, t1330, stack; //apuntador al heap del obejto
=>, t1330, t1331, heap; // recuperando pos incial del objeto
+, t1331, 2, t1330;
=>, t1330, t1332, heap; // valor a retoranar del acceso
jne, t1327, t1332, L449;
jmp, , , L450;
L449:

// ----------- Instancia a una variable local --------------
+, p, 3, t1333; // pos de bebe
<=, t1333, h, stack; //guardando referencia del heap para el objeto bebe
+, h, 1, t1334; // guardo la posicion donde inicia el objeto 
<=, h, t1334, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 5, h; // reservando espacio para el objeto bebe
//Ingresando referencia al this del objeto bebe
+, p, 3, t1335; // pos de bebe
=>, t1335, t1336, stack; // obteniendo apuntador de bebe
+, p, 6, t1337; // simulando cambio de ambito
+, t1337, 0, t1338; //pos del this de bebe
<=, t1338, t1336, stack; // insertando apuntador del heap al stack del obeto bebe
// No posee parametros 
+, p, 6, p; // simulando cambio de ambito
call, , , Persona_vacio_Persona;
-, p, 6, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 3, t1339; // pos del objeto
=>, t1339, t1341, stack; //apuntador al heap del obejto
=>, t1341, t1342, heap; // recuperando pos incial del objeto
+, t1342, 0, t1341;
=>, t1341, t1343, heap; // valor a retoranar del acceso
+, P, 2, t1344;
=>, t1344, t1345, stack; 
=>, t1345, t1346, heap; 
=>, t1346, t1347, heap; // valor de size del arreglo nombre
+, t1346, 1, t1348; // apuntador donde inicia el arreglo nombre
=>, t1348, t1349, heap; // primer caracter del arreglo nombre
+, H, 0, t1350;
+, H, 1, t1351;
<=, t1350, t1351, heap; 
+, H, 1, H;
+, 0, 0, t1352;
<=, H, t1352, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L451:
jne, t1349, 36, L452;
jmp, , , L453;
L452:
<=, H, t1349, heap; // ingresando el caracter 
+, H, 1, H;
+, t1352, 1, t1352; // incrementando en uno el size de la nueva cadena
+, t1348, 1, t1348;
=>, t1348, t1349, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L451;
L453:
<=, t1351, t1352, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t1341, 1, t1353;
// -------------------- Arreglo global asignar :) 
=>, t1341, t1354, heap; // inicia el arreglo
=>, t1354, t1355, heap; // size del arreglo 
+, t1354, 1, t1356; //Pos 0 del arreglo
=>, t1350, t1357, heap; // pos que apunta al size de la cadena
=>, t1357, t1358, heap; // size de la cadena
+, t1357, 1, t1359; // Pos 0 de la cadena
=>, t1359, t1360, heap; // sacandor el caracter del heap cadena
jle, t1358, t1355, L454;
jmp, , , L455;
jmp, , , L454;
L454:
jne, t1360, 36, L456;
jmp, , , L457;
jmp, , , L456;
L456:
<=, t1356, t1360, heap; // guardando el caracter 
+, t1356, 1, t1356; // incremnetnado la pos del arreglo
+, t1359, 1, t1359; // incrementando la pos de la cadena
=>, t1359, t1360, heap; // sacandor el caracter del heap cadena
jmp, , , L454;
jmp, , , L457;
L457:
<= , t1356, 36, heap; // extraaaaaaaaaaa
jmp, , , L455;
L455:
// ----------------- Resolviendo acceso local 
+, P, 3, t1361; // pos del objeto
=>, t1361, t1363, stack; //apuntador al heap del obejto
=>, t1363, t1364, heap; // recuperando pos incial del objeto
+, t1364, 4, t1363;
=>, t1363, t1365, heap; // valor a retoranar del acceso
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1366; // pos this 
=>, t1366, t1367, stack; // obtenido apuntador al heap 
=>, t1367, t1368, heap; // apuntador 
+, t1368, 4, t1369; // pos de apellido
=>, t1369, t1370, heap; // obtengo el valor que se encuentre en el heap 
<=, t1363, t1370, heap; // asignando variable 
// ------------------------ Creando arreglo local ape
+, P, 4, t1371; //pos de arreglo ape
<=, t1371, H, stack; // ingrensando al stack apunt del heap para ape
+, H, 1, t1372;
<=, H, t1372, heap; //insetnado donde inicia el arreglo ape
+, H, 1, H;
// calculando el tamanho del arreglo
-, 60, 1, t1373; //calculando el n real
-, t1373, 0, t1374; //iReal columna 0
+, t1374, 1, t1374; //size del arreglo ape
<=, H, t1374, heap; // insertando el tamanio del arreglo linealizado ape
+, H, 1, H;
+, h, t1374, h; // reservnado el espacio del arreglo ape
+, P, 4, t1377; // pos del arreglo 
=>, t1377, t1378, stack; //apuntador al heap del arreglo
=>, t1378, t1379, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1379, t1375, heap; // size del arreglo ape
+, t1379, 1, t1376; // pos 0 donde inicia el arreglo ape
// ----------------- Resolviendo acceso local 
+, P, 3, t1380; // pos del objeto
=>, t1380, t1382, stack; //apuntador al heap del obejto
=>, t1382, t1383, heap; // recuperando pos incial del objeto
+, t1383, 4, t1382;
=>, t1382, t1384, heap; // valor a retoranar del acceso
+, P, 4, t1385;
=>, t1385, t1386, stack; 
=>, t1386, t1387, heap; 
=>, t1387, t1388, heap; // valor de size del arreglo ape
+, t1387, 1, t1389; // apuntador donde inicia el arreglo ape
=>, t1389, t1390, heap; // primer caracter del arreglo ape
+, H, 0, t1391;
+, H, 1, t1392;
<=, t1391, t1392, heap; 
+, H, 1, H;
+, 0, 0, t1393;
<=, H, t1393, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L458:
jne, t1390, 36, L459;
jmp, , , L460;
L459:
<=, H, t1390, heap; // ingresando el caracter 
+, H, 1, H;
+, t1393, 1, t1393; // incrementando en uno el size de la nueva cadena
+, t1389, 1, t1389;
=>, t1389, t1390, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L458;
L460:
<=, t1392, t1393, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t1394; //apuntaodr a cadena 
+, H, 1, t1395; //apu donde inicia la cadena
<=, t1394, t1395, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1396; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
//Iniciando a concatnar cadenas 
=>, t1391, t1397, heap;
=>, t1397, t1398, heap; // size cadena1
+, t1397, 1, t1399; // pos 0 de la cadena 1
=>, t1394, t1400, heap;
=>, t1400, t1401, heap; // size cadena2
+, t1400, 1, t1402; // pos 0 de la cadena 2
+, t1398, t1401, t1403; // size de la nueva cadena
=>, t1399, t1404, heap; // primer caracter de la cadena 1
=>, t1402, t1405, heap; // primer caracter de la cadena 2
+, H, 0, t1406; // posicion de retorno de la cadena
+, H, 1, t1407;
<=, t1406, t1407, heap;
+, H, 1, H;
<=, H, t1403, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L461;
L461:
jne, t1404, 36, L462;
jmp, , , L463;
jmp, , , L462;
L462:
<=, H, t1404, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1399, 1, t1399;
=>, t1399, t1404, heap;
jmp, , , L461;
jmp, , , L463;
L463:
jmp, , , L464;
L464:
jne, t1405, 36, L465;
jmp, , , L466;
jmp, , , L465;
L465:
<=, H, t1405, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1402, 1, t1402;
=>, t1402, t1405, heap;
jmp, , , L464;
jmp, , , L466;
L466:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 4, t1410; // pos del arreglo 
=>, t1410, t1411, stack; //apuntador al heap del arreglo
=>, t1411, t1412, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1412, t1408, heap; // size del arreglo ape
+, t1412, 1, t1409; // pos 0 donde inicia el arreglo ape
=>, t1406, t1413, heap; // pos que apunta al size de la cadena
=>, t1413, t1414, heap; // size de la cadena
+, t1413, 1, t1415; // Pos 0 de la cadena
=>, t1415, t1416, heap; // sacandor el caracter del heap cadena
jle, t1414, t1408, L467;
jmp, , , L468;
jmp, , , L467;
L467:
jne, t1416, 36, L469;
jmp, , , L470;
jmp, , , L469;
L469:
<=, t1409, t1416, heap; // guardando el caracter 
+, t1409, 1, t1409; // incremnetnado la pos del arreglo
+, t1415, 1, t1415; // incrementando la pos de la cadena
=>, t1415, t1416, heap; // sacandor el caracter del heap cadena
jmp, , , L467;
jmp, , , L470;
L470:
<= , t1409, 36, heap; // extraaaaaaaaaaa
jmp, , , L468;
L468:
+, P, 4, t1417;
=>, t1417, t1418, stack; 
=>, t1418, t1419, heap; 
=>, t1419, t1420, heap; // valor de size del arreglo ape
+, t1419, 1, t1421; // apuntador donde inicia el arreglo ape
=>, t1421, t1422, heap; // primer caracter del arreglo ape
+, H, 0, t1423;
+, H, 1, t1424;
<=, t1423, t1424, heap; 
+, H, 1, H;
+, 0, 0, t1425;
<=, H, t1425, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L471:
jne, t1422, 36, L472;
jmp, , , L473;
L472:
<=, H, t1422, heap; // ingresando el caracter 
+, H, 1, H;
+, t1425, 1, t1425; // incrementando en uno el size de la nueva cadena
+, t1421, 1, t1421;
=>, t1421, t1422, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L471;
L473:
<=, t1424, t1425, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 1, t1426; // pos del objeto
=>, t1426, t1428, stack; //apuntador al heap del obejto
=>, t1428, t1429, heap; // recuperando pos incial del objeto
+, t1429, 4, t1428;
=>, t1428, t1430, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t1431;
+, H, 1, t1432;
<=, t1431, t1432, heap;
+, H, 1, H;
+, H, 1, H;
=>, t1428, t1433, heap; 
+, t1433, 1, t1434;
=>, t1434, t1435, heap; // caracter actual
+, 0, 0, t1436;
L474:
jne, t1435, 36, L475;
jmp, , , L476;
L475:
+, t1436, 1, t1436;
<=, H, t1435, heap;
+, H, 1, H;
+, t1434, 1, t1434;
=>, t1434, t1435, heap; // caracter actual
jmp, , , L474;
L476:
<=, H, 36, heap;
+, H, 1, H;
<=, t1432, t1436, heap;
//Iniciando a concatnar cadenas 
=>, t1423, t1437, heap;
=>, t1437, t1438, heap; // size cadena1
+, t1437, 1, t1439; // pos 0 de la cadena 1
=>, t1431, t1440, heap;
=>, t1440, t1441, heap; // size cadena2
+, t1440, 1, t1442; // pos 0 de la cadena 2
+, t1438, t1441, t1443; // size de la nueva cadena
=>, t1439, t1444, heap; // primer caracter de la cadena 1
=>, t1442, t1445, heap; // primer caracter de la cadena 2
+, H, 0, t1446; // posicion de retorno de la cadena
+, H, 1, t1447;
<=, t1446, t1447, heap;
+, H, 1, H;
<=, H, t1443, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L477;
L477:
jne, t1444, 36, L478;
jmp, , , L479;
jmp, , , L478;
L478:
<=, H, t1444, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1439, 1, t1439;
=>, t1439, t1444, heap;
jmp, , , L477;
jmp, , , L479;
L479:
jmp, , , L480;
L480:
jne, t1445, 36, L481;
jmp, , , L482;
jmp, , , L481;
L481:
<=, H, t1445, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1442, 1, t1442;
=>, t1442, t1445, heap;
jmp, , , L480;
jmp, , , L482;
L482:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 4, t1450; // pos del arreglo 
=>, t1450, t1451, stack; //apuntador al heap del arreglo
=>, t1451, t1452, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1452, t1448, heap; // size del arreglo ape
+, t1452, 1, t1449; // pos 0 donde inicia el arreglo ape
=>, t1446, t1453, heap; // pos que apunta al size de la cadena
=>, t1453, t1454, heap; // size de la cadena
+, t1453, 1, t1455; // Pos 0 de la cadena
=>, t1455, t1456, heap; // sacandor el caracter del heap cadena
jle, t1454, t1448, L483;
jmp, , , L484;
jmp, , , L483;
L483:
jne, t1456, 36, L485;
jmp, , , L486;
jmp, , , L485;
L485:
<=, t1449, t1456, heap; // guardando el caracter 
+, t1449, 1, t1449; // incremnetnado la pos del arreglo
+, t1455, 1, t1455; // incrementando la pos de la cadena
=>, t1455, t1456, heap; // sacandor el caracter del heap cadena
jmp, , , L483;
jmp, , , L486;
L486:
<= , t1449, 36, heap; // extraaaaaaaaaaa
jmp, , , L484;
L484:
// ----------------- Resolviendo acceso local 
+, P, 3, t1457; // pos del objeto
=>, t1457, t1459, stack; //apuntador al heap del obejto
=>, t1459, t1460, heap; // recuperando pos incial del objeto
+, t1460, 4, t1459;
=>, t1459, t1461, heap; // valor a retoranar del acceso
+, P, 4, t1462;
=>, t1462, t1463, stack; 
=>, t1463, t1464, heap; 
=>, t1464, t1465, heap; // valor de size del arreglo ape
+, t1464, 1, t1466; // apuntador donde inicia el arreglo ape
=>, t1466, t1467, heap; // primer caracter del arreglo ape
+, H, 0, t1468;
+, H, 1, t1469;
<=, t1468, t1469, heap; 
+, H, 1, H;
+, 0, 0, t1470;
<=, H, t1470, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L487:
jne, t1467, 36, L488;
jmp, , , L489;
L488:
<=, H, t1467, heap; // ingresando el caracter 
+, H, 1, H;
+, t1470, 1, t1470; // incrementando en uno el size de la nueva cadena
+, t1466, 1, t1466;
=>, t1466, t1467, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L487;
L489:
<=, t1469, t1470, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t1459, 1, t1471;
// -------------------- Arreglo global asignar :) 
=>, t1459, t1472, heap; // inicia el arreglo
=>, t1472, t1473, heap; // size del arreglo 
+, t1472, 1, t1474; //Pos 0 del arreglo
=>, t1468, t1475, heap; // pos que apunta al size de la cadena
=>, t1475, t1476, heap; // size de la cadena
+, t1475, 1, t1477; // Pos 0 de la cadena
=>, t1477, t1478, heap; // sacandor el caracter del heap cadena
jle, t1476, t1473, L490;
jmp, , , L491;
jmp, , , L490;
L490:
jne, t1478, 36, L492;
jmp, , , L493;
jmp, , , L492;
L492:
<=, t1474, t1478, heap; // guardando el caracter 
+, t1474, 1, t1474; // incremnetnado la pos del arreglo
+, t1477, 1, t1477; // incrementando la pos de la cadena
=>, t1477, t1478, heap; // sacandor el caracter del heap cadena
jmp, , , L490;
jmp, , , L493;
L493:
<= , t1474, 36, heap; // extraaaaaaaaaaa
jmp, , , L491;
L491:
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t1479; // pos de bebe
=>, t1479, t1480, stack; // valor de lo que trae en el stack bebe
+, P, 5, t1481; // pos de retorno de a funcion Persona_Persona_reproducir_Persona_caracter
<=, t1481, t1480, stack; //asignando el retorno con su valor
jmp, , , L444;
jmp, , , L448; // salida del if
L450:

L448:
// RESOLVIENDO UN RETORNO

L444:
end, , Persona_Persona_reproducir_Persona_caracter




begin, , , Persona_vacio_matrimonio_Persona

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1482; // pos this 
=>, t1482, t1483, stack; // obtenido apuntador al heap 
=>, t1483, t1484, heap; // apuntador 
+, t1484, 2, t1485; // pos de genero
=>, t1485, t1486, heap; // obtengo el valor que se encuentre en el heap 
je, t1486, 70, L496;
jmp, , , L497;
L496:

// ------------------------ Creando arreglo local ape
+, P, 2, t1487; //pos de arreglo ape
<=, t1487, H, stack; // ingrensando al stack apunt del heap para ape
+, H, 1, t1488;
<=, H, t1488, heap; //insetnado donde inicia el arreglo ape
+, H, 1, H;
// calculando el tamanho del arreglo
-, 15, 1, t1489; //calculando el n real
-, t1489, 0, t1490; //iReal columna 0
+, t1490, 1, t1490; //size del arreglo ape
<=, H, t1490, heap; // insertando el tamanio del arreglo linealizado ape
+, H, 1, H;
+, h, t1490, h; // reservnado el espacio del arreglo ape
+, P, 2, t1493; // pos del arreglo 
=>, t1493, t1494, stack; //apuntador al heap del arreglo
=>, t1494, t1495, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1495, t1491, heap; // size del arreglo ape
+, t1495, 1, t1492; // pos 0 donde inicia el arreglo ape
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1496; // pos this 
=>, t1496, t1497, stack; // obtenido apuntador al heap 
=>, t1497, t1498, heap; // apuntador 
+, t1498, 4, t1499; // pos de apellido
=>, t1499, t1500, heap; // obtengo el valor que se encuentre en el heap 
+, P, 2, t1501;
=>, t1501, t1502, stack; 
=>, t1502, t1503, heap; 
=>, t1503, t1504, heap; // valor de size del arreglo ape
+, t1503, 1, t1505; // apuntador donde inicia el arreglo ape
=>, t1505, t1506, heap; // primer caracter del arreglo ape
+, H, 0, t1507;
+, H, 1, t1508;
<=, t1507, t1508, heap; 
+, H, 1, H;
+, 0, 0, t1509;
<=, H, t1509, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L498:
jne, t1506, 36, L499;
jmp, , , L500;
L499:
<=, H, t1506, heap; // ingresando el caracter 
+, H, 1, H;
+, t1509, 1, t1509; // incrementando en uno el size de la nueva cadena
+, t1505, 1, t1505;
=>, t1505, t1506, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L498;
L500:
<=, t1508, t1509, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t1510; //apuntaodr a cadena 
+, H, 1, t1511; //apu donde inicia la cadena
<=, t1510, t1511, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1512; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
//Iniciando a concatnar cadenas 
=>, t1507, t1513, heap;
=>, t1513, t1514, heap; // size cadena1
+, t1513, 1, t1515; // pos 0 de la cadena 1
=>, t1510, t1516, heap;
=>, t1516, t1517, heap; // size cadena2
+, t1516, 1, t1518; // pos 0 de la cadena 2
+, t1514, t1517, t1519; // size de la nueva cadena
=>, t1515, t1520, heap; // primer caracter de la cadena 1
=>, t1518, t1521, heap; // primer caracter de la cadena 2
+, H, 0, t1522; // posicion de retorno de la cadena
+, H, 1, t1523;
<=, t1522, t1523, heap;
+, H, 1, H;
<=, H, t1519, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L501;
L501:
jne, t1520, 36, L502;
jmp, , , L503;
jmp, , , L502;
L502:
<=, H, t1520, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1515, 1, t1515;
=>, t1515, t1520, heap;
jmp, , , L501;
jmp, , , L503;
L503:
jmp, , , L504;
L504:
jne, t1521, 36, L505;
jmp, , , L506;
jmp, , , L505;
L505:
<=, H, t1521, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1518, 1, t1518;
=>, t1518, t1521, heap;
jmp, , , L504;
jmp, , , L506;
L506:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t1526; // pos del arreglo 
=>, t1526, t1527, stack; //apuntador al heap del arreglo
=>, t1527, t1528, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1528, t1524, heap; // size del arreglo ape
+, t1528, 1, t1525; // pos 0 donde inicia el arreglo ape
=>, t1522, t1529, heap; // pos que apunta al size de la cadena
=>, t1529, t1530, heap; // size de la cadena
+, t1529, 1, t1531; // Pos 0 de la cadena
=>, t1531, t1532, heap; // sacandor el caracter del heap cadena
jle, t1530, t1524, L507;
jmp, , , L508;
jmp, , , L507;
L507:
jne, t1532, 36, L509;
jmp, , , L510;
jmp, , , L509;
L509:
<=, t1525, t1532, heap; // guardando el caracter 
+, t1525, 1, t1525; // incremnetnado la pos del arreglo
+, t1531, 1, t1531; // incrementando la pos de la cadena
=>, t1531, t1532, heap; // sacandor el caracter del heap cadena
jmp, , , L507;
jmp, , , L510;
L510:
<= , t1525, 36, heap; // extraaaaaaaaaaa
jmp, , , L508;
L508:
+, P, 2, t1533;
=>, t1533, t1534, stack; 
=>, t1534, t1535, heap; 
=>, t1535, t1536, heap; // valor de size del arreglo ape
+, t1535, 1, t1537; // apuntador donde inicia el arreglo ape
=>, t1537, t1538, heap; // primer caracter del arreglo ape
+, H, 0, t1539;
+, H, 1, t1540;
<=, t1539, t1540, heap; 
+, H, 1, H;
+, 0, 0, t1541;
<=, H, t1541, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L511:
jne, t1538, 36, L512;
jmp, , , L513;
L512:
<=, H, t1538, heap; // ingresando el caracter 
+, H, 1, H;
+, t1541, 1, t1541; // incrementando en uno el size de la nueva cadena
+, t1537, 1, t1537;
=>, t1537, t1538, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L511;
L513:
<=, t1540, t1541, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 1, t1542; // pos del objeto
=>, t1542, t1544, stack; //apuntador al heap del obejto
=>, t1544, t1545, heap; // recuperando pos incial del objeto
+, t1545, 4, t1544;
=>, t1544, t1546, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t1547;
+, H, 1, t1548;
<=, t1547, t1548, heap;
+, H, 1, H;
+, H, 1, H;
=>, t1544, t1549, heap; 
+, t1549, 1, t1550;
=>, t1550, t1551, heap; // caracter actual
+, 0, 0, t1552;
L514:
jne, t1551, 36, L515;
jmp, , , L516;
L515:
+, t1552, 1, t1552;
<=, H, t1551, heap;
+, H, 1, H;
+, t1550, 1, t1550;
=>, t1550, t1551, heap; // caracter actual
jmp, , , L514;
L516:
<=, H, 36, heap;
+, H, 1, H;
<=, t1548, t1552, heap;
//Iniciando a concatnar cadenas 
=>, t1539, t1553, heap;
=>, t1553, t1554, heap; // size cadena1
+, t1553, 1, t1555; // pos 0 de la cadena 1
=>, t1547, t1556, heap;
=>, t1556, t1557, heap; // size cadena2
+, t1556, 1, t1558; // pos 0 de la cadena 2
+, t1554, t1557, t1559; // size de la nueva cadena
=>, t1555, t1560, heap; // primer caracter de la cadena 1
=>, t1558, t1561, heap; // primer caracter de la cadena 2
+, H, 0, t1562; // posicion de retorno de la cadena
+, H, 1, t1563;
<=, t1562, t1563, heap;
+, H, 1, H;
<=, H, t1559, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L517;
L517:
jne, t1560, 36, L518;
jmp, , , L519;
jmp, , , L518;
L518:
<=, H, t1560, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1555, 1, t1555;
=>, t1555, t1560, heap;
jmp, , , L517;
jmp, , , L519;
L519:
jmp, , , L520;
L520:
jne, t1561, 36, L521;
jmp, , , L522;
jmp, , , L521;
L521:
<=, H, t1561, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1558, 1, t1558;
=>, t1558, t1561, heap;
jmp, , , L520;
jmp, , , L522;
L522:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t1566; // pos del arreglo 
=>, t1566, t1567, stack; //apuntador al heap del arreglo
=>, t1567, t1568, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1568, t1564, heap; // size del arreglo ape
+, t1568, 1, t1565; // pos 0 donde inicia el arreglo ape
=>, t1562, t1569, heap; // pos que apunta al size de la cadena
=>, t1569, t1570, heap; // size de la cadena
+, t1569, 1, t1571; // Pos 0 de la cadena
=>, t1571, t1572, heap; // sacandor el caracter del heap cadena
jle, t1570, t1564, L523;
jmp, , , L524;
jmp, , , L523;
L523:
jne, t1572, 36, L525;
jmp, , , L526;
jmp, , , L525;
L525:
<=, t1565, t1572, heap; // guardando el caracter 
+, t1565, 1, t1565; // incremnetnado la pos del arreglo
+, t1571, 1, t1571; // incrementando la pos de la cadena
=>, t1571, t1572, heap; // sacandor el caracter del heap cadena
jmp, , , L523;
jmp, , , L526;
L526:
<= , t1565, 36, heap; // extraaaaaaaaaaa
jmp, , , L524;
L524:
jmp, , , L495; // salida del if
L497:

L495:

L494:
end, , Persona_vacio_matrimonio_Persona




begin, , , Persona_vacio_nacer

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1573; // pos this 
=>, t1573, t1574, stack; // obtenido apuntador al heap 
=>, t1574, t1575, heap; // apuntador 
+, t1575, 1, t1576; // pos de edad
=>, t1576, t1577, heap; // obtengo el valor que se encuentre en el heap 
<=, t1576, 0, HEAP; // asignando variable 
// Resolviendo una cadena 
+, H, 0, t1578; //apuntaodr a cadena 
+, H, 1, t1579; //apu donde inicia la cadena
<=, t1578, t1579, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 14, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1580; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 121, heap; //guardadndo y
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t1578);

L527:
end, , Persona_vacio_nacer


