

begin, , , Node_vacio_Node_entero

// Asignando atributo key
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de key
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de d
=>, t5, t6, stack; // valor de lo que trae en el stack d
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo height
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de height
<=, t10, 1, heap; //guardando en el heap el valor del atributo

L1:
end, , Node_vacio_Node_entero




begin, , , Avl_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t11; // pos de arbol
<=, t11, h, stack; //guardando referencia del heap para el objeto arbol
+, h, 1, t12; // guardo la posicion donde inicia el objeto 
<=, h, t12, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 1, h; // reservando espacio para el objeto arbol
//Ingresando referencia al this del objeto arbol
+, p, 0, t13; // pos de arbol
=>, t13, t14, stack; // obteniendo apuntador de arbol
+, p, 1, t15; // simulando cambio de ambito
+, t15, 0, t16; //pos del this de arbol
<=, t16, t14, stack; // insertando apuntador del heap al stack del obeto arbol
// No posee parametros 
+, p, 1, p; // simulando cambio de ambito
call, , , Tree_vacio_tree;
-, p, 1, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t17; // pos del objeto
=>, t17, t19, stack; //apuntador al heap del obejto
=>, t19, t20, heap; // recuperando pos incial del objeto
+, t20, 0, t19;
=>, t19, t21, heap; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 0, t22; // pos del objeto
=>, t22, t24, stack; //apuntador al heap del obejto
+, P, 6, t25;
+, t25, 0, t26;
<=, t26, t24, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 6, t27; // size de funcion actual
+, t27, 1, t28; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 0, t29; // pos del objeto
=>, t29, t31, stack; //apuntador al heap del obejto
=>, t31, t32, heap; // recuperando pos incial del objeto
+, t32, 0, t31;
=>, t31, t33, heap; // valor a retoranar del acceso
<=, t28, t33, stack; // asignado al stack el parametro
+, p, 6, t34; // size de funcion actual
+, t34, 2, t35; //pos del parametro 2
<=, t35, 10, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t36;
=>, t36, t37, stack; // valor del return
-, P, 6, P;
=>, t36, t38, stack; // valor a retoranar del acceso
<=, t19, t38, heap; // asignando variable 
print("%d", 4);
// ----------------- Resolviendo acceso local 
+, P, 0, t39; // pos del objeto
=>, t39, t41, stack; //apuntador al heap del obejto
=>, t41, t42, heap; // recuperando pos incial del objeto
+, t42, 0, t41;
=>, t41, t43, heap; // recuperando pos incial del objeto
+, t43, 0, t41;
=>, t41, t44, heap; // valor a retoranar del acceso
print("%d", t44);
// ----------------- Resolviendo acceso local 
+, P, 0, t45; // pos del objeto
=>, t45, t47, stack; //apuntador al heap del obejto
=>, t47, t48, heap; // recuperando pos incial del objeto
+, t48, 0, t47;
=>, t47, t49, heap; // recuperando pos incial del objeto
+, t49, 1, t47;
=>, t47, t50, heap; // valor a retoranar del acceso
print("%d", t50);
print("%d", 2);

L2:
end, , Avl_PRINCIPAL




begin, , , Tree_vacio_tree


L3:
end, , Tree_vacio_tree




begin, , , Tree_entero_height_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t51; // pos de N
=>, t51, t52, stack; // valor de lo que trae en el stack N
je, t52, 36, L6;
jmp, , , L7;
L6:

// RESOLVIENDO UN RETORNO
+, P, 2, t53; // pos de retorno de a funcion Tree_entero_height_Node
<=, t53, 0, stack; //asignando el retorno con su valor
jmp, , , L4;
jmp, , , L5; // salida del if
L7:

L5:
// RESOLVIENDO UN RETORNO
// ----------------- Resolviendo acceso local 
+, P, 1, t54; // pos del objeto
=>, t54, t56, stack; //apuntador al heap del obejto
=>, t56, t57, heap; // recuperando pos incial del objeto
+, t57, 1, t56;
=>, t56, t58, heap; // valor a retoranar del acceso
+, P, 2, t59; // pos de retorno de a funcion Tree_entero_height_Node
<=, t59, t58, stack; //asignando el retorno con su valor
jmp, , , L4;

L4:
end, , Tree_entero_height_Node




begin, , , Tree_entero_max_entero_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t60; // pos de a
=>, t60, t61, stack; // valor de lo que trae en el stack a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t62; // pos de b
=>, t62, t63, stack; // valor de lo que trae en el stack b
jg, t61, t63, L10;
jmp, , , L11;
L10:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t64; // pos de a
=>, t64, t65, stack; // valor de lo que trae en el stack a
+, P, 3, t66; // pos de retorno de a funcion Tree_entero_max_entero_entero
<=, t66, t65, stack; //asignando el retorno con su valor
jmp, , , L8;
jmp, , , L9; // salida del if
L11:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t67; // pos de b
=>, t67, t68, stack; // valor de lo que trae en el stack b
+, P, 3, t69; // pos de retorno de a funcion Tree_entero_max_entero_entero
<=, t69, t68, stack; //asignando el retorno con su valor
jmp, , , L8;
L9:

L8:
end, , Tree_entero_max_entero_entero




begin, , , Tree_Node_rightRotate_Node

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t70; // pos de x
// ----------------- Resolviendo acceso local 
+, P, 1, t71; // pos del objeto
=>, t71, t73, stack; //apuntador al heap del obejto
=>, t73, t74, heap; // recuperando pos incial del objeto
+, t74, 2, t73;
=>, t73, t75, heap; // valor a retoranar del acceso
<=, t70, t75, stack; // asignando a x
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t76; // pos de T2
// ----------------- Resolviendo acceso local 
+, P, 2, t77; // pos del objeto
=>, t77, t79, stack; //apuntador al heap del obejto
=>, t79, t80, heap; // recuperando pos incial del objeto
+, t80, 3, t79;
=>, t79, t81, heap; // valor a retoranar del acceso
<=, t76, t81, stack; // asignando a T2
// ----------------- Resolviendo acceso local 
+, P, 2, t82; // pos del objeto
=>, t82, t84, stack; //apuntador al heap del obejto
=>, t84, t85, heap; // recuperando pos incial del objeto
+, t85, 3, t84;
=>, t84, t86, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t87; // pos de y
=>, t87, t88, stack; // valor de lo que trae en el stack y
<=, t84, t88, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t89; // pos del objeto
=>, t89, t91, stack; //apuntador al heap del obejto
=>, t91, t92, heap; // recuperando pos incial del objeto
+, t92, 2, t91;
=>, t91, t93, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t94; // pos de T2
=>, t94, t95, stack; // valor de lo que trae en el stack T2
<=, t91, t95, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t96; // pos del objeto
=>, t96, t98, stack; //apuntador al heap del obejto
=>, t98, t99, heap; // recuperando pos incial del objeto
+, t99, 1, t98;
=>, t98, t100, heap; // valor a retoranar del acceso
+, P, 0, t101;
=>, t101, t102, stack; 
+, P, 5, t103;
+, t102, 0, t104;
<=, t103, t102, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t105; // size de funcion actual
+, t105, 1, t106; //pos del parametro 1
+, P, 0, t107;
=>, t107, t108, stack; 
+, P, 5, t109;
+, t108, 0, t110;
<=, t109, t108, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t111; // size de funcion actual
+, t111, 1, t112; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t113; // pos del objeto
=>, t113, t115, stack; //apuntador al heap del obejto
=>, t115, t116, heap; // recuperando pos incial del objeto
+, t116, 2, t115;
=>, t115, t117, heap; // valor a retoranar del acceso
<=, t112, t117, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t118;
=>, t118, t119, stack; // valor del return
-, P, 5, P;
<=, t106, t119, stack; // asignado al stack el parametro
+, p, 5, t120; // size de funcion actual
+, t120, 2, t121; //pos del parametro 2
+, P, 0, t122;
=>, t122, t123, stack; 
+, P, 5, t124;
+, t123, 0, t125;
<=, t124, t123, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t126; // size de funcion actual
+, t126, 1, t127; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t128; // pos del objeto
=>, t128, t130, stack; //apuntador al heap del obejto
=>, t130, t131, heap; // recuperando pos incial del objeto
+, t131, 3, t130;
=>, t130, t132, heap; // valor a retoranar del acceso
<=, t127, t132, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t133;
=>, t133, t134, stack; // valor del return
-, P, 5, P;
<=, t121, t134, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t135;
=>, t135, t136, stack; // valor del return
-, P, 5, P;
+, t136, 1, t137;
<=, t98, t137, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 2, t138; // pos del objeto
=>, t138, t140, stack; //apuntador al heap del obejto
=>, t140, t141, heap; // recuperando pos incial del objeto
+, t141, 1, t140;
=>, t140, t142, heap; // valor a retoranar del acceso
+, P, 0, t143;
=>, t143, t144, stack; 
+, P, 5, t145;
+, t144, 0, t146;
<=, t145, t144, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t147; // size de funcion actual
+, t147, 1, t148; //pos del parametro 1
+, P, 0, t149;
=>, t149, t150, stack; 
+, P, 5, t151;
+, t150, 0, t152;
<=, t151, t150, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t153; // size de funcion actual
+, t153, 1, t154; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t155; // pos del objeto
=>, t155, t157, stack; //apuntador al heap del obejto
=>, t157, t158, heap; // recuperando pos incial del objeto
+, t158, 2, t157;
=>, t157, t159, heap; // valor a retoranar del acceso
<=, t154, t159, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t160;
=>, t160, t161, stack; // valor del return
-, P, 5, P;
<=, t148, t161, stack; // asignado al stack el parametro
+, p, 5, t162; // size de funcion actual
+, t162, 2, t163; //pos del parametro 2
+, P, 0, t164;
=>, t164, t165, stack; 
+, P, 5, t166;
+, t165, 0, t167;
<=, t166, t165, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t168; // size de funcion actual
+, t168, 1, t169; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t170; // pos del objeto
=>, t170, t172, stack; //apuntador al heap del obejto
=>, t172, t173, heap; // recuperando pos incial del objeto
+, t173, 3, t172;
=>, t172, t174, heap; // valor a retoranar del acceso
<=, t169, t174, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t175;
=>, t175, t176, stack; // valor del return
-, P, 5, P;
<=, t163, t176, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t177;
=>, t177, t178, stack; // valor del return
-, P, 5, P;
+, t178, 1, t179;
<=, t140, t179, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t180; // pos de x
=>, t180, t181, stack; // valor de lo que trae en el stack x
+, P, 4, t182; // pos de retorno de a funcion Tree_Node_rightRotate_Node
<=, t182, t181, stack; //asignando el retorno con su valor
jmp, , , L12;

L12:
end, , Tree_Node_rightRotate_Node




begin, , , Tree_Node_leftRotate_Node

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t183; // pos de y
// ----------------- Resolviendo acceso local 
+, P, 1, t184; // pos del objeto
=>, t184, t186, stack; //apuntador al heap del obejto
=>, t186, t187, heap; // recuperando pos incial del objeto
+, t187, 3, t186;
=>, t186, t188, heap; // valor a retoranar del acceso
<=, t183, t188, stack; // asignando a y
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t189; // pos de T2
// ----------------- Resolviendo acceso local 
+, P, 2, t190; // pos del objeto
=>, t190, t192, stack; //apuntador al heap del obejto
=>, t192, t193, heap; // recuperando pos incial del objeto
+, t193, 2, t192;
=>, t192, t194, heap; // valor a retoranar del acceso
<=, t189, t194, stack; // asignando a T2
// ----------------- Resolviendo acceso local 
+, P, 2, t195; // pos del objeto
=>, t195, t197, stack; //apuntador al heap del obejto
=>, t197, t198, heap; // recuperando pos incial del objeto
+, t198, 2, t197;
=>, t197, t199, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t200; // pos de x
=>, t200, t201, stack; // valor de lo que trae en el stack x
<=, t197, t201, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t202; // pos del objeto
=>, t202, t204, stack; //apuntador al heap del obejto
=>, t204, t205, heap; // recuperando pos incial del objeto
+, t205, 3, t204;
=>, t204, t206, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t207; // pos de T2
=>, t207, t208, stack; // valor de lo que trae en el stack T2
<=, t204, t208, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t209; // pos del objeto
=>, t209, t211, stack; //apuntador al heap del obejto
=>, t211, t212, heap; // recuperando pos incial del objeto
+, t212, 1, t211;
=>, t211, t213, heap; // valor a retoranar del acceso
+, P, 0, t214;
=>, t214, t215, stack; 
+, P, 5, t216;
+, t215, 0, t217;
<=, t216, t215, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t218; // size de funcion actual
+, t218, 1, t219; //pos del parametro 1
+, P, 0, t220;
=>, t220, t221, stack; 
+, P, 5, t222;
+, t221, 0, t223;
<=, t222, t221, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t224; // size de funcion actual
+, t224, 1, t225; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t226; // pos del objeto
=>, t226, t228, stack; //apuntador al heap del obejto
=>, t228, t229, heap; // recuperando pos incial del objeto
+, t229, 2, t228;
=>, t228, t230, heap; // valor a retoranar del acceso
<=, t225, t230, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t231;
=>, t231, t232, stack; // valor del return
-, P, 5, P;
<=, t219, t232, stack; // asignado al stack el parametro
+, p, 5, t233; // size de funcion actual
+, t233, 2, t234; //pos del parametro 2
+, P, 0, t235;
=>, t235, t236, stack; 
+, P, 5, t237;
+, t236, 0, t238;
<=, t237, t236, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t239; // size de funcion actual
+, t239, 1, t240; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t241; // pos del objeto
=>, t241, t243, stack; //apuntador al heap del obejto
=>, t243, t244, heap; // recuperando pos incial del objeto
+, t244, 3, t243;
=>, t243, t245, heap; // valor a retoranar del acceso
<=, t240, t245, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t246;
=>, t246, t247, stack; // valor del return
-, P, 5, P;
<=, t234, t247, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t248;
=>, t248, t249, stack; // valor del return
-, P, 5, P;
+, t249, 1, t250;
<=, t211, t250, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 2, t251; // pos del objeto
=>, t251, t253, stack; //apuntador al heap del obejto
=>, t253, t254, heap; // recuperando pos incial del objeto
+, t254, 1, t253;
=>, t253, t255, heap; // valor a retoranar del acceso
+, P, 0, t256;
=>, t256, t257, stack; 
+, P, 5, t258;
+, t257, 0, t259;
<=, t258, t257, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t260; // size de funcion actual
+, t260, 1, t261; //pos del parametro 1
+, P, 0, t262;
=>, t262, t263, stack; 
+, P, 5, t264;
+, t263, 0, t265;
<=, t264, t263, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t266; // size de funcion actual
+, t266, 1, t267; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t268; // pos del objeto
=>, t268, t270, stack; //apuntador al heap del obejto
=>, t270, t271, heap; // recuperando pos incial del objeto
+, t271, 2, t270;
=>, t270, t272, heap; // valor a retoranar del acceso
<=, t267, t272, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t273;
=>, t273, t274, stack; // valor del return
-, P, 5, P;
<=, t261, t274, stack; // asignado al stack el parametro
+, p, 5, t275; // size de funcion actual
+, t275, 2, t276; //pos del parametro 2
+, P, 0, t277;
=>, t277, t278, stack; 
+, P, 5, t279;
+, t278, 0, t280;
<=, t279, t278, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t281; // size de funcion actual
+, t281, 1, t282; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t283; // pos del objeto
=>, t283, t285, stack; //apuntador al heap del obejto
=>, t285, t286, heap; // recuperando pos incial del objeto
+, t286, 3, t285;
=>, t285, t287, heap; // valor a retoranar del acceso
<=, t282, t287, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t288;
=>, t288, t289, stack; // valor del return
-, P, 5, P;
<=, t276, t289, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t290;
=>, t290, t291, stack; // valor del return
-, P, 5, P;
+, t291, 1, t292;
<=, t253, t292, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t293; // pos de y
=>, t293, t294, stack; // valor de lo que trae en el stack y
+, P, 4, t295; // pos de retorno de a funcion Tree_Node_leftRotate_Node
<=, t295, t294, stack; //asignando el retorno con su valor
jmp, , , L13;

L13:
end, , Tree_Node_leftRotate_Node




begin, , , Tree_entero_getBalance_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t296; // pos de N
=>, t296, t297, stack; // valor de lo que trae en el stack N
je, t297, 36, L16;
jmp, , , L17;
L16:

// RESOLVIENDO UN RETORNO
+, P, 2, t298; // pos de retorno de a funcion Tree_entero_getBalance_Node
<=, t298, 0, stack; //asignando el retorno con su valor
jmp, , , L14;
jmp, , , L15; // salida del if
L17:

L15:
// RESOLVIENDO UN RETORNO
+, P, 0, t299;
=>, t299, t300, stack; 
+, P, 3, t301;
+, t300, 0, t302;
<=, t301, t300, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t303; // size de funcion actual
+, t303, 1, t304; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t305; // pos del objeto
=>, t305, t307, stack; //apuntador al heap del obejto
=>, t307, t308, heap; // recuperando pos incial del objeto
+, t308, 2, t307;
=>, t307, t309, heap; // valor a retoranar del acceso
<=, t304, t309, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_entero_height_Node;
+, P, 2, t310;
=>, t310, t311, stack; // valor del return
-, P, 3, P;
+, P, 0, t312;
=>, t312, t313, stack; 
+, P, 3, t314;
+, t313, 0, t315;
<=, t314, t313, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t316; // size de funcion actual
+, t316, 1, t317; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t318; // pos del objeto
=>, t318, t320, stack; //apuntador al heap del obejto
=>, t320, t321, heap; // recuperando pos incial del objeto
+, t321, 3, t320;
=>, t320, t322, heap; // valor a retoranar del acceso
<=, t317, t322, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_entero_height_Node;
+, P, 2, t323;
=>, t323, t324, stack; // valor del return
-, P, 3, P;
-, t311, t324, t325;
+, P, 2, t326; // pos de retorno de a funcion Tree_entero_getBalance_Node
<=, t326, t325, stack; //asignando el retorno con su valor
jmp, , , L14;

L14:
end, , Tree_entero_getBalance_Node




begin, , , Tree_Node_insert_Node_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t327; // pos de node2
=>, t327, t328, stack; // valor de lo que trae en el stack node2
je, t328, 36, L20;
jmp, , , L21;
L20:

// ----------- Instancia a una variable local --------------
+, p, 3, t329; // pos de o
<=, t329, h, stack; //guardando referencia del heap para el objeto o
+, h, 1, t330; // guardo la posicion donde inicia el objeto 
<=, h, t330, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 4, h; // reservando espacio para el objeto o
//Ingresando referencia al this del objeto o
+, p, 3, t331; // pos de o
=>, t331, t332, stack; // obteniendo apuntador de o
+, p, 6, t333; // simulando cambio de ambito
+, t333, 0, t334; //pos del this de o
<=, t334, t332, stack; // insertando apuntador del heap al stack del obeto o
// Asignando parametros  
+, p, 6, t335; // size de funcion actual
+, t335, 1, t336; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t337; // pos de key
=>, t337, t338, stack; // valor de lo que trae en el stack key
<=, t336, t338, stack; // asignado al stack el parametro
+, p, 6, p; // simulando cambio de ambito
call, , , Node_vacio_Node_entero;
-, p, 6, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t339; // pos de o
=>, t339, t340, stack; // valor de lo que trae en el stack o
+, P, 5, t341; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t341, t340, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L19; // salida del if
L21:

L19:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t342; // pos de key
=>, t342, t343, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t344; // pos del objeto
=>, t344, t346, stack; //apuntador al heap del obejto
=>, t346, t347, heap; // recuperando pos incial del objeto
+, t347, 0, t346;
=>, t346, t348, heap; // valor a retoranar del acceso
jl, t343, t348, L23;
jmp, , , L24;
L23:

// Resolviendo una cadena 
+, H, 0, t349; //apuntaodr a cadena 
+, H, 1, t350; //apu donde inicia la cadena
<=, t349, t350, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t351; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t349);
// ----------------- Resolviendo acceso local 
+, P, 1, t352; // pos del objeto
=>, t352, t354, stack; //apuntador al heap del obejto
=>, t354, t355, heap; // recuperando pos incial del objeto
+, t355, 2, t354;
=>, t354, t356, heap; // valor a retoranar del acceso
+, P, 0, t357;
=>, t357, t358, stack; 
+, P, 6, t359;
+, t358, 0, t360;
<=, t359, t358, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t361; // size de funcion actual
+, t361, 1, t362; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t363; // pos del objeto
=>, t363, t365, stack; //apuntador al heap del obejto
=>, t365, t366, heap; // recuperando pos incial del objeto
+, t366, 2, t365;
=>, t365, t367, heap; // valor a retoranar del acceso
<=, t362, t367, stack; // asignado al stack el parametro
+, p, 6, t368; // size de funcion actual
+, t368, 2, t369; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t370; // pos de key
=>, t370, t371, stack; // valor de lo que trae en el stack key
<=, t369, t371, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t372;
=>, t372, t373, stack; // valor del return
-, P, 6, P;
<=, t354, t373, heap; // asignando variable 
jmp, , , L22; // salida del if
L24:

// Resolviendo una cadena 
+, H, 0, t374; //apuntaodr a cadena 
+, H, 1, t375; //apu donde inicia la cadena
<=, t374, t375, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t376; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t374);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t377; // pos de key
=>, t377, t378, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t379; // pos del objeto
=>, t379, t381, stack; //apuntador al heap del obejto
=>, t381, t382, heap; // recuperando pos incial del objeto
+, t382, 0, t381;
=>, t381, t383, heap; // valor a retoranar del acceso
jg, t378, t383, L26;
jmp, , , L27;
L26:

// ----------------- Resolviendo acceso local 
+, P, 1, t384; // pos del objeto
=>, t384, t386, stack; //apuntador al heap del obejto
=>, t386, t387, heap; // recuperando pos incial del objeto
+, t387, 3, t386;
=>, t386, t388, heap; // valor a retoranar del acceso
+, P, 0, t389;
=>, t389, t390, stack; 
+, P, 6, t391;
+, t390, 0, t392;
<=, t391, t390, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t393; // size de funcion actual
+, t393, 1, t394; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t395; // pos del objeto
=>, t395, t397, stack; //apuntador al heap del obejto
=>, t397, t398, heap; // recuperando pos incial del objeto
+, t398, 3, t397;
=>, t397, t399, heap; // valor a retoranar del acceso
<=, t394, t399, stack; // asignado al stack el parametro
+, p, 6, t400; // size de funcion actual
+, t400, 2, t401; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t402; // pos de key
=>, t402, t403, stack; // valor de lo que trae en el stack key
<=, t401, t403, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t404;
=>, t404, t405, stack; // valor del return
-, P, 6, P;
<=, t386, t405, heap; // asignando variable 
jmp, , , L25; // salida del if
L27:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t406; // pos de node2
=>, t406, t407, stack; // valor de lo que trae en el stack node2
+, P, 5, t408; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t408, t407, stack; //asignando el retorno con su valor
jmp, , , L18;
L25:
L22:
// ----------------- Resolviendo acceso local 
+, P, 1, t409; // pos del objeto
=>, t409, t411, stack; //apuntador al heap del obejto
=>, t411, t412, heap; // recuperando pos incial del objeto
+, t412, 1, t411;
=>, t411, t413, heap; // valor a retoranar del acceso
+, P, 0, t414;
=>, t414, t415, stack; 
+, P, 6, t416;
+, t415, 0, t417;
<=, t416, t415, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t418; // size de funcion actual
+, t418, 1, t419; //pos del parametro 1
+, P, 0, t420;
=>, t420, t421, stack; 
+, P, 6, t422;
+, t421, 0, t423;
<=, t422, t421, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t424; // size de funcion actual
+, t424, 1, t425; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t426; // pos del objeto
=>, t426, t428, stack; //apuntador al heap del obejto
=>, t428, t429, heap; // recuperando pos incial del objeto
+, t429, 2, t428;
=>, t428, t430, heap; // valor a retoranar del acceso
<=, t425, t430, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_height_Node;
+, P, 2, t431;
=>, t431, t432, stack; // valor del return
-, P, 6, P;
<=, t419, t432, stack; // asignado al stack el parametro
+, p, 6, t433; // size de funcion actual
+, t433, 2, t434; //pos del parametro 2
+, P, 0, t435;
=>, t435, t436, stack; 
+, P, 6, t437;
+, t436, 0, t438;
<=, t437, t436, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t439; // size de funcion actual
+, t439, 1, t440; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t441; // pos del objeto
=>, t441, t443, stack; //apuntador al heap del obejto
=>, t443, t444, heap; // recuperando pos incial del objeto
+, t444, 3, t443;
=>, t443, t445, heap; // valor a retoranar del acceso
<=, t440, t445, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_height_Node;
+, P, 2, t446;
=>, t446, t447, stack; // valor del return
-, P, 6, P;
<=, t434, t447, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t448;
=>, t448, t449, stack; // valor del return
-, P, 6, P;
+, 1, t449, t450;
<=, t411, t450, heap; // asignando variable 
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t451; // pos de balance
+, P, 0, t452;
=>, t452, t453, stack; 
+, P, 6, t454;
+, t453, 0, t455;
<=, t454, t453, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t456; // size de funcion actual
+, t456, 1, t457; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t458; // pos de node2
=>, t458, t459, stack; // valor de lo que trae en el stack node2
<=, t457, t459, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_getBalance_Node;
+, P, 2, t460;
=>, t460, t461, stack; // valor del return
-, P, 6, P;
<=, t451, t461, stack; // asignando a balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t462; // pos de balance
=>, t462, t463, stack; // valor de lo que trae en el stack balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t464; // pos de key
=>, t464, t465, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t466; // pos del objeto
=>, t466, t468, stack; //apuntador al heap del obejto
=>, t468, t469, heap; // recuperando pos incial del objeto
+, t469, 2, t468;
=>, t468, t470, heap; // recuperando pos incial del objeto
+, t470, 0, t468;
=>, t468, t471, heap; // valor a retoranar del acceso
jg, t463, 1, L29;
jmp, , , L30;
L29:

jl, t465, t471, L31;
jmp, , , L32;

L31:

// RESOLVIENDO UN RETORNO
+, P, 0, t472;
=>, t472, t473, stack; 
+, P, 6, t474;
+, t473, 0, t475;
<=, t474, t473, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t476; // size de funcion actual
+, t476, 1, t477; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t478; // pos de node2
=>, t478, t479, stack; // valor de lo que trae en el stack node2
<=, t477, t479, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t480;
=>, t480, t481, stack; // valor del return
-, P, 6, P;
+, P, 5, t482; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t482, t481, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L28; // salida del if
L30:
L32:

L28:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t483; // pos de balance
=>, t483, t484, stack; // valor de lo que trae en el stack balance
*, 1, -1, t485;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t486; // pos de key
=>, t486, t487, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t488; // pos del objeto
=>, t488, t490, stack; //apuntador al heap del obejto
=>, t490, t491, heap; // recuperando pos incial del objeto
+, t491, 3, t490;
=>, t490, t492, heap; // recuperando pos incial del objeto
+, t492, 0, t490;
=>, t490, t493, heap; // valor a retoranar del acceso
jl, t484, t485, L34;
jmp, , , L35;
L34:

jg, t487, t493, L36;
jmp, , , L37;

L36:

// RESOLVIENDO UN RETORNO
+, P, 0, t494;
=>, t494, t495, stack; 
+, P, 6, t496;
+, t495, 0, t497;
<=, t496, t495, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t498; // size de funcion actual
+, t498, 1, t499; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t500; // pos de node2
=>, t500, t501, stack; // valor de lo que trae en el stack node2
<=, t499, t501, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t502;
=>, t502, t503, stack; // valor del return
-, P, 6, P;
+, P, 5, t504; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t504, t503, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L33; // salida del if
L35:
L37:

L33:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t505; // pos de balance
=>, t505, t506, stack; // valor de lo que trae en el stack balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t507; // pos de key
=>, t507, t508, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t509; // pos del objeto
=>, t509, t511, stack; //apuntador al heap del obejto
=>, t511, t512, heap; // recuperando pos incial del objeto
+, t512, 2, t511;
=>, t511, t513, heap; // recuperando pos incial del objeto
+, t513, 0, t511;
=>, t511, t514, heap; // valor a retoranar del acceso
jg, t506, 1, L39;
jmp, , , L40;
L39:

jg, t508, t514, L41;
jmp, , , L42;

L41:

// ----------------- Resolviendo acceso local 
+, P, 1, t515; // pos del objeto
=>, t515, t517, stack; //apuntador al heap del obejto
=>, t517, t518, heap; // recuperando pos incial del objeto
+, t518, 2, t517;
=>, t517, t519, heap; // valor a retoranar del acceso
+, P, 0, t520;
=>, t520, t521, stack; 
+, P, 6, t522;
+, t521, 0, t523;
<=, t522, t521, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t524; // size de funcion actual
+, t524, 1, t525; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t526; // pos del objeto
=>, t526, t528, stack; //apuntador al heap del obejto
=>, t528, t529, heap; // recuperando pos incial del objeto
+, t529, 2, t528;
=>, t528, t530, heap; // valor a retoranar del acceso
<=, t525, t530, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t531;
=>, t531, t532, stack; // valor del return
-, P, 6, P;
<=, t517, t532, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
+, P, 0, t533;
=>, t533, t534, stack; 
+, P, 6, t535;
+, t534, 0, t536;
<=, t535, t534, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t537; // size de funcion actual
+, t537, 1, t538; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t539; // pos de node2
=>, t539, t540, stack; // valor de lo que trae en el stack node2
<=, t538, t540, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t541;
=>, t541, t542, stack; // valor del return
-, P, 6, P;
+, P, 5, t543; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t543, t542, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L38; // salida del if
L40:
L42:

L38:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t544; // pos de balance
=>, t544, t545, stack; // valor de lo que trae en el stack balance
*, 1, -1, t546;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t547; // pos de key
=>, t547, t548, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t549; // pos del objeto
=>, t549, t551, stack; //apuntador al heap del obejto
=>, t551, t552, heap; // recuperando pos incial del objeto
+, t552, 3, t551;
=>, t551, t553, heap; // recuperando pos incial del objeto
+, t553, 0, t551;
=>, t551, t554, heap; // valor a retoranar del acceso
jl, t545, t546, L44;
jmp, , , L45;
L44:

jl, t548, t554, L46;
jmp, , , L47;

L46:

// ----------------- Resolviendo acceso local 
+, P, 1, t555; // pos del objeto
=>, t555, t557, stack; //apuntador al heap del obejto
=>, t557, t558, heap; // recuperando pos incial del objeto
+, t558, 3, t557;
=>, t557, t559, heap; // valor a retoranar del acceso
+, P, 0, t560;
=>, t560, t561, stack; 
+, P, 6, t562;
+, t561, 0, t563;
<=, t562, t561, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t564; // size de funcion actual
+, t564, 1, t565; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t566; // pos del objeto
=>, t566, t568, stack; //apuntador al heap del obejto
=>, t568, t569, heap; // recuperando pos incial del objeto
+, t569, 3, t568;
=>, t568, t570, heap; // valor a retoranar del acceso
<=, t565, t570, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t571;
=>, t571, t572, stack; // valor del return
-, P, 6, P;
<=, t557, t572, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
+, P, 0, t573;
=>, t573, t574, stack; 
+, P, 6, t575;
+, t574, 0, t576;
<=, t575, t574, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t577; // size de funcion actual
+, t577, 1, t578; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t579; // pos de node2
=>, t579, t580, stack; // valor de lo que trae en el stack node2
<=, t578, t580, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t581;
=>, t581, t582, stack; // valor del return
-, P, 6, P;
+, P, 5, t583; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t583, t582, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L43; // salida del if
L45:
L47:

L43:
// Resolviendo una cadena 
+, H, 0, t584; //apuntaodr a cadena 
+, H, 1, t585; //apu donde inicia la cadena
<=, t584, t585, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t586; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 40, heap; //guardadndo (
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t584);
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t587; // pos de node2
=>, t587, t588, stack; // valor de lo que trae en el stack node2
+, P, 5, t589; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t589, t588, stack; //asignando el retorno con su valor
jmp, , , L18;

L18:
end, , Tree_Node_insert_Node_entero




begin, , , Tree_vacio_postOrder_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t590; // pos de node2
=>, t590, t591, stack; // valor de lo que trae en el stack node2
jne, t591, 36, L50;
jmp, , , L51;
L50:

// Resolviendo una cadena 
+, H, 0, t592; //apuntaodr a cadena 
+, H, 1, t593; //apu donde inicia la cadena
<=, t592, t593, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 18, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t594; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t592);
// ----------------- Resolviendo acceso local 
+, P, 1, t595; // pos del objeto
=>, t595, t597, stack; //apuntador al heap del obejto
=>, t597, t598, heap; // recuperando pos incial del objeto
+, t598, 0, t597;
=>, t597, t599, heap; // valor a retoranar del acceso
print("%d", t599);
+, P, 0, t600;
=>, t600, t601, stack; 
+, P, 3, t602;
+, t601, 0, t603;
<=, t602, t601, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t604; // size de funcion actual
+, t604, 1, t605; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t606; // pos del objeto
=>, t606, t608, stack; //apuntador al heap del obejto
=>, t608, t609, heap; // recuperando pos incial del objeto
+, t609, 2, t608;
=>, t608, t610, heap; // valor a retoranar del acceso
<=, t605, t610, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_vacio_postOrder_Node;
+, P, 2, t611;
=>, t611, t612, stack; // valor del return
-, P, 3, P;
+, P, 0, t613;
=>, t613, t614, stack; 
+, P, 3, t615;
+, t614, 0, t616;
<=, t615, t614, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t617; // size de funcion actual
+, t617, 1, t618; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t619; // pos del objeto
=>, t619, t621, stack; //apuntador al heap del obejto
=>, t621, t622, heap; // recuperando pos incial del objeto
+, t622, 3, t621;
=>, t621, t623, heap; // valor a retoranar del acceso
<=, t618, t623, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_vacio_postOrder_Node;
+, P, 2, t624;
=>, t624, t625, stack; // valor del return
-, P, 3, P;
jmp, , , L49; // salida del if
L51:

L49:

L48:
end, , Tree_vacio_postOrder_Node


