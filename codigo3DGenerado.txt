

begin, , , llanta_vacio_llanta_entero_entero

// Asignando atributo valor1Llanta
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de valor1Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de val1
=>, t5, t6, stack; // valor de lo que trae en el stack val1
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo valor2Llanta
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de valor2Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t11; // pos de val2
=>, t11, t12, stack; // valor de lo que trae en el stack val2
<=, t10, t12, heap; //guardando en el heap el valor del atributo

L1:
end, , llanta_vacio_llanta_entero_entero




begin, , , llanta_vacio_mostrarVAlor1

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t13; // pos this 
=>, t13, t14, stack; // obtenido apuntador al heap 
=>, t14, t15, heap; // apuntador 
+, t15, 0, t16; // pos de valor1Llanta
=>, t16, t17, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t17);

L2:
end, , llanta_vacio_mostrarVAlor1




begin, , , llanta_vacio_mostrarVAlor2

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t18; // pos this 
=>, t18, t19, stack; // obtenido apuntador al heap 
=>, t19, t20, heap; // apuntador 
+, t20, 1, t21; // pos de valor2Llanta
=>, t21, t22, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t22);

L3:
end, , llanta_vacio_mostrarVAlor2




begin, , , carro_vacio_carro_caracter_entero

// Asignando atributo col
+, p, 0, t23; //pos this 
=>, t23, t24, stack; // apuntador al heap
=>, t24, t25, heap; // apuntador donde inicia el objeto
+, t25, 0, t26; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t27; // pos de color
=>, t27, t28, stack; // valor de lo que trae en el stack color
<=, t26, t28, heap; //guardando en el heap el valor del atributo
print("%c", 89);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t29; // pos de rinLlanta
=>, t29, t30, stack; // valor de lo que trae en el stack rinLlanta
print("%d", t30);
// Asignando atributo valorCarro
+, p, 0, t31; //pos this 
=>, t31, t32, stack; // apuntador al heap
=>, t32, t33, heap; // apuntador donde inicia el objeto
+, t33, 2, t34; // pos real  de valorCarro
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t35; // pos de rinLlanta
=>, t35, t36, stack; // valor de lo que trae en el stack rinLlanta
<=, t34, t36, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t37;// pos this de lla1
=>, t37, t38, stack; //apuntador del heap de lla1
=>, t38, t39, heap; //posicion real del heap donde inicia lla1
+, t39, 1, t40; //pos real del atributo lla1
<=, t40, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t41;
=>, t41, t42, stack; //apuntador al heap de lla1
=>, t42, t43, heap; //posicion real donde incia el objeto lla1
+, t43, 1, t44; // pos real donde incial el objeto lla1

+, p, 4, t45; // tamanho de la funcion actual carro_vacio_carro_caracter_entero
+, t45, 0, t46; // pos del this para la nueva instancia de lla1
<=, t46, t44, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 4, t47; // size de funcion actual
+, t47, 1, t48; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t49; // pos de rinLlanta
=>, t49, t50, stack; // valor de lo que trae en el stack rinLlanta
*, t50, 2, t51;
<=, t48, t51, stack; // asignado al stack el parametro
+, p, 4, t52; // size de funcion actual
+, t52, 2, t53; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t54; // pos de rinLlanta
=>, t54, t55, stack; // valor de lo que trae en el stack rinLlanta
*, t55, 3, t56;
<=, t53, t56, stack; // asignado al stack el parametro
+, p, 4, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 4, p; // regresando al ambito acutal

print("%c", 77);
// Resolviendo un acceso para un atrinuto
+, P, 0, t57; 
=>, t57, t58, stack; // apuntador al heap
=>, t58, t59, heap;
+, t59, 1, t61; 
=>, t61, t62, heap; // recuperando pos incial del objeto
+, t62, 0, t61;
=>, t61, t63, heap; // valor a retoranar del acceso
print("%d", t63);
// Resolviendo un acceso para un atrinuto
+, P, 0, t64; 
=>, t64, t65, stack; // apuntador al heap
=>, t65, t66, heap;
+, t66, 1, t68; 
=>, t68, t69, heap; // recuperando pos incial del objeto
+, t69, 0, t68;
=>, t68, t70, heap; // valor a retoranar del acceso
=>, t68, t71, heap; //obtenidoe el valor la vairable 
*, t71, 8, t72;
<=, t68, t72, heap; // asignando vairble  
// Resolviendo un acceso para un atrinuto
+, P, 0, t73; 
=>, t73, t74, stack; // apuntador al heap
=>, t74, t75, heap;
+, t75, 1, t77; 
=>, t77, t78, heap; // recuperando pos incial del objeto
+, t78, 0, t77;
=>, t77, t79, heap; // valor a retoranar del acceso
print("%d", t79);

L4:
end, , carro_vacio_carro_caracter_entero




begin, , , carro_caracter_obtenerNombreCarro

// ------------------------ Creando arreglo local h
+, P, 1, t80; //pos de arreglo h
<=, t80, H, stack; // ingrensando al stack apunt del heap para h
+, H, 1, t81;
<=, H, t81, heap; //insetnado donde inicia el arreglo h
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t82; //calculando el n real
-, t82, 0, t83; //iReal columna 0
+, t83, 1, t83; //size del arreglo h
<=, H, t83, heap; // insertando el tamanio del arreglo linealizado h
+, H, 1, H;
+, h, t83, h; // reservnado el espacio del arreglo h
// Resolviendo una cadena 
+, H, 0, t84; //apuntaodr a cadena 
+, H, 1, t85; //apu donde inicia la cadena
<=, t84, t85, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 12, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t86; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 1, t89; // pos del arreglo 
=>, t89, t90, stack; //apuntador al heap del arreglo
=>, t90, t91, heap; // apuntador del heap al heap donde inicia la cadena
=>, t91, t87, heap; // size del arreglo h
+, t91, 1, t88; // pos 0 donde inicia el arreglo h
=>, t84, t92, heap; // pos que apunta al size de la cadena
=>, t92, t93, heap; // size de la cadena
+, t92, 1, t94; // Pos 0 de la cadena
=>, t94, t95, heap; // sacandor el caracter del heap cadena
jle, t93, t87, L6;
jmp, , , L7;
jmp, , , L6;
L6:
jne, t95, 34, L8;
jmp, , , L9;
jmp, , , L8;
L8:
<=, t88, t95, heap; // guardando el caracter 
+, t88, 1, t88; // incremnetnado la pos del arreglo
+, t94, 1, t94; // incrementando la pos de la cadena
=>, t94, t95, heap; // sacandor el caracter del heap cadena
jmp, , , L6;
jmp, , , L9;
L9:
jmp, , , L7;
L7:
+, P, 1, t96; // pos de arreglo h
=>, t96, t97, stack; // apunt al heap de arreglo h
=>, t97, t98, heap; //apunt al heap donde inicia el arreglo h
=>, t98, t99, heap; //obteniendo el tamanio del arreglo h
+, t98, 1, t100; // pos 0 del arreglo h
// ---- Calculo de valor de las posiciones  
// -----------(Obteniendo valor) Calculo de iReal para el arreglo h
-, 4, 0, t101; //calculando el n real ()
-, t101, 0, t102; //iReal columna 0
+, t100, t102, t103; // pos buscada del arreglo  h
=>, t103, t104, heap; //valor que trae el objeto
print("%c", t104);
// RESOLVIENDO UN RETORNO
+, P, 1, t105; // pos de arreglo h
=>, t105, t106, stack; // apunt al heap de arreglo h
=>, t106, t107, heap; //apunt al heap donde inicia el arreglo h
=>, t107, t108, heap; //obteniendo el tamanio del arreglo h
+, t107, 1, t109; // pos 0 del arreglo h
// ---- Calculo de valor de las posiciones  
// -----------(Obteniendo valor) Calculo de iReal para el arreglo h
-, 8, 0, t110; //calculando el n real ()
-, t110, 0, t111; //iReal columna 0
+, t109, t111, t112; // pos buscada del arreglo  h
=>, t112, t113, heap; //valor que trae el objeto
+, P, 2, t114; // pos de retorno de a funcion carro_caracter_obtenerNombreCarro
<=, t114, t113, stack; //asignando el retorno con su valor
jmp, , , L5;

L5:
end, , carro_caracter_obtenerNombreCarro




begin, , , carro_caracter_obtenerColor

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t115; // pos this 
=>, t115, t116, stack; // obtenido apuntador al heap 
=>, t116, t117, heap; // apuntador 
+, t117, 0, t118; // pos de col
=>, t118, t119, heap; // obtengo el valor que se encuentre en el heap 
+, P, 1, t120; // pos de retorno de a funcion carro_caracter_obtenerColor
<=, t120, t119, stack; //asignando el retorno con su valor
jmp, , , L10;

L10:
end, , carro_caracter_obtenerColor




begin, , , carro_entero_obtenerValor

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t121; // pos this 
=>, t121, t122, stack; // obtenido apuntador al heap 
=>, t122, t123, heap; // apuntador 
+, t123, 2, t124; // pos de valorCarro
=>, t124, t125, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t125);
print("%c", 76);
// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t126; // pos this 
=>, t126, t127, stack; // obtenido apuntador al heap 
=>, t127, t128, heap; // apuntador 
+, t128, 2, t129; // pos de valorCarro
=>, t129, t130, heap; // obtengo el valor que se encuentre en el heap 
*, t130, 5, t131;
+, P, 1, t132; // pos de retorno de a funcion carro_entero_obtenerValor
<=, t132, t131, stack; //asignando el retorno con su valor
jmp, , , L11;

L11:
end, , carro_entero_obtenerValor




begin, , , carro_vacio_carro_caracter

// Asignando atributo col
+, p, 0, t133; //pos this 
=>, t133, t134, stack; // apuntador al heap
=>, t134, t135, heap; // apuntador donde inicia el objeto
+, t135, 0, t136; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t137; // pos de n
=>, t137, t138, stack; // valor de lo que trae en el stack n
<=, t136, t138, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t139;// pos this de lla1
=>, t139, t140, stack; //apuntador del heap de lla1
=>, t140, t141, heap; //posicion real del heap donde inicia lla1
+, t141, 1, t142; //pos real del atributo lla1
<=, t142, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t143;
=>, t143, t144, stack; //apuntador al heap de lla1
=>, t144, t145, heap; //posicion real donde incia el objeto lla1
+, t145, 1, t146; // pos real donde incial el objeto lla1

+, p, 3, t147; // tamanho de la funcion actual carro_vacio_carro_caracter
+, t147, 0, t148; // pos del this para la nueva instancia de lla1
<=, t148, t146, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 3, t149; // size de funcion actual
+, t149, 1, t150; //pos del parametro 1
<=, t150, 10, stack; // asignado al stack el parametro
+, p, 3, t151; // size de funcion actual
+, t151, 2, t152; //pos del parametro 2
<=, t152, 20, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 3, p; // regresando al ambito acutal


L12:
end, , carro_vacio_carro_caracter




begin, , , carro_vacio_imprimir_Color

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t153; // pos this 
=>, t153, t154, stack; // obtenido apuntador al heap 
=>, t154, t155, heap; // apuntador 
+, t155, 0, t156; // pos de col
=>, t156, t157, heap; // obtengo el valor que se encuentre en el heap 
print("%c", t157);

L13:
end, , carro_vacio_imprimir_Color




begin, , , persona_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t158; // pos de p1
<=, t158, h, stack; //guardando referencia del heap para el objeto p1
+, h, 1, t159; // guardo la posicion donde inicia el objeto 
<=, h, t159, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto p1
//Ingresando referencia al this del objeto p1
+, p, 0, t160; // pos de p1
=>, t160, t161, stack; // obteniendo apuntador de p1
+, p, 4, t162; // simulando cambio de ambito
+, t162, 0, t163; //pos del this de p1
<=, t163, t161, stack; // insertando apuntador del heap al stack del obeto p1
// Asignando parametros  
+, p, 4, t164; // size de funcion actual
+, t164, 1, t165; //pos del parametro 1
<=, t165, 25, stack; // asignado al stack el parametro
+, p, 4, t166; // size de funcion actual
+, t166, 2, t167; //pos del parametro 2
<=, t167, 80, stack; // asignado al stack el parametro
+, p, 4, p; // simulando cambio de ambito
call, , , persona_vacio_persona_entero_caracter;
-, p, 4, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t168; // pos del objeto
=>, t168, t170, stack; //apuntador al heap del obejto
+, P, 2, t171;
+, t171, 0, t172;
<=, t172, t170, stack; // pasadon como refeenria el valor del this
+, P, 2, P;
call, , , persona_entero_incrementarEdad;
+, P, 1, t173;
=>, t173, t174, stack; // valor del return
-, P, 2, P;
=>, t173, t175, stack; // valor a retoranar del acceso
print("%d", t175);
// ----------------- Resolviendo acceso local 
+, P, 0, t176; // pos del objeto
=>, t176, t178, stack; //apuntador al heap del obejto
=>, t178, t179, heap; // recuperando pos incial del objeto
+, t179, 1, t178;
=>, t178, t180, heap; // recuperando pos incial del objeto
+, t180, 2, t178;
=>, t178, t181, heap; // valor a retoranar del acceso
=>, t178, t182, heap; //obtenidoe el valor la vairable 
*, t182, 10, t183;
<=, t178, t183, heap; // asignando vairble  
// ----------------- Resolviendo acceso local 
+, P, 0, t184; // pos del objeto
=>, t184, t186, stack; //apuntador al heap del obejto
=>, t186, t187, heap; // recuperando pos incial del objeto
+, t187, 1, t186;
=>, t186, t188, heap; // recuperando pos incial del objeto
+, t188, 2, t186;
=>, t186, t189, heap; // valor a retoranar del acceso
print("%d", t189);
print("%c", 74);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t190; // pos de valor1
// ----------------- Resolviendo acceso local 
+, P, 0, t191; // pos del objeto
=>, t191, t193, stack; //apuntador al heap del obejto
+, P, 3, t194;
+, t194, 0, t195;
<=, t195, t193, stack; // pasadon como refeenria el valor del this
+, P, 3, P;
call, , , persona_carro_retornoCarro;
+, P, 2, t196;
=>, t196, t197, stack; // valor del return
-, P, 3, P;
=>, t196, t198, stack; // recuperando pos incial del objeto 888
+, t198, 0, t196;
+, P, 3, t199;
+, t199, 0, t200;
<=, t200, t196, stack; // pasadon como refeenria el valor del this
+, P, 3, P;
call, , , carro_caracter_obtenerNombreCarro;
+, P, 2, t201;
=>, t201, t202, stack; // valor del return
-, P, 3, P;
=>, t201, t203, stack; // valor a retoranar del acceso
<=, t190, t203, stack; // asignando a valor1
// ------------------------ Creando arreglo local nombre
+, P, 2, t204; //pos de arreglo nombre
<=, t204, H, stack; // ingrensando al stack apunt del heap para nombre
+, H, 1, t205;
<=, H, t205, heap; //insetnado donde inicia el arreglo nombre
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t206; //calculando el n real
-, t206, 0, t207; //iReal columna 0
+, t207, 1, t207; //size del arreglo nombre
<=, H, t207, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, h, t207, h; // reservnado el espacio del arreglo nombre
// Resolviendo una cadena 
+, H, 0, t208; //apuntaodr a cadena 
+, H, 1, t209; //apu donde inicia la cadena
<=, t208, t209, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 12, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t210; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 85, heap; //guardadndo U
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 2, t213; // pos del arreglo 
=>, t213, t214, stack; //apuntador al heap del arreglo
=>, t214, t215, heap; // apuntador del heap al heap donde inicia la cadena
=>, t215, t211, heap; // size del arreglo nombre
+, t215, 1, t212; // pos 0 donde inicia el arreglo nombre
=>, t208, t216, heap; // pos que apunta al size de la cadena
=>, t216, t217, heap; // size de la cadena
+, t216, 1, t218; // Pos 0 de la cadena
=>, t218, t219, heap; // sacandor el caracter del heap cadena
jle, t217, t211, L15;
jmp, , , L16;
jmp, , , L15;
L15:
jne, t219, 34, L17;
jmp, , , L18;
jmp, , , L17;
L17:
<=, t212, t219, heap; // guardando el caracter 
+, t212, 1, t212; // incremnetnado la pos del arreglo
+, t218, 1, t218; // incrementando la pos de la cadena
=>, t218, t219, heap; // sacandor el caracter del heap cadena
jmp, , , L15;
jmp, , , L18;
L18:
jmp, , , L16;
L16:
+, P, 2, t220; // pos de arreglo nombre
=>, t220, t221, stack; // apunt al heap de arreglo nombre
=>, t221, t222, heap; //apunt al heap donde inicia el arreglo nombre
=>, t222, t223, heap; //obteniendo el tamanio del arreglo nombre
+, t222, 1, t224; // pos 0 del arreglo nombre
// ---- Calculo de valor de las posiciones  
// -----------(Obteniendo valor) Calculo de iReal para el arreglo nombre
-, 8, 0, t225; //calculando el n real ()
-, t225, 0, t226; //iReal columna 0
+, t224, t226, t227; // pos buscada del arreglo  nombre
=>, t227, t228, heap; //valor que trae el objeto
print("%c", t228);
+, P, 2, t229; // pos de arreglo nombre
=>, t229, t230, stack; // apunt al heap de arreglo nombre
=>, t230, t231, heap; //apunt al heap donde inicia el arreglo nombre
=>, t231, t232, heap; //obteniendo el tamanio del arreglo nombre
+, t231, 1, t233; // pos 0 del arreglo nombre
// ---- Calculo de valor de las posiciones  
// -----------(Obteniendo valor) Calculo de iReal para el arreglo nombre
-, 4, 0, t234; //calculando el n real ()
-, t234, 0, t235; //iReal columna 0
+, t233, t235, t236; // pos buscada del arreglo  nombre
=>, t236, t237, heap; //valor que trae el objeto
print("%c", t237);
// ----------------- Resolviendo acceso local 
+, P, 0, t238; // pos del objeto
=>, t238, t240, stack; //apuntador al heap del obejto
//------------- Asignancio posicion de un arreglo Atributo  nombre
=>, t240, t242, heap; // obteniendo apuntador al heap del arreglo 
+, t242, 2, t241; // pos del arreglo dentro del heap acceso 
=>, t241, t243, heap; // apuntador donde inicia el arreglo
=>, t243, t244, heap; // size del arreglo nombre
+, t243, 1, t245; //pos 0 del arreglo nombre
// ----------- Calculo de iReal para el arreglo nombre
-, 4, 0, t246; //calculando el n real ()
-, t246, 0, t247; //iReal columna 0
+, t245, t247, t248; // pos buscade del arreglo atributo nombre
=>, t248, t249, heap; // valor a retoranar del acceso
print("%c", t249);
// ----------------- Resolviendo acceso local 
+, P, 0, t250; // pos del objeto
=>, t250, t252, stack; //apuntador al heap del obejto
//------------- Asignancio posicion de un arreglo Atributo  nombre
=>, t252, t254, heap; // obteniendo apuntador al heap del arreglo 
+, t254, 2, t253; // pos del arreglo dentro del heap acceso 
=>, t253, t255, heap; // apuntador donde inicia el arreglo
=>, t255, t256, heap; // size del arreglo nombre
+, t255, 1, t257; //pos 0 del arreglo nombre
// ----------- Calculo de iReal para el arreglo nombre
-, 4, 0, t258; //calculando el n real ()
-, t258, 0, t259; //iReal columna 0
+, t257, t259, t260; // pos buscade del arreglo atributo nombre
=>, t260, t261, heap; // valor a retoranar del acceso
<=, t260, 69, heap; // asignando variable 
print("%c", 69);
// ----------------- Resolviendo acceso local 
+, P, 0, t262; // pos del objeto
=>, t262, t264, stack; //apuntador al heap del obejto
=>, t264, t265, heap; // recuperando pos incial del objeto
+, t265, 2, t264;
=>, t264, t266, heap; // recuperando pos incial del objeto
=>, t266, t267, heap; // obteneindio el size del arreglo 
print("%d", t267);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t268; // pos de i
<=, t268, 0, stack; // asignando a i
// Resolviendo un repetur mientras
jmp, , ,L19; //regresando a la etiqueral del ciclo repetir- mientras
L19:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t269; // pos de i
=>, t269, t270, stack; // valor de lo que trae en el stack i
// ----------------- Resolviendo acceso local 
+, P, 0, t271; // pos del objeto
=>, t271, t273, stack; //apuntador al heap del obejto
=>, t273, t274, heap; // recuperando pos incial del objeto
+, t274, 2, t273;
=>, t273, t275, heap; // recuperando pos incial del objeto
=>, t275, t276, heap; // obteneindio el size del arreglo 
jl, t270, t276, L20;
jmp, , , L21;
L20:

// ----------------- Resolviendo acceso local 
+, P, 0, t277; // pos del objeto
=>, t277, t279, stack; //apuntador al heap del obejto
//------------- Asignancio posicion de un arreglo Atributo  nombre
=>, t279, t281, heap; // obteniendo apuntador al heap del arreglo 
+, t281, 2, t280; // pos del arreglo dentro del heap acceso 
=>, t280, t282, heap; // apuntador donde inicia el arreglo
=>, t282, t283, heap; // size del arreglo nombre
+, t282, 1, t284; //pos 0 del arreglo nombre
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t285; // pos de i
=>, t285, t286, stack; // valor de lo que trae en el stack i
// ----------- Calculo de iReal para el arreglo nombre
-, t286, 0, t287; //calculando el n real ()
-, t287, 0, t288; //iReal columna 0
+, t284, t288, t289; // pos buscade del arreglo atributo nombre
=>, t289, t290, heap; // valor a retoranar del acceso
print("%c", t290);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t291; // pos de i
=>, t291, t292, stack; //obtenidoe el valor de i
+, t292, 1, t293;
<=, t291, t293, stack; // asignando a i
jmp, , ,L19; //regresando a la etiqueral del ciclo repetir mientras
L21:


L14:
end, , persona_PRINCIPAL




begin, , , persona_vacio_molestar

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t294; // pos this 
=>, t294, t295, stack; // obtenido apuntador al heap 
=>, t295, t296, heap; // apuntador 
+, t296, 0, t297; // pos de edad
=>, t297, t298, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t298);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t299; // pos de a
<=, t299, 189, stack; // asignando a a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t300; // pos de a
=>, t300, t301, stack; // valor de lo que trae en el stack a
print("%d", t301);
// RESOLVIENDO UN RETORNO
jmp, , , L22;
print("%c", 84);

L22:
end, , persona_vacio_molestar




begin, , , persona_carro_obtenerCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t302; // pos de c
<=, t302, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t303; // guardo la posicion donde inicia el objeto 
<=, h, t303, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t304; // pos de c
=>, t304, t305, stack; // obteniendo apuntador de c
+, p, 3, t306; // simulando cambio de ambito
+, t306, 0, t307; //pos del this de c
<=, t307, t305, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t308; // size de funcion actual
+, t308, 1, t309; //pos del parametro 1
<=, t309, 72, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t310; // pos de c
=>, t310, t311, stack; // valor de lo que trae en el stack c
+, P, 2, t312; // pos de retorno de a funcion persona_carro_obtenerCarro
<=, t312, t311, stack; //asignando el retorno con su valor
jmp, , , L23;

L23:
end, , persona_carro_obtenerCarro




begin, , , persona_entero_obtenernUmero

// RESOLVIENDO UN RETORNO
*, 5, 8, t313;
+, P, 1, t314; // pos de retorno de a funcion persona_entero_obtenernUmero
<=, t314, t313, stack; //asignando el retorno con su valor
jmp, , , L24;

L24:
end, , persona_entero_obtenernUmero




begin, , , persona_vacio_persona_entero_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t315; //pos this del arreglo
=>, t315, t316, stack; //obteniendo apuntador de arreglo en eel heap
=>, t316, t317, heap;//apuntando donde en verdad inicia el arreglo
+, t317, 2, t318; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t318, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t319; //calculando el n real
-, t319, 0, t320; //iReal columna 0
+, t320, 1, t320; //size del arreglo nombre
<=, H, t320, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t320, 0, t321; // anhadiendo una posicion mas
+, h, t321, h; // reservnado el espacio del arreglo nombre
+, P, 0, t324; // pos this del objeto 
=>, t324, t325, stack; // apuntador al heap del objeto 
=>, t325, t326, heap; // apunt al heap donde inica el objeto
+, t326, 2, t327; //apuntador a posicion donde incia el arreglo
=>, t327, t328, heap; // inicia el arreglo
=>, t328, t322, heap; // size del arreglo nombre
+, t328, 1, t323; //Pos 0 del arreglo
// Resolviendo una cadena 
+, H, 0, t329; //apuntaodr a cadena 
+, H, 1, t330; //apu donde inicia la cadena
<=, t329, t330, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 20, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t331; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 85, heap; //guardadndo U
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t329, t332, heap; // pos que apunta al size de la cadena
=>, t332, t333, heap; // size de la cadena
+, t332, 1, t334; // Pos 0 de la cadena
=>, t334, t335, heap; // sacandor el caracter del heap cadena
jle, t333, t322, L26;
jmp, , , L27;
jmp, , , L26;
L26:
jne, t335, 34, L28;
jmp, , , L29;
jmp, , , L28;
L28:
<=, t323, t335, heap; // guardando el caracter 
+, t323, 1, t323; // incremnetnado la pos del arreglo
+, t334, 1, t334; // incrementando la pos de la cadena
=>, t334, t335, heap; // sacandor el caracter del heap cadena
jmp, , , L26;
jmp, , , L29;
L29:
jmp, , , L27;
L27:
// Asignando atributo edad
+, p, 0, t336; //pos this 
=>, t336, t337, stack; // apuntador al heap
=>, t337, t338, heap; // apuntador donde inicia el objeto
+, t338, 0, t339; // pos real  de edad
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t340; // pos de val
=>, t340, t341, stack; // valor de lo que trae en el stack val
<=, t339, t341, heap; //guardando en el heap el valor del atributo
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t342; // pos this 
=>, t342, t343, stack; // obtenido apuntador al heap 
=>, t343, t344, heap; // apuntador 
+, t344, 0, t345; // pos de edad
=>, t345, t346, heap; // obtengo el valor que se encuentre en el heap 
+, t346, 10, t347;
print("%d", t347);
// ----------- Instancia a un atributo --------------
+, p, 0, t348;// pos this de car
=>, t348, t349, stack; //apuntador del heap de car
=>, t349, t350, heap; //posicion real del heap donde inicia car
+, t350, 1, t351; //pos real del atributo car
<=, t351, h, heap; //guardando la pos real donde inicia el objeto car
+, h, 3, h; // reservando el espacio de memoria para el nuevo objeto car

// Guardando la referencia al this del objeto para la llamada al constructor car
+, p, 0, t352;
=>, t352, t353, stack; //apuntador al heap de car
=>, t353, t354, heap; //posicion real donde incia el objeto car
+, t354, 1, t355; // pos real donde incial el objeto car

+, p, 7, t356; // tamanho de la funcion actual persona_vacio_persona_entero_caracter
+, t356, 0, t357; // pos del this para la nueva instancia de car
<=, t357, t355, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 7, t358; // size de funcion actual
+, t358, 1, t359; //pos del parametro 1
<=, t359, 70, stack; // asignado al stack el parametro
+, p, 7, t360; // size de funcion actual
+, t360, 2, t361; //pos del parametro 2
<=, t361, 126, stack; // asignado al stack el parametro
+, p, 7, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter_entero;
-, p, 7, p; // regresando al ambito acutal

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t362; // pos de color
// Resolviendo un acceso para un atrinuto
+, P, 0, t363; 
=>, t363, t364, stack; // apuntador al heap
=>, t364, t365, heap;
+, t365, 1, t367; 
+, P, 2, t368;
+, t368, 0, t369;
<=, t369, t367, stack; // pasadon como refeenria el valor del this
+, P, 2, P;
call, , , carro_caracter_obtenerColor;
+, P, 1, t370;
=>, t370, t371, stack; // valor del return
-, P, 2, P;
=>, t370, t372, stack; // valor a retoranar del acceso
<=, t362, t372, stack; // asignando a color
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t373; // pos de color
=>, t373, t374, stack; // valor de lo que trae en el stack color
print("%c", t374);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t375; // pos de i
<=, t375, 0, stack; // asignando a i
// Resolviendo un repetur mientras
jmp, , ,L30; //regresando a la etiqueral del ciclo repetir- mientras
L30:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t376; // pos de i
=>, t376, t377, stack; // valor de lo que trae en el stack i
// Resolviendo un acceso para un atrinuto
+, P, 0, t378; 
=>, t378, t379, stack; // apuntador al heap
=>, t379, t380, heap;
+, t380, 2, t382; 
=>, t382, t383, heap; // recuperando pos incial del objeto
=>, t383, t384, heap; // obteneindio el size del arreglo 
jl, t377, t384, L31;
jmp, , , L32;
L31:

//------------- Asignancio posicion de un arreglo Atributo  nombre
+, P, 0, t386; // pos this del objeto 
=>, t386, t387, stack; // apunt del heap para le objeto
=>, t387, t388, heap; // apunt donde inicia el objeto
+, t388, 2, t385; // pos del arreglo dentro del heap 
=>, t385, t389, heap; // apuntador donde inicia el arreglo
=>, t389, t390, heap; // size del arreglo nombre
+, t389, 1, t391; //pos 0 del arreglo nombre
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t392; // pos de i
=>, t392, t393, stack; // valor de lo que trae en el stack i
// ----------- Calculo de iReal para el arreglo nombre
-, t393, 0, t394; //calculando el n real ()
-, t394, 0, t395; //iReal columna 0
+, t391, t395, t396; // pos buscade del arreglo atributo nombre
=>, t396, t397, heap; //valor que trae el objeto
print("%c", t397);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t398; // pos de i
=>, t398, t399, stack; //obtenidoe el valor de i
+, t399, 1, t400;
<=, t398, t400, stack; // asignando a i
jmp, , ,L30; //regresando a la etiqueral del ciclo repetir mientras
L32:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 5, t401; // pos de g
+, P, 0, t402;
=>, t402, t403, stack; 
+, P, 7, t404;
+, t403, 0, t405;
<=, t404, t403, stack; 
+, P, 7, P;
call, , , persona_caracter_obtenerChar;
+, P, 1, t406;
=>, t406, t407, stack; // valor del return
-, P, 7, P;
<=, t401, t407, stack; // asignando a g
// -------------- Resolviendo para un ID (var local) ------------
+, p, 5, t408; // pos de g
=>, t408, t409, stack; // valor de lo que trae en el stack g
print("%c", t409);
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t410; // pos this 
=>, t410, t411, stack; // obtenido apuntador al heap 
=>, t411, t412, heap; // apuntador 
+, t412, 0, t413; // pos de edad
=>, t413, t414, heap; // obtengo el valor que se encuentre en el heap 
*, 1024, 2, t415;
<=, t413, t415, HEAP; // asignando variable 
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t416; // pos this 
=>, t416, t417, stack; // obtenido apuntador al heap 
=>, t417, t418, heap; // apuntador 
+, t418, 0, t419; // pos de edad
=>, t419, t420, heap; // obtengo el valor que se encuentre en el heap 
=>, t419, t421, HEAP; //obtenidoe el valor la vairable 
*, t421, 3, t422;
<=, t419, t422, HEAP; // asignando vairble  
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t423; // pos this 
=>, t423, t424, stack; // obtenido apuntador al heap 
=>, t424, t425, heap; // apuntador 
+, t425, 0, t426; // pos de edad
=>, t426, t427, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t427);

L25:
end, , persona_vacio_persona_entero_caracter




begin, , , persona_caracter_obtenerChar

// RESOLVIENDO UN RETORNO
+, P, 1, t428; // pos de retorno de a funcion persona_caracter_obtenerChar
<=, t428, 75, stack; //asignando el retorno con su valor
jmp, , , L33;

L33:
end, , persona_caracter_obtenerChar




begin, , , persona_carro_retornoCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t429; // pos de c
<=, t429, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t430; // guardo la posicion donde inicia el objeto 
<=, h, t430, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t431; // pos de c
=>, t431, t432, stack; // obteniendo apuntador de c
+, p, 3, t433; // simulando cambio de ambito
+, t433, 0, t434; //pos del this de c
<=, t434, t432, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t435; // size de funcion actual
+, t435, 1, t436; //pos del parametro 1
<=, t436, 82, stack; // asignado al stack el parametro
+, 5, 5, t439;
*, t439, 2, t440;
+, p, 3, t437; // size de funcion actual
+, t437, 2, t438; //pos del parametro 2
<=, t438, t440, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter_entero;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t441; // pos de c
=>, t441, t442, stack; // valor de lo que trae en el stack c
+, P, 2, t443; // pos de retorno de a funcion persona_carro_retornoCarro
<=, t443, t442, stack; //asignando el retorno con su valor
jmp, , , L34;

L34:
end, , persona_carro_retornoCarro




begin, , , persona_entero_incrementarEdad

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t444; // pos this 
=>, t444, t445, stack; // obtenido apuntador al heap 
=>, t445, t446, heap; // apuntador 
+, t446, 0, t447; // pos de edad
=>, t447, t448, heap; // obtengo el valor que se encuentre en el heap 
+, t448, 1, t449;
+, P, 1, t450; // pos de retorno de a funcion persona_entero_incrementarEdad
<=, t450, t449, stack; //asignando el retorno con su valor
jmp, , , L35;

L35:
end, , persona_entero_incrementarEdad


