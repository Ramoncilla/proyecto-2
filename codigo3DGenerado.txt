

begin, , , persona_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t1; // pos de p
<=, t1, h, stack; //guardando referencia del heap para el objeto p
+, h, 1, t2; // guardo la posicion donde inicia el objeto 
<=, h, t2, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 1, h; // reservando espacio para el objeto p
//Ingresando referencia al this del objeto p
+, p, 0, t3; // pos de p
=>, t3, t4, stack; // obteniendo apuntador de p
+, p, 4, t5; // simulando cambio de ambito
+, t5, 0, t6; //pos del this de p
<=, t6, t4, stack; // insertando apuntador del heap al stack del obeto p
// No posee parametros 
+, p, 4, p; // simulando cambio de ambito
call, , , persona_vacio_persona;
-, p, 4, p; // regresando al ambito acutal

// ------------------------ Creando arreglo local nombreP
+, P, 1, t7; //pos de arreglo nombreP
<=, t7, H, stack; // ingrensando al stack apunt del heap para nombreP
+, H, 1, t8;
<=, H, t8, heap; //insetnado donde inicia el arreglo nombreP
+, H, 1, H;
// calculando el tamanho del arreglo
-, 6, 1, t9; //calculando el n real
-, t9, 0, t10; //iReal columna 0
-, 2, 1, t11; //calculando el n real
*, t10, 2, t12;// multiplicando por n1
+, t12, t11, t13;
-, t13, 0, t14; //i real de columna 1
+, t14, 1, t14; //size del arreglo nombreP
<=, H, t14, heap; // insertando el tamanio del arreglo linealizado nombreP
+, H, 1, H;
+, h, t14, h; // reservnado el espacio del arreglo nombreP
+, P, 1, t15; // pos de arreglo nombrep
=>, t15, t16, stack; // apunt al heap de arreglo nombrep
=>, t16, t17, heap; //apunt al heap donde inicia el arreglo nombrep
=>, t17, t18, heap; //obteniendo el tamanio del arreglo nombrep
+, t17, 1, t19; // pos 0 del arreglo nombrep
// ---- Calculo de valor de las posiciones  
// ----------- Calculo de iReal para el arreglo nombrep
-, 4, 0, t20; //calculando el n real ()
-, t20, 0, t21; //iReal columna 0
-, 1, 0, t22; //calculando el n real ()
*, t21, 2, t23;// multiplicando por n1
+, t23, t22, t24;
-, t24, 0, t25; //i real de columna 1
+, t19, t25, t26; // pos donde se va inicar a escribir el arreglo nombrep
<=, t26, 65, heap; // asignando al heap en la nueva posicion de arreglo nombrep
// ------------------------ Creando arreglo local n
+, P, 2, t27; //pos de arreglo n
<=, t27, H, stack; // ingrensando al stack apunt del heap para n
+, H, 1, t28;
<=, H, t28, heap; //insetnado donde inicia el arreglo n
+, H, 1, H;
// calculando el tamanho del arreglo
-, 10, 1, t29; //calculando el n real
-, t29, 0, t30; //iReal columna 0
+, t30, 1, t30; //size del arreglo n
<=, H, t30, heap; // insertando el tamanio del arreglo linealizado n
+, H, 1, H;
+, h, t30, h; // reservnado el espacio del arreglo n
+, P, 2, t31; // pos de arreglo n
=>, t31, t32, stack; // apunt al heap de arreglo n
=>, t32, t33, heap; //apunt al heap donde inicia el arreglo n
=>, t33, t34, heap; //obteniendo el tamanio del arreglo n
+, t33, 1, t35; // pos 0 del arreglo n
// ---- Calculo de valor de las posiciones  
// ----------- Calculo de iReal para el arreglo n
-, 0, 0, t36; //calculando el n real ()
-, t36, 0, t37; //iReal columna 0
+, t35, t37, t38; // pos donde se va inicar a escribir el arreglo n
<=, t38, 65, heap; // asignando al heap en la nueva posicion de arreglo n
+, P, 2, t39; // pos de arreglo n
=>, t39, t40, stack; // apunt al heap de arreglo n
=>, t40, t41, heap; //apunt al heap donde inicia el arreglo n
=>, t41, t42, heap; //obteniendo el tamanio del arreglo n
+, t41, 1, t43; // pos 0 del arreglo n
// ---- Calculo de valor de las posiciones  
// ----------- Calculo de iReal para el arreglo n
-, 1, 0, t44; //calculando el n real ()
-, t44, 0, t45; //iReal columna 0
+, t43, t45, t46; // pos donde se va inicar a escribir el arreglo n
<=, t46, 76, heap; // asignando al heap en la nueva posicion de arreglo n
+, P, 2, t47; // pos de arreglo n
=>, t47, t48, stack; // apunt al heap de arreglo n
=>, t48, t49, heap; //apunt al heap donde inicia el arreglo n
=>, t49, t50, heap; //obteniendo el tamanio del arreglo n
+, t49, 1, t51; // pos 0 del arreglo n
// ---- Calculo de valor de las posiciones  
*, 2, 1, t52;
// ----------- Calculo de iReal para el arreglo n
-, t52, 0, t53; //calculando el n real ()
-, t53, 0, t54; //iReal columna 0
+, t51, t54, t55; // pos donde se va inicar a escribir el arreglo n
<=, t55, 73, heap; // asignando al heap en la nueva posicion de arreglo n
+, P, 2, t56; // pos de arreglo n
=>, t56, t57, stack; // apunt al heap de arreglo n
=>, t57, t58, heap; //apunt al heap donde inicia el arreglo n
=>, t58, t59, heap; //obteniendo el tamanio del arreglo n
+, t58, 1, t60; // pos 0 del arreglo n
// ---- Calculo de valor de las posiciones  
+, 2, 1, t61;
// ----------- Calculo de iReal para el arreglo n
-, t61, 0, t62; //calculando el n real ()
-, t62, 0, t63; //iReal columna 0
+, t60, t63, t64; // pos donde se va inicar a escribir el arreglo n
<=, t64, 78, heap; // asignando al heap en la nueva posicion de arreglo n
+, P, 2, t65; // pos de arreglo n
=>, t65, t66, stack; // apunt al heap de arreglo n
=>, t66, t67, heap; //apunt al heap donde inicia el arreglo n
=>, t67, t68, heap; //obteniendo el tamanio del arreglo n
+, t67, 1, t69; // pos 0 del arreglo n
// ---- Calculo de valor de las posiciones  
*, 2, 2, t70;
// ----------- Calculo de iReal para el arreglo n
-, t70, 0, t71; //calculando el n real ()
-, t71, 0, t72; //iReal columna 0
+, t69, t72, t73; // pos donde se va inicar a escribir el arreglo n
<=, t73, 65, heap; // asignando al heap en la nueva posicion de arreglo n
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t74; // pos de i
<=, t74, 0, stack; // asignando a i
// Resolviendo un repetur mientras
jmp, , ,L1; //regresando a la etiqueral del ciclo repetir- mientras
L1:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t75; // pos de i
=>, t75, t76, stack; // valor de lo que trae en el stack i
jl, t76, 10, L2;
jmp, , , L3;
L2:

+, P, 2, t77; // pos de arreglo n
=>, t77, t78, stack; // apunt al heap de arreglo n
=>, t78, t79, heap; //apunt al heap donde inicia el arreglo n
=>, t79, t80, heap; //obteniendo el tamanio del arreglo n
+, t79, 1, t81; // pos 0 del arreglo n
// ---- Calculo de valor de las posiciones  
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t82; // pos de i
=>, t82, t83, stack; // valor de lo que trae en el stack i
// -----------(Obteniendo valor) Calculo de iReal para el arreglo n
-, t83, 0, t84; //calculando el n real ()
-, t84, 0, t85; //iReal columna 0
+, t81, t85, t86; // pos donde se va inicar a escribir el arreglo n
=>, t86, t87, heap; //valor que trae el objeto
print("%c", t87);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t88; // pos de i
=>, t88, t89, stack; //obtenidoe el valor de i
+, t89, 1, t90;
<=, t88, t90, stack; // asignando a i
jmp, , ,L1; //regresando a la etiqueral del ciclo repetir mientras
L3:


end, , persona_PRINCIPAL




begin, , , persona_vacio_persona

// ----------------------- Creando arreglo atributo valor
+, P, 0, t91; //pos this del arreglo
=>, t91, t92, stack; //obteniendo apuntador de arreglo en eel heap
=>, t92, t93, heap;//apuntando donde en verdad inicia el arreglo
+, t93, 0, t94; //pos del heap que guarda apuntador del heap para el arreglo valor
<=, t94, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 6, 1, t95; //calculando el n real
-, t95, 0, t96; //iReal columna 0
-, 2, 1, t97; //calculando el n real
*, t96, 2, t98;// multiplicando por n1
+, t98, t97, t99;
-, t99, 0, t100; //i real de columna 1
+, t100, 1, t100; //size del arreglo valor
<=, H, t100, heap; // insertando el tamanio del arreglo linealizado valor
+, H, 1, H;
+, t100, 0, t101; // anhadiendo una posicion mas
+, h, t101, h; // reservnado el espacio del arreglo valor
//------------- Asignancio posicion de un arreglo Atributo  valor
+, P, 0, t102; // pos this del objeto 
=>, t102, t103, stack; // apunt del heap para le objeto
=>, t103, t104, heap; // apunt donde inicia el objeto
+, t104, 0, t105; // pos del arreglo dentro del heap 
=>, t105, t106, heap; // apuntador donde inicia el arreglo
=>, t106, t107, heap; // size del arreglo valor
+, t106, 1, t108; //pos 0 del arreglo valor
// ----------- Calculo de iReal para el arreglo valor
-, 0, 0, t109; //calculando el n real ()
-, t109, 0, t110; //iReal columna 0
-, 0, 0, t111; //calculando el n real ()
*, t110, 2, t112;// multiplicando por n1
+, t112, t111, t113;
-, t113, 0, t114; //i real de columna 1
+, t108, t114, t115; // pos donde se va inicar a escribir el arreglo valor
<=, t115, 79, heap; // asignando al heap en la nueva posicion de arreglo valor
//------------- Asignancio posicion de un arreglo Atributo  valor
+, P, 0, t116; // pos this del objeto 
=>, t116, t117, stack; // apunt del heap para le objeto
=>, t117, t118, heap; // apunt donde inicia el objeto
+, t118, 0, t119; // pos del arreglo dentro del heap 
=>, t119, t120, heap; // apuntador donde inicia el arreglo
=>, t120, t121, heap; // size del arreglo valor
+, t120, 1, t122; //pos 0 del arreglo valor
// ----------- Calculo de iReal para el arreglo valor
-, 3, 0, t123; //calculando el n real ()
-, t123, 0, t124; //iReal columna 0
-, 1, 0, t125; //calculando el n real ()
*, t124, 2, t126;// multiplicando por n1
+, t126, t125, t127;
-, t127, 0, t128; //i real de columna 1
+, t122, t128, t129; // pos donde se va inicar a escribir el arreglo valor
<=, t129, 112, heap; // asignando al heap en la nueva posicion de arreglo valor

end, , persona_vacio_persona


