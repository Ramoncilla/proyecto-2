

begin, , , llanta_vacio_llanta_entero_entero

// Asignando atributo valor1Llanta
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de valor1Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de val1
=>, t5, t6, stack; // valor de lo que trae en el stack val1
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo valor2Llanta
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de valor2Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t11; // pos de val2
=>, t11, t12, stack; // valor de lo que trae en el stack val2
<=, t10, t12, heap; //guardando en el heap el valor del atributo

L1:
end, , llanta_vacio_llanta_entero_entero




begin, , , llanta_vacio_mostrarVAlor1

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t13; // pos this 
=>, t13, t14, stack; // obtenido apuntador al heap 
=>, t14, t15, heap; // apuntador 
+, t15, 0, t16; // pos de valor1Llanta
=>, t16, t17, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t17);

L2:
end, , llanta_vacio_mostrarVAlor1




begin, , , llanta_vacio_mostrarVAlor2

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t18; // pos this 
=>, t18, t19, stack; // obtenido apuntador al heap 
=>, t19, t20, heap; // apuntador 
+, t20, 1, t21; // pos de valor2Llanta
=>, t21, t22, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t22);

L3:
end, , llanta_vacio_mostrarVAlor2




begin, , , carro_vacio_carro_caracter_entero

// Asignando atributo col
+, p, 0, t23; //pos this 
=>, t23, t24, stack; // apuntador al heap
=>, t24, t25, heap; // apuntador donde inicia el objeto
+, t25, 0, t26; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t27; // pos de color
=>, t27, t28, stack; // valor de lo que trae en el stack color
<=, t26, t28, heap; //guardando en el heap el valor del atributo
print("%c", 89);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t29; // pos de rinLlanta
=>, t29, t30, stack; // valor de lo que trae en el stack rinLlanta
print("%d", t30);
// Asignando atributo valorCarro
+, p, 0, t31; //pos this 
=>, t31, t32, stack; // apuntador al heap
=>, t32, t33, heap; // apuntador donde inicia el objeto
+, t33, 2, t34; // pos real  de valorCarro
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t35; // pos de rinLlanta
=>, t35, t36, stack; // valor de lo que trae en el stack rinLlanta
<=, t34, t36, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t37;// pos this de lla1
=>, t37, t38, stack; //apuntador del heap de lla1
=>, t38, t39, heap; //posicion real del heap donde inicia lla1
+, t39, 1, t40; //pos real del atributo lla1
<=, t40, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t41;
=>, t41, t42, stack; //apuntador al heap de lla1
=>, t42, t43, heap; //posicion real donde incia el objeto lla1
+, t43, 1, t44; // pos real donde incial el objeto lla1

+, p, 4, t45; // tamanho de la funcion actual carro_vacio_carro_caracter_entero
+, t45, 0, t46; // pos del this para la nueva instancia de lla1
<=, t46, t44, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 4, t47; // size de funcion actual
+, t47, 1, t48; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t49; // pos de rinLlanta
=>, t49, t50, stack; // valor de lo que trae en el stack rinLlanta
*, t50, 2, t51;
<=, t48, t51, stack; // asignado al stack el parametro
+, p, 4, t52; // size de funcion actual
+, t52, 2, t53; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t54; // pos de rinLlanta
=>, t54, t55, stack; // valor de lo que trae en el stack rinLlanta
*, t55, 3, t56;
<=, t53, t56, stack; // asignado al stack el parametro
+, p, 4, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 4, p; // regresando al ambito acutal


L4:
end, , carro_vacio_carro_caracter_entero




begin, , , carro_vacio_carro_caracter

// Asignando atributo col
+, p, 0, t57; //pos this 
=>, t57, t58, stack; // apuntador al heap
=>, t58, t59, heap; // apuntador donde inicia el objeto
+, t59, 0, t60; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t61; // pos de n
=>, t61, t62, stack; // valor de lo que trae en el stack n
<=, t60, t62, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t63;// pos this de lla1
=>, t63, t64, stack; //apuntador del heap de lla1
=>, t64, t65, heap; //posicion real del heap donde inicia lla1
+, t65, 1, t66; //pos real del atributo lla1
<=, t66, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t67;
=>, t67, t68, stack; //apuntador al heap de lla1
=>, t68, t69, heap; //posicion real donde incia el objeto lla1
+, t69, 1, t70; // pos real donde incial el objeto lla1

+, p, 3, t71; // tamanho de la funcion actual carro_vacio_carro_caracter
+, t71, 0, t72; // pos del this para la nueva instancia de lla1
<=, t72, t70, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 3, t73; // size de funcion actual
+, t73, 1, t74; //pos del parametro 1
<=, t74, 10, stack; // asignado al stack el parametro
+, p, 3, t75; // size de funcion actual
+, t75, 2, t76; //pos del parametro 2
<=, t76, 20, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 3, p; // regresando al ambito acutal


L5:
end, , carro_vacio_carro_caracter




begin, , , carro_caracter_obtenerColor

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t77; // pos this 
=>, t77, t78, stack; // obtenido apuntador al heap 
=>, t78, t79, heap; // apuntador 
+, t79, 0, t80; // pos de col
=>, t80, t81, heap; // obtengo el valor que se encuentre en el heap 
+, P, 1, t82; // pos de retorno de a funcion carro_caracter_obtenerColor
<=, t82, t81, stack; //asignando el retorno con su valor
jmp, , , L6;

L6:
end, , carro_caracter_obtenerColor




begin, , , carro_vacio_imprimir_Color

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t83; // pos this 
=>, t83, t84, stack; // obtenido apuntador al heap 
=>, t84, t85, heap; // apuntador 
+, t85, 0, t86; // pos de col
=>, t86, t87, heap; // obtengo el valor que se encuentre en el heap 
print("%c", t87);

L7:
end, , carro_vacio_imprimir_Color




begin, , , persona_PRINCIPAL

// ------------------------ Creando arreglo local nombre
+, P, 0, t88; //pos de arreglo nombre
<=, t88, H, stack; // ingrensando al stack apunt del heap para nombre
+, H, 1, t89;
<=, H, t89, heap; //insetnado donde inicia el arreglo nombre
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t90; //calculando el n real
-, t90, 0, t91; //iReal columna 0
+, t91, 1, t91; //size del arreglo nombre
<=, H, t91, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, h, t91, h; // reservnado el espacio del arreglo nombre
+, P, 0, t94; // pos del arreglo 
=>, t94, t95, stack; //apuntador al heap del arreglo
=>, t95, t96, heap; // apuntador del heap al heap donde inicia la cadena
=>, t96, t92, heap; // size del arreglo nombre
+, t96, 1, t93; // pos 0 donde inicia el arreglo nombre
// Resolviendo una cadena 
+, H, 0, t97; //apuntaodr a cadena 
+, H, 1, t98; //apu donde inicia la cadena
<=, t97, t98, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 10, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t99; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t97, t100, heap; // pos que apunta al size de la cadena
=>, t100, t101, heap; // size de la cadena
+, t100, 1, t102; // Pos 0 de la cadena
=>, t102, t103, heap; // sacandor el caracter del heap cadena
jle, t101, t92, L9;
jmp, , , L10;
jmp, , , L9;
L9:
jne, t103, 34, L11;
jmp, , , L12;
jmp, , , L11;
L11:
<=, t93, t103, heap; // guardando el caracter 
+, t93, 1, t93; // incremnetnado la pos del arreglo
+, t102, 1, t102; // incrementando la pos de la cadena
=>, t102, t103, heap; // sacandor el caracter del heap cadena
jmp, , , L9;
jmp, , , L12;
L12:
jmp, , , L10;
L10:
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t104; // pos de i
<=, t104, 0, stack; // asignando a i
// ---------- Resolver Hacer Mientras ----------- 
L13:
+, P, 0, t105; // pos de arreglo nombre
=>, t105, t106, stack; // apunt al heap de arreglo nombre
=>, t106, t107, heap; //apunt al heap donde inicia el arreglo nombre
=>, t107, t108, heap; //obteniendo el tamanio del arreglo nombre
+, t107, 1, t109; // pos 0 del arreglo nombre
// ---- Calculo de valor de las posiciones  
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t110; // pos de i
=>, t110, t111, stack; // valor de lo que trae en el stack i
// -----------(Obteniendo valor) Calculo de iReal para el arreglo nombre
-, t111, 0, t112; //calculando el n real ()
-, t112, 0, t113; //iReal columna 0
+, t109, t113, t114; // pos buscada del arreglo  nombre
=>, t114, t115, heap; //valor que trae el objeto
print("%c", t115);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t116; // pos de i
=>, t116, t117, stack; //obtenidoe el valor de i
+, t117, 1, t118;
<=, t116, t118, stack; // asignando a i
L15: //etiqueta del conituar
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t119; // pos de i
=>, t119, t120, stack; // valor de lo que trae en el stack i
// ----------------- Resolviendo acceso local 
+, P, 0, t121; // pos del objeto
=>, t121, t123, stack; //apuntador al heap del obejto
=>, t123, t124, heap; // recuperando pos incial del objeto
=>, t124, t125, heap; // obteneindio el size del arreglo 
jl, t120, t125, L16;
jmp, , , L17;
L16:

jmp, , , L13;
L17:

L14:

L8:
end, , persona_PRINCIPAL




begin, , , persona_vacio_molestar

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t126; // pos this 
=>, t126, t127, stack; // obtenido apuntador al heap 
=>, t127, t128, heap; // apuntador 
+, t128, 0, t129; // pos de edad
=>, t129, t130, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t130);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t131; // pos de a
<=, t131, 189, stack; // asignando a a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t132; // pos de a
=>, t132, t133, stack; // valor de lo que trae en el stack a
print("%d", t133);
// RESOLVIENDO UN RETORNO
jmp, , , L18;
print("%c", 84);

L18:
end, , persona_vacio_molestar




begin, , , persona_carro_obtenerCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t134; // pos de c
<=, t134, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t135; // guardo la posicion donde inicia el objeto 
<=, h, t135, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t136; // pos de c
=>, t136, t137, stack; // obteniendo apuntador de c
+, p, 3, t138; // simulando cambio de ambito
+, t138, 0, t139; //pos del this de c
<=, t139, t137, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t140; // size de funcion actual
+, t140, 1, t141; //pos del parametro 1
<=, t141, 72, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t142; // pos de c
=>, t142, t143, stack; // valor de lo que trae en el stack c
+, P, 2, t144; // pos de retorno de a funcion persona_carro_obtenerCarro
<=, t144, t143, stack; //asignando el retorno con su valor
jmp, , , L19;

L19:
end, , persona_carro_obtenerCarro




begin, , , persona_entero_obtenernUmero

// RESOLVIENDO UN RETORNO
*, 5, 8, t145;
+, P, 1, t146; // pos de retorno de a funcion persona_entero_obtenernUmero
<=, t146, t145, stack; //asignando el retorno con su valor
jmp, , , L20;

L20:
end, , persona_entero_obtenernUmero




begin, , , persona_vacio_persona_entero_caracter

// Asignando atributo edad
+, p, 0, t147; //pos this 
=>, t147, t148, stack; // apuntador al heap
=>, t148, t149, heap; // apuntador donde inicia el objeto
+, t149, 0, t150; // pos real  de edad
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t151; // pos de val
=>, t151, t152, stack; // valor de lo que trae en el stack val
<=, t150, t152, heap; //guardando en el heap el valor del atributo

L21:
end, , persona_vacio_persona_entero_caracter




begin, , , persona_caracter_obtenerChar

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t153; // pos de c
<=, t153, 85, stack; // asignando a c
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t154; // pos de c
=>, t154, t155, stack; // valor de lo que trae en el stack c
print("%c", t155);
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t156; // pos de c
=>, t156, t157, stack; // valor de lo que trae en el stack c
+, P, 2, t158; // pos de retorno de a funcion persona_caracter_obtenerChar
<=, t158, t157, stack; //asignando el retorno con su valor
jmp, , , L22;
print("%c", 65);
print("%c", 65);

L22:
end, , persona_caracter_obtenerChar


