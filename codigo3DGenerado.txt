

begin, , , llanta_vacio_llanta_entero_entero

// Asignando atributo valor1Llanta
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de valor1Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de val1
=>, t5, t6, stack; // valor de lo que trae en el stack val1
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo valor2Llanta
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de valor2Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t11; // pos de val2
=>, t11, t12, stack; // valor de lo que trae en el stack val2
<=, t10, t12, heap; //guardando en el heap el valor del atributo

L1:
end, , llanta_vacio_llanta_entero_entero




begin, , , llanta_vacio_mostrarVAlor1

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t13; // pos this 
=>, t13, t14, stack; // obtenido apuntador al heap 
=>, t14, t15, heap; // apuntador 
+, t15, 0, t16; // pos de valor1Llanta
=>, t16, t17, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t17);

L2:
end, , llanta_vacio_mostrarVAlor1




begin, , , llanta_vacio_mostrarVAlor2

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t18; // pos this 
=>, t18, t19, stack; // obtenido apuntador al heap 
=>, t19, t20, heap; // apuntador 
+, t20, 1, t21; // pos de valor2Llanta
=>, t21, t22, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t22);

L3:
end, , llanta_vacio_mostrarVAlor2




begin, , , carro_vacio_carro_caracter_entero

// Asignando atributo col
+, p, 0, t23; //pos this 
=>, t23, t24, stack; // apuntador al heap
=>, t24, t25, heap; // apuntador donde inicia el objeto
+, t25, 0, t26; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t27; // pos de color
=>, t27, t28, stack; // valor de lo que trae en el stack color
<=, t26, t28, heap; //guardando en el heap el valor del atributo
print("%c", 89);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t29; // pos de rinLlanta
=>, t29, t30, stack; // valor de lo que trae en el stack rinLlanta
print("%d", t30);
// Asignando atributo valorCarro
+, p, 0, t31; //pos this 
=>, t31, t32, stack; // apuntador al heap
=>, t32, t33, heap; // apuntador donde inicia el objeto
+, t33, 2, t34; // pos real  de valorCarro
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t35; // pos de rinLlanta
=>, t35, t36, stack; // valor de lo que trae en el stack rinLlanta
<=, t34, t36, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t37;// pos this de lla1
=>, t37, t38, stack; //apuntador del heap de lla1
=>, t38, t39, heap; //posicion real del heap donde inicia lla1
+, t39, 1, t40; //pos real del atributo lla1
<=, t40, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t41;
=>, t41, t42, stack; //apuntador al heap de lla1
=>, t42, t43, heap; //posicion real donde incia el objeto lla1
+, t43, 1, t44; // pos real donde incial el objeto lla1

+, p, 4, t45; // tamanho de la funcion actual carro_vacio_carro_caracter_entero
+, t45, 0, t46; // pos del this para la nueva instancia de lla1
<=, t46, t44, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 4, t47; // size de funcion actual
+, t47, 1, t48; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t49; // pos de rinLlanta
=>, t49, t50, stack; // valor de lo que trae en el stack rinLlanta
*, t50, 2, t51;
<=, t48, t51, stack; // asignado al stack el parametro
+, p, 4, t52; // size de funcion actual
+, t52, 2, t53; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t54; // pos de rinLlanta
=>, t54, t55, stack; // valor de lo que trae en el stack rinLlanta
*, t55, 3, t56;
<=, t53, t56, stack; // asignado al stack el parametro
+, p, 4, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 4, p; // regresando al ambito acutal


L4:
end, , carro_vacio_carro_caracter_entero




begin, , , carro_entero_obtenerValor

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t57; // pos this 
=>, t57, t58, stack; // obtenido apuntador al heap 
=>, t58, t59, heap; // apuntador 
+, t59, 2, t60; // pos de valorCarro
=>, t60, t61, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t61);
print("%c", 76);
// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t62; // pos this 
=>, t62, t63, stack; // obtenido apuntador al heap 
=>, t63, t64, heap; // apuntador 
+, t64, 2, t65; // pos de valorCarro
=>, t65, t66, heap; // obtengo el valor que se encuentre en el heap 
*, t66, 5, t67;
+, P, 1, t68; // pos de retorno de a funcion carro_entero_obtenerValor
<=, t68, t67, stack; //asignando el retorno con su valor
jmp, , , L5;

L5:
end, , carro_entero_obtenerValor




begin, , , carro_vacio_carro_caracter

// Asignando atributo col
+, p, 0, t69; //pos this 
=>, t69, t70, stack; // apuntador al heap
=>, t70, t71, heap; // apuntador donde inicia el objeto
+, t71, 0, t72; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t73; // pos de n
=>, t73, t74, stack; // valor de lo que trae en el stack n
<=, t72, t74, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t75;// pos this de lla1
=>, t75, t76, stack; //apuntador del heap de lla1
=>, t76, t77, heap; //posicion real del heap donde inicia lla1
+, t77, 1, t78; //pos real del atributo lla1
<=, t78, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t79;
=>, t79, t80, stack; //apuntador al heap de lla1
=>, t80, t81, heap; //posicion real donde incia el objeto lla1
+, t81, 1, t82; // pos real donde incial el objeto lla1

+, p, 3, t83; // tamanho de la funcion actual carro_vacio_carro_caracter
+, t83, 0, t84; // pos del this para la nueva instancia de lla1
<=, t84, t82, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 3, t85; // size de funcion actual
+, t85, 1, t86; //pos del parametro 1
<=, t86, 10, stack; // asignado al stack el parametro
+, p, 3, t87; // size de funcion actual
+, t87, 2, t88; //pos del parametro 2
<=, t88, 20, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 3, p; // regresando al ambito acutal


L6:
end, , carro_vacio_carro_caracter




begin, , , carro_caracter_obtenerColor

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t89; // pos this 
=>, t89, t90, stack; // obtenido apuntador al heap 
=>, t90, t91, heap; // apuntador 
+, t91, 0, t92; // pos de col
=>, t92, t93, heap; // obtengo el valor que se encuentre en el heap 
+, P, 1, t94; // pos de retorno de a funcion carro_caracter_obtenerColor
<=, t94, t93, stack; //asignando el retorno con su valor
jmp, , , L7;

L7:
end, , carro_caracter_obtenerColor




begin, , , carro_vacio_imprimir_Color

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t95; // pos this 
=>, t95, t96, stack; // obtenido apuntador al heap 
=>, t96, t97, heap; // apuntador 
+, t97, 0, t98; // pos de col
=>, t98, t99, heap; // obtengo el valor que se encuentre en el heap 
print("%c", t99);

L8:
end, , carro_vacio_imprimir_Color




begin, , , persona_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t100; // pos de p1
<=, t100, h, stack; //guardando referencia del heap para el objeto p1
+, h, 1, t101; // guardo la posicion donde inicia el objeto 
<=, h, t101, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 2, h; // reservando espacio para el objeto p1
//Ingresando referencia al this del objeto p1
+, p, 0, t102; // pos de p1
=>, t102, t103, stack; // obteniendo apuntador de p1
+, p, 2, t104; // simulando cambio de ambito
+, t104, 0, t105; //pos del this de p1
<=, t105, t103, stack; // insertando apuntador del heap al stack del obeto p1
// Asignando parametros  
+, p, 2, t106; // size de funcion actual
+, t106, 1, t107; //pos del parametro 1
<=, t107, 25, stack; // asignado al stack el parametro
+, p, 2, t108; // size de funcion actual
+, t108, 2, t109; //pos del parametro 2
<=, t109, 80, stack; // asignado al stack el parametro
+, p, 2, p; // simulando cambio de ambito
call, , , persona_vacio_persona_entero_caracter;
-, p, 2, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t110; // pos del objeto
=>, t110, t112, stack; //apuntador al heap del obejto
+, P, 2, t113;
+, t113, 0, t114;
<=, t114, t112, stack; // pasadon como refeenria el valor del this
+, P, 2, P;
call, , , persona_entero_incrementarEdad;
+, P, 1, t115;
=>, t115, t116, stack; // valor del return
-, P, 2, P;
=>, t115, t117, stack; // valor a retoranar del acceso
print("%d", t117);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t118; // pos de valor1
// ----------------- Resolviendo acceso local 
+, P, 0, t119; // pos del objeto
=>, t119, t121, stack; //apuntador al heap del obejto
+, P, 3, t122;
+, t122, 0, t123;
<=, t123, t121, stack; // pasadon como refeenria el valor del this
+, P, 3, P;
call, , , persona_carro_retornoCarro;
+, P, 2, t124;
=>, t124, t125, stack; // valor del return
-, P, 3, P;
=>, t124, t126, stack; // recuperando pos incial del objeto
=>, t126, t126, heap; // apuntador inciail del objeto 
+, t126, 2, t124;
=>, t124, t127, heap; // valor a retoranar del acceso
<=, t118, t127, stack; // asignando a valor1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t128; // pos de valor1
=>, t128, t129, stack; // valor de lo que trae en el stack valor1
print("%d", t129);

L9:
end, , persona_PRINCIPAL




begin, , , persona_vacio_molestar

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t130; // pos this 
=>, t130, t131, stack; // obtenido apuntador al heap 
=>, t131, t132, heap; // apuntador 
+, t132, 0, t133; // pos de edad
=>, t133, t134, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t134);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t135; // pos de a
<=, t135, 189, stack; // asignando a a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t136; // pos de a
=>, t136, t137, stack; // valor de lo que trae en el stack a
print("%d", t137);
// RESOLVIENDO UN RETORNO
jmp, , , L10;
print("%c", 84);

L10:
end, , persona_vacio_molestar




begin, , , persona_carro_obtenerCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t138; // pos de c
<=, t138, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t139; // guardo la posicion donde inicia el objeto 
<=, h, t139, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t140; // pos de c
=>, t140, t141, stack; // obteniendo apuntador de c
+, p, 3, t142; // simulando cambio de ambito
+, t142, 0, t143; //pos del this de c
<=, t143, t141, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t144; // size de funcion actual
+, t144, 1, t145; //pos del parametro 1
<=, t145, 72, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t146; // pos de c
=>, t146, t147, stack; // valor de lo que trae en el stack c
+, P, 2, t148; // pos de retorno de a funcion persona_carro_obtenerCarro
<=, t148, t147, stack; //asignando el retorno con su valor
jmp, , , L11;

L11:
end, , persona_carro_obtenerCarro




begin, , , persona_entero_obtenernUmero

// RESOLVIENDO UN RETORNO
*, 5, 8, t149;
+, P, 1, t150; // pos de retorno de a funcion persona_entero_obtenernUmero
<=, t150, t149, stack; //asignando el retorno con su valor
jmp, , , L12;

L12:
end, , persona_entero_obtenernUmero




begin, , , persona_vacio_persona_entero_caracter

// Asignando atributo edad
+, p, 0, t151; //pos this 
=>, t151, t152, stack; // apuntador al heap
=>, t152, t153, heap; // apuntador donde inicia el objeto
+, t153, 0, t154; // pos real  de edad
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t155; // pos de val
=>, t155, t156, stack; // valor de lo que trae en el stack val
<=, t154, t156, heap; //guardando en el heap el valor del atributo

L13:
end, , persona_vacio_persona_entero_caracter




begin, , , persona_caracter_obtenerChar


L14:
end, , persona_caracter_obtenerChar




begin, , , persona_carro_retornoCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t157; // pos de c
<=, t157, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t158; // guardo la posicion donde inicia el objeto 
<=, h, t158, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t159; // pos de c
=>, t159, t160, stack; // obteniendo apuntador de c
+, p, 3, t161; // simulando cambio de ambito
+, t161, 0, t162; //pos del this de c
<=, t162, t160, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t163; // size de funcion actual
+, t163, 1, t164; //pos del parametro 1
<=, t164, 82, stack; // asignado al stack el parametro
+, 5, 5, t167;
*, t167, 2, t168;
+, p, 3, t165; // size de funcion actual
+, t165, 2, t166; //pos del parametro 2
<=, t166, t168, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter_entero;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t169; // pos de c
=>, t169, t170, stack; // valor de lo que trae en el stack c
+, P, 2, t171; // pos de retorno de a funcion persona_carro_retornoCarro
<=, t171, t170, stack; //asignando el retorno con su valor
jmp, , , L15;

L15:
end, , persona_carro_retornoCarro




begin, , , persona_entero_incrementarEdad

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t172; // pos this 
=>, t172, t173, stack; // obtenido apuntador al heap 
=>, t173, t174, heap; // apuntador 
+, t174, 0, t175; // pos de edad
=>, t175, t176, heap; // obtengo el valor que se encuentre en el heap 
+, t176, 1, t177;
+, P, 1, t178; // pos de retorno de a funcion persona_entero_incrementarEdad
<=, t178, t177, stack; //asignando el retorno con su valor
jmp, , , L16;

L16:
end, , persona_entero_incrementarEdad


