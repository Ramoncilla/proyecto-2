

begin, , , Node_vacio_Node_entero

// Asignando atributo key
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de key
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de d
=>, t5, t6, stack; // valor de lo que trae en el stack d
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo height
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de height
<=, t10, 1, heap; //guardando en el heap el valor del atributo

L1:
end, , Node_vacio_Node_entero




begin, , , Avl_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t11; // pos de arbol
<=, t11, h, stack; //guardando referencia del heap para el objeto arbol
+, h, 1, t12; // guardo la posicion donde inicia el objeto 
<=, h, t12, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 1, h; // reservando espacio para el objeto arbol
//Ingresando referencia al this del objeto arbol
+, p, 0, t13; // pos de arbol
=>, t13, t14, stack; // obteniendo apuntador de arbol
+, p, 2, t15; // simulando cambio de ambito
+, t15, 0, t16; //pos del this de arbol
<=, t16, t14, stack; // insertando apuntador del heap al stack del obeto arbol
// No posee parametros 
+, p, 2, p; // simulando cambio de ambito
call, , , Tree_vacio_tree;
-, p, 2, p; // regresando al ambito acutal

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t17; // pos de n
// ----------------- Resolviendo acceso local 
+, P, 0, t18; // pos del objeto
=>, t18, t20, stack; //apuntador al heap del obejto
+, P, 6, t21;
+, t21, 0, t22;
<=, t22, t20, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 6, t23; // size de funcion actual
+, t23, 1, t24; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 0, t25; // pos del objeto
=>, t25, t27, stack; //apuntador al heap del obejto
=>, t27, t28, heap; // recuperando pos incial del objeto
+, t28, 0, t27;
=>, t27, t29, heap; // valor a retoranar del acceso
<=, t24, t29, stack; // asignado al stack el parametro
+, p, 6, t30; // size de funcion actual
+, t30, 2, t31; //pos del parametro 2
<=, t31, 10, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero; 
+, P, 5, t32;
=>, t32, t33, stack; // valor del return
-, P, 6, P;
=>, t32, t34, stack; // valor a retoranar del acceso
<=, t17, t34, stack; // asignando a n
print("%d", 4);
// ----------------- Resolviendo acceso local 
+, P, 0, t35; // pos del objeto
=>, t35, t37, stack; //apuntador al heap del obejto
=>, t37, t38, heap; // recuperando pos incial del objeto
+, t38, 0, t37;
=>, t37, t39, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t40; // pos de n
=>, t40, t41, stack; // valor de lo que trae en el stack n
<=, t37, t41, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 0, t42; // pos del objeto
=>, t42, t44, stack; //apuntador al heap del obejto
=>, t44, t45, heap; // recuperando pos incial del objeto
+, t45, 0, t44;
=>, t44, t46, heap; // recuperando pos incial del objeto
+, t46, 0, t44;
=>, t44, t47, heap; // valor a retoranar del acceso
print("%d", t47);
// ----------------- Resolviendo acceso local 
+, P, 0, t48; // pos del objeto
=>, t48, t50, stack; //apuntador al heap del obejto
=>, t50, t51, heap; // recuperando pos incial del objeto
+, t51, 0, t50;
=>, t50, t52, heap; // recuperando pos incial del objeto
+, t52, 1, t50;
=>, t50, t53, heap; // valor a retoranar del acceso
print("%d", t53);
print("%d", 2);

L2:
end, , Avl_PRINCIPAL




begin, , , Tree_vacio_tree


L3:
end, , Tree_vacio_tree




begin, , , Tree_entero_height_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t54; // pos de N
=>, t54, t55, stack; // valor de lo que trae en el stack N
je, t55, 36, L6;
jmp, , , L7;
L6:

// RESOLVIENDO UN RETORNO
+, P, 2, t56; // pos de retorno de a funcion Tree_entero_height_Node
<=, t56, 0, stack; //asignando el retorno con su valor
jmp, , , L4;
jmp, , , L5; // salida del if
L7:

L5:
// RESOLVIENDO UN RETORNO
// ----------------- Resolviendo acceso local 
+, P, 1, t57; // pos del objeto
=>, t57, t59, stack; //apuntador al heap del obejto
=>, t59, t60, heap; // recuperando pos incial del objeto
+, t60, 1, t59;
=>, t59, t61, heap; // valor a retoranar del acceso
+, P, 2, t62; // pos de retorno de a funcion Tree_entero_height_Node
<=, t62, t61, stack; //asignando el retorno con su valor
jmp, , , L4;

L4:
end, , Tree_entero_height_Node




begin, , , Tree_entero_max_entero_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t63; // pos de a
=>, t63, t64, stack; // valor de lo que trae en el stack a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t65; // pos de b
=>, t65, t66, stack; // valor de lo que trae en el stack b
jg, t64, t66, L10;
jmp, , , L11;
L10:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t67; // pos de a
=>, t67, t68, stack; // valor de lo que trae en el stack a
+, P, 3, t69; // pos de retorno de a funcion Tree_entero_max_entero_entero
<=, t69, t68, stack; //asignando el retorno con su valor
jmp, , , L8;
jmp, , , L9; // salida del if
L11:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t70; // pos de b
=>, t70, t71, stack; // valor de lo que trae en el stack b
+, P, 3, t72; // pos de retorno de a funcion Tree_entero_max_entero_entero
<=, t72, t71, stack; //asignando el retorno con su valor
jmp, , , L8;
L9:

L8:
end, , Tree_entero_max_entero_entero




begin, , , Tree_Node_rightRotate_Node

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t73; // pos de x
// ----------------- Resolviendo acceso local 
+, P, 1, t74; // pos del objeto
=>, t74, t76, stack; //apuntador al heap del obejto
=>, t76, t77, heap; // recuperando pos incial del objeto
+, t77, 2, t76;
=>, t76, t78, heap; // valor a retoranar del acceso
<=, t73, t78, stack; // asignando a x
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t79; // pos de T2
// ----------------- Resolviendo acceso local 
+, P, 2, t80; // pos del objeto
=>, t80, t82, stack; //apuntador al heap del obejto
=>, t82, t83, heap; // recuperando pos incial del objeto
+, t83, 3, t82;
=>, t82, t84, heap; // valor a retoranar del acceso
<=, t79, t84, stack; // asignando a T2
// ----------------- Resolviendo acceso local 
+, P, 2, t85; // pos del objeto
=>, t85, t87, stack; //apuntador al heap del obejto
=>, t87, t88, heap; // recuperando pos incial del objeto
+, t88, 3, t87;
=>, t87, t89, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t90; // pos de y
=>, t90, t91, stack; // valor de lo que trae en el stack y
<=, t87, t91, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t92; // pos del objeto
=>, t92, t94, stack; //apuntador al heap del obejto
=>, t94, t95, heap; // recuperando pos incial del objeto
+, t95, 2, t94;
=>, t94, t96, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t97; // pos de T2
=>, t97, t98, stack; // valor de lo que trae en el stack T2
<=, t94, t98, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t99; // pos del objeto
=>, t99, t101, stack; //apuntador al heap del obejto
=>, t101, t102, heap; // recuperando pos incial del objeto
+, t102, 1, t101;
=>, t101, t103, heap; // valor a retoranar del acceso
+, P, 0, t104;
=>, t104, t105, stack; 
+, P, 5, t106;
+, t105, 0, t107;
<=, t106, t105, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t108; // size de funcion actual
+, t108, 1, t109; //pos del parametro 1
+, P, 0, t110;
=>, t110, t111, stack; 
+, P, 5, t112;
+, t111, 0, t113;
<=, t112, t111, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t114; // size de funcion actual
+, t114, 1, t115; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t116; // pos del objeto
=>, t116, t118, stack; //apuntador al heap del obejto
=>, t118, t119, heap; // recuperando pos incial del objeto
+, t119, 2, t118;
=>, t118, t120, heap; // valor a retoranar del acceso
<=, t115, t120, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t121;
=>, t121, t122, stack; // valor del return
-, P, 5, P;
<=, t109, t122, stack; // asignado al stack el parametro
+, p, 5, t123; // size de funcion actual
+, t123, 2, t124; //pos del parametro 2
+, P, 0, t125;
=>, t125, t126, stack; 
+, P, 5, t127;
+, t126, 0, t128;
<=, t127, t126, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t129; // size de funcion actual
+, t129, 1, t130; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t131; // pos del objeto
=>, t131, t133, stack; //apuntador al heap del obejto
=>, t133, t134, heap; // recuperando pos incial del objeto
+, t134, 3, t133;
=>, t133, t135, heap; // valor a retoranar del acceso
<=, t130, t135, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t136;
=>, t136, t137, stack; // valor del return
-, P, 5, P;
<=, t124, t137, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t138;
=>, t138, t139, stack; // valor del return
-, P, 5, P;
+, t139, 1, t140;
<=, t101, t140, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 2, t141; // pos del objeto
=>, t141, t143, stack; //apuntador al heap del obejto
=>, t143, t144, heap; // recuperando pos incial del objeto
+, t144, 1, t143;
=>, t143, t145, heap; // valor a retoranar del acceso
+, P, 0, t146;
=>, t146, t147, stack; 
+, P, 5, t148;
+, t147, 0, t149;
<=, t148, t147, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t150; // size de funcion actual
+, t150, 1, t151; //pos del parametro 1
+, P, 0, t152;
=>, t152, t153, stack; 
+, P, 5, t154;
+, t153, 0, t155;
<=, t154, t153, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t156; // size de funcion actual
+, t156, 1, t157; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t158; // pos del objeto
=>, t158, t160, stack; //apuntador al heap del obejto
=>, t160, t161, heap; // recuperando pos incial del objeto
+, t161, 2, t160;
=>, t160, t162, heap; // valor a retoranar del acceso
<=, t157, t162, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t163;
=>, t163, t164, stack; // valor del return
-, P, 5, P;
<=, t151, t164, stack; // asignado al stack el parametro
+, p, 5, t165; // size de funcion actual
+, t165, 2, t166; //pos del parametro 2
+, P, 0, t167;
=>, t167, t168, stack; 
+, P, 5, t169;
+, t168, 0, t170;
<=, t169, t168, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t171; // size de funcion actual
+, t171, 1, t172; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t173; // pos del objeto
=>, t173, t175, stack; //apuntador al heap del obejto
=>, t175, t176, heap; // recuperando pos incial del objeto
+, t176, 3, t175;
=>, t175, t177, heap; // valor a retoranar del acceso
<=, t172, t177, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t178;
=>, t178, t179, stack; // valor del return
-, P, 5, P;
<=, t166, t179, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t180;
=>, t180, t181, stack; // valor del return
-, P, 5, P;
+, t181, 1, t182;
<=, t143, t182, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t183; // pos de x
=>, t183, t184, stack; // valor de lo que trae en el stack x
+, P, 4, t185; // pos de retorno de a funcion Tree_Node_rightRotate_Node
<=, t185, t184, stack; //asignando el retorno con su valor
jmp, , , L12;

L12:
end, , Tree_Node_rightRotate_Node




begin, , , Tree_Node_leftRotate_Node

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t186; // pos de y
// ----------------- Resolviendo acceso local 
+, P, 1, t187; // pos del objeto
=>, t187, t189, stack; //apuntador al heap del obejto
=>, t189, t190, heap; // recuperando pos incial del objeto
+, t190, 3, t189;
=>, t189, t191, heap; // valor a retoranar del acceso
<=, t186, t191, stack; // asignando a y
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t192; // pos de T2
// ----------------- Resolviendo acceso local 
+, P, 2, t193; // pos del objeto
=>, t193, t195, stack; //apuntador al heap del obejto
=>, t195, t196, heap; // recuperando pos incial del objeto
+, t196, 2, t195;
=>, t195, t197, heap; // valor a retoranar del acceso
<=, t192, t197, stack; // asignando a T2
// ----------------- Resolviendo acceso local 
+, P, 2, t198; // pos del objeto
=>, t198, t200, stack; //apuntador al heap del obejto
=>, t200, t201, heap; // recuperando pos incial del objeto
+, t201, 2, t200;
=>, t200, t202, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t203; // pos de x
=>, t203, t204, stack; // valor de lo que trae en el stack x
<=, t200, t204, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t205; // pos del objeto
=>, t205, t207, stack; //apuntador al heap del obejto
=>, t207, t208, heap; // recuperando pos incial del objeto
+, t208, 3, t207;
=>, t207, t209, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t210; // pos de T2
=>, t210, t211, stack; // valor de lo que trae en el stack T2
<=, t207, t211, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t212; // pos del objeto
=>, t212, t214, stack; //apuntador al heap del obejto
=>, t214, t215, heap; // recuperando pos incial del objeto
+, t215, 1, t214;
=>, t214, t216, heap; // valor a retoranar del acceso
+, P, 0, t217;
=>, t217, t218, stack; 
+, P, 5, t219;
+, t218, 0, t220;
<=, t219, t218, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t221; // size de funcion actual
+, t221, 1, t222; //pos del parametro 1
+, P, 0, t223;
=>, t223, t224, stack; 
+, P, 5, t225;
+, t224, 0, t226;
<=, t225, t224, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t227; // size de funcion actual
+, t227, 1, t228; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t229; // pos del objeto
=>, t229, t231, stack; //apuntador al heap del obejto
=>, t231, t232, heap; // recuperando pos incial del objeto
+, t232, 2, t231;
=>, t231, t233, heap; // valor a retoranar del acceso
<=, t228, t233, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t234;
=>, t234, t235, stack; // valor del return
-, P, 5, P;
<=, t222, t235, stack; // asignado al stack el parametro
+, p, 5, t236; // size de funcion actual
+, t236, 2, t237; //pos del parametro 2
+, P, 0, t238;
=>, t238, t239, stack; 
+, P, 5, t240;
+, t239, 0, t241;
<=, t240, t239, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t242; // size de funcion actual
+, t242, 1, t243; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t244; // pos del objeto
=>, t244, t246, stack; //apuntador al heap del obejto
=>, t246, t247, heap; // recuperando pos incial del objeto
+, t247, 3, t246;
=>, t246, t248, heap; // valor a retoranar del acceso
<=, t243, t248, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t249;
=>, t249, t250, stack; // valor del return
-, P, 5, P;
<=, t237, t250, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t251;
=>, t251, t252, stack; // valor del return
-, P, 5, P;
+, t252, 1, t253;
<=, t214, t253, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 2, t254; // pos del objeto
=>, t254, t256, stack; //apuntador al heap del obejto
=>, t256, t257, heap; // recuperando pos incial del objeto
+, t257, 1, t256;
=>, t256, t258, heap; // valor a retoranar del acceso
+, P, 0, t259;
=>, t259, t260, stack; 
+, P, 5, t261;
+, t260, 0, t262;
<=, t261, t260, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t263; // size de funcion actual
+, t263, 1, t264; //pos del parametro 1
+, P, 0, t265;
=>, t265, t266, stack; 
+, P, 5, t267;
+, t266, 0, t268;
<=, t267, t266, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t269; // size de funcion actual
+, t269, 1, t270; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t271; // pos del objeto
=>, t271, t273, stack; //apuntador al heap del obejto
=>, t273, t274, heap; // recuperando pos incial del objeto
+, t274, 2, t273;
=>, t273, t275, heap; // valor a retoranar del acceso
<=, t270, t275, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t276;
=>, t276, t277, stack; // valor del return
-, P, 5, P;
<=, t264, t277, stack; // asignado al stack el parametro
+, p, 5, t278; // size de funcion actual
+, t278, 2, t279; //pos del parametro 2
+, P, 0, t280;
=>, t280, t281, stack; 
+, P, 5, t282;
+, t281, 0, t283;
<=, t282, t281, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t284; // size de funcion actual
+, t284, 1, t285; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t286; // pos del objeto
=>, t286, t288, stack; //apuntador al heap del obejto
=>, t288, t289, heap; // recuperando pos incial del objeto
+, t289, 3, t288;
=>, t288, t290, heap; // valor a retoranar del acceso
<=, t285, t290, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t291;
=>, t291, t292, stack; // valor del return
-, P, 5, P;
<=, t279, t292, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t293;
=>, t293, t294, stack; // valor del return
-, P, 5, P;
+, t294, 1, t295;
<=, t256, t295, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t296; // pos de y
=>, t296, t297, stack; // valor de lo que trae en el stack y
+, P, 4, t298; // pos de retorno de a funcion Tree_Node_leftRotate_Node
<=, t298, t297, stack; //asignando el retorno con su valor
jmp, , , L13;

L13:
end, , Tree_Node_leftRotate_Node




begin, , , Tree_entero_getBalance_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t299; // pos de N
=>, t299, t300, stack; // valor de lo que trae en el stack N
je, t300, 36, L16;
jmp, , , L17;
L16:

// RESOLVIENDO UN RETORNO
+, P, 2, t301; // pos de retorno de a funcion Tree_entero_getBalance_Node
<=, t301, 0, stack; //asignando el retorno con su valor
jmp, , , L14;
jmp, , , L15; // salida del if
L17:

L15:
// RESOLVIENDO UN RETORNO
+, P, 0, t302;
=>, t302, t303, stack; 
+, P, 3, t304;
+, t303, 0, t305;
<=, t304, t303, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t306; // size de funcion actual
+, t306, 1, t307; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t308; // pos del objeto
=>, t308, t310, stack; //apuntador al heap del obejto
=>, t310, t311, heap; // recuperando pos incial del objeto
+, t311, 2, t310;
=>, t310, t312, heap; // valor a retoranar del acceso
<=, t307, t312, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_entero_height_Node;
+, P, 2, t313;
=>, t313, t314, stack; // valor del return
-, P, 3, P;
+, P, 0, t315;
=>, t315, t316, stack; 
+, P, 3, t317;
+, t316, 0, t318;
<=, t317, t316, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t319; // size de funcion actual
+, t319, 1, t320; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t321; // pos del objeto
=>, t321, t323, stack; //apuntador al heap del obejto
=>, t323, t324, heap; // recuperando pos incial del objeto
+, t324, 3, t323;
=>, t323, t325, heap; // valor a retoranar del acceso
<=, t320, t325, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_entero_height_Node;
+, P, 2, t326;
=>, t326, t327, stack; // valor del return
-, P, 3, P;
-, t314, t327, t328;
+, P, 2, t329; // pos de retorno de a funcion Tree_entero_getBalance_Node
<=, t329, t328, stack; //asignando el retorno con su valor
jmp, , , L14;

L14:
end, , Tree_entero_getBalance_Node




begin, , , Tree_Node_insert_Node_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t330; // pos de node2
=>, t330, t331, stack; // valor de lo que trae en el stack node2
je, t331, 36, L20;
jmp, , , L21;
L20:

// ----------- Instancia a una variable local --------------
+, p, 3, t332; // pos de o
<=, t332, h, stack; //guardando referencia del heap para el objeto o
+, h, 1, t333; // guardo la posicion donde inicia el objeto 
<=, h, t333, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 4, h; // reservando espacio para el objeto o
//Ingresando referencia al this del objeto o
+, p, 3, t334; // pos de o
=>, t334, t335, stack; // obteniendo apuntador de o
+, p, 6, t336; // simulando cambio de ambito
+, t336, 0, t337; //pos del this de o
<=, t337, t335, stack; // insertando apuntador del heap al stack del obeto o
// Asignando parametros  
+, p, 6, t338; // size de funcion actual
+, t338, 1, t339; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t340; // pos de key
=>, t340, t341, stack; // valor de lo que trae en el stack key
<=, t339, t341, stack; // asignado al stack el parametro
+, p, 6, p; // simulando cambio de ambito
call, , , Node_vacio_Node_entero;
-, p, 6, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t342; // pos de o
=>, t342, t343, stack; // valor de lo que trae en el stack o
+, P, 5, t344; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t344, t343, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L19; // salida del if
L21:

L19:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t345; // pos de key
=>, t345, t346, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t347; // pos del objeto
=>, t347, t349, stack; //apuntador al heap del obejto
=>, t349, t350, heap; // recuperando pos incial del objeto
+, t350, 0, t349;
=>, t349, t351, heap; // valor a retoranar del acceso
jl, t346, t351, L23;
jmp, , , L24;
L23:

// Resolviendo una cadena 
+, H, 0, t352; //apuntaodr a cadena 
+, H, 1, t353; //apu donde inicia la cadena
<=, t352, t353, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t354; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t352);
// ----------------- Resolviendo acceso local 
+, P, 1, t355; // pos del objeto
=>, t355, t357, stack; //apuntador al heap del obejto
=>, t357, t358, heap; // recuperando pos incial del objeto
+, t358, 2, t357;
=>, t357, t359, heap; // valor a retoranar del acceso
+, P, 0, t360;
=>, t360, t361, stack; 
+, P, 6, t362;
+, t361, 0, t363;
<=, t362, t361, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t364; // size de funcion actual
+, t364, 1, t365; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t366; // pos del objeto
=>, t366, t368, stack; //apuntador al heap del obejto
=>, t368, t369, heap; // recuperando pos incial del objeto
+, t369, 2, t368;
=>, t368, t370, heap; // valor a retoranar del acceso
<=, t365, t370, stack; // asignado al stack el parametro
+, p, 6, t371; // size de funcion actual
+, t371, 2, t372; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t373; // pos de key
=>, t373, t374, stack; // valor de lo que trae en el stack key
<=, t372, t374, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t375;
=>, t375, t376, stack; // valor del return
-, P, 6, P;
<=, t357, t376, heap; // asignando variable 
jmp, , , L22; // salida del if
L24:

// Resolviendo una cadena 
+, H, 0, t377; //apuntaodr a cadena 
+, H, 1, t378; //apu donde inicia la cadena
<=, t377, t378, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t379; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t377);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t380; // pos de key
=>, t380, t381, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t382; // pos del objeto
=>, t382, t384, stack; //apuntador al heap del obejto
=>, t384, t385, heap; // recuperando pos incial del objeto
+, t385, 0, t384;
=>, t384, t386, heap; // valor a retoranar del acceso
jg, t381, t386, L26;
jmp, , , L27;
L26:

// ----------------- Resolviendo acceso local 
+, P, 1, t387; // pos del objeto
=>, t387, t389, stack; //apuntador al heap del obejto
=>, t389, t390, heap; // recuperando pos incial del objeto
+, t390, 3, t389;
=>, t389, t391, heap; // valor a retoranar del acceso
+, P, 0, t392;
=>, t392, t393, stack; 
+, P, 6, t394;
+, t393, 0, t395;
<=, t394, t393, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t396; // size de funcion actual
+, t396, 1, t397; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t398; // pos del objeto
=>, t398, t400, stack; //apuntador al heap del obejto
=>, t400, t401, heap; // recuperando pos incial del objeto
+, t401, 3, t400;
=>, t400, t402, heap; // valor a retoranar del acceso
<=, t397, t402, stack; // asignado al stack el parametro
+, p, 6, t403; // size de funcion actual
+, t403, 2, t404; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t405; // pos de key
=>, t405, t406, stack; // valor de lo que trae en el stack key
<=, t404, t406, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t407;
=>, t407, t408, stack; // valor del return
-, P, 6, P;
<=, t389, t408, heap; // asignando variable 
jmp, , , L25; // salida del if
L27:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t409; // pos de node2
=>, t409, t410, stack; // valor de lo que trae en el stack node2
+, P, 5, t411; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t411, t410, stack; //asignando el retorno con su valor
jmp, , , L18;
L25:
L22:
// ----------------- Resolviendo acceso local 
+, P, 1, t412; // pos del objeto
=>, t412, t414, stack; //apuntador al heap del obejto
=>, t414, t415, heap; // recuperando pos incial del objeto
+, t415, 1, t414;
=>, t414, t416, heap; // valor a retoranar del acceso
+, P, 0, t417;
=>, t417, t418, stack; 
+, P, 6, t419;
+, t418, 0, t420;
<=, t419, t418, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t421; // size de funcion actual
+, t421, 1, t422; //pos del parametro 1
+, P, 0, t423;
=>, t423, t424, stack; 
+, P, 6, t425;
+, t424, 0, t426;
<=, t425, t424, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t427; // size de funcion actual
+, t427, 1, t428; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t429; // pos del objeto
=>, t429, t431, stack; //apuntador al heap del obejto
=>, t431, t432, heap; // recuperando pos incial del objeto
+, t432, 2, t431;
=>, t431, t433, heap; // valor a retoranar del acceso
<=, t428, t433, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_height_Node;
+, P, 2, t434;
=>, t434, t435, stack; // valor del return
-, P, 6, P;
<=, t422, t435, stack; // asignado al stack el parametro
+, p, 6, t436; // size de funcion actual
+, t436, 2, t437; //pos del parametro 2
+, P, 0, t438;
=>, t438, t439, stack; 
+, P, 6, t440;
+, t439, 0, t441;
<=, t440, t439, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t442; // size de funcion actual
+, t442, 1, t443; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t444; // pos del objeto
=>, t444, t446, stack; //apuntador al heap del obejto
=>, t446, t447, heap; // recuperando pos incial del objeto
+, t447, 3, t446;
=>, t446, t448, heap; // valor a retoranar del acceso
<=, t443, t448, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_height_Node;
+, P, 2, t449;
=>, t449, t450, stack; // valor del return
-, P, 6, P;
<=, t437, t450, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t451;
=>, t451, t452, stack; // valor del return
-, P, 6, P;
+, 1, t452, t453;
<=, t414, t453, heap; // asignando variable 
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t454; // pos de balance
+, P, 0, t455;
=>, t455, t456, stack; 
+, P, 6, t457;
+, t456, 0, t458;
<=, t457, t456, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t459; // size de funcion actual
+, t459, 1, t460; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t461; // pos de node2
=>, t461, t462, stack; // valor de lo que trae en el stack node2
<=, t460, t462, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_getBalance_Node;
+, P, 2, t463;
=>, t463, t464, stack; // valor del return
-, P, 6, P;
<=, t454, t464, stack; // asignando a balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t465; // pos de balance
=>, t465, t466, stack; // valor de lo que trae en el stack balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t467; // pos de key
=>, t467, t468, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t469; // pos del objeto
=>, t469, t471, stack; //apuntador al heap del obejto
=>, t471, t472, heap; // recuperando pos incial del objeto
+, t472, 2, t471;
=>, t471, t473, heap; // recuperando pos incial del objeto
+, t473, 0, t471;
=>, t471, t474, heap; // valor a retoranar del acceso
jg, t466, 1, L29;
jmp, , , L30;
L29:

jl, t468, t474, L31;
jmp, , , L32;

L31:

// RESOLVIENDO UN RETORNO
+, P, 0, t475;
=>, t475, t476, stack; 
+, P, 6, t477;
+, t476, 0, t478;
<=, t477, t476, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t479; // size de funcion actual
+, t479, 1, t480; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t481; // pos de node2
=>, t481, t482, stack; // valor de lo que trae en el stack node2
<=, t480, t482, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t483;
=>, t483, t484, stack; // valor del return
-, P, 6, P;
+, P, 5, t485; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t485, t484, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L28; // salida del if
L30:
L32:

L28:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t486; // pos de balance
=>, t486, t487, stack; // valor de lo que trae en el stack balance
*, 1, -1, t488;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t489; // pos de key
=>, t489, t490, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t491; // pos del objeto
=>, t491, t493, stack; //apuntador al heap del obejto
=>, t493, t494, heap; // recuperando pos incial del objeto
+, t494, 3, t493;
=>, t493, t495, heap; // recuperando pos incial del objeto
+, t495, 0, t493;
=>, t493, t496, heap; // valor a retoranar del acceso
jl, t487, t488, L34;
jmp, , , L35;
L34:

jg, t490, t496, L36;
jmp, , , L37;

L36:

// RESOLVIENDO UN RETORNO
+, P, 0, t497;
=>, t497, t498, stack; 
+, P, 6, t499;
+, t498, 0, t500;
<=, t499, t498, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t501; // size de funcion actual
+, t501, 1, t502; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t503; // pos de node2
=>, t503, t504, stack; // valor de lo que trae en el stack node2
<=, t502, t504, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t505;
=>, t505, t506, stack; // valor del return
-, P, 6, P;
+, P, 5, t507; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t507, t506, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L33; // salida del if
L35:
L37:

L33:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t508; // pos de balance
=>, t508, t509, stack; // valor de lo que trae en el stack balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t510; // pos de key
=>, t510, t511, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t512; // pos del objeto
=>, t512, t514, stack; //apuntador al heap del obejto
=>, t514, t515, heap; // recuperando pos incial del objeto
+, t515, 2, t514;
=>, t514, t516, heap; // recuperando pos incial del objeto
+, t516, 0, t514;
=>, t514, t517, heap; // valor a retoranar del acceso
jg, t509, 1, L39;
jmp, , , L40;
L39:

jg, t511, t517, L41;
jmp, , , L42;

L41:

// ----------------- Resolviendo acceso local 
+, P, 1, t518; // pos del objeto
=>, t518, t520, stack; //apuntador al heap del obejto
=>, t520, t521, heap; // recuperando pos incial del objeto
+, t521, 2, t520;
=>, t520, t522, heap; // valor a retoranar del acceso
+, P, 0, t523;
=>, t523, t524, stack; 
+, P, 6, t525;
+, t524, 0, t526;
<=, t525, t524, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t527; // size de funcion actual
+, t527, 1, t528; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t529; // pos del objeto
=>, t529, t531, stack; //apuntador al heap del obejto
=>, t531, t532, heap; // recuperando pos incial del objeto
+, t532, 2, t531;
=>, t531, t533, heap; // valor a retoranar del acceso
<=, t528, t533, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t534;
=>, t534, t535, stack; // valor del return
-, P, 6, P;
<=, t520, t535, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
+, P, 0, t536;
=>, t536, t537, stack; 
+, P, 6, t538;
+, t537, 0, t539;
<=, t538, t537, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t540; // size de funcion actual
+, t540, 1, t541; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t542; // pos de node2
=>, t542, t543, stack; // valor de lo que trae en el stack node2
<=, t541, t543, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t544;
=>, t544, t545, stack; // valor del return
-, P, 6, P;
+, P, 5, t546; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t546, t545, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L38; // salida del if
L40:
L42:

L38:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t547; // pos de balance
=>, t547, t548, stack; // valor de lo que trae en el stack balance
*, 1, -1, t549;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t550; // pos de key
=>, t550, t551, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t552; // pos del objeto
=>, t552, t554, stack; //apuntador al heap del obejto
=>, t554, t555, heap; // recuperando pos incial del objeto
+, t555, 3, t554;
=>, t554, t556, heap; // recuperando pos incial del objeto
+, t556, 0, t554;
=>, t554, t557, heap; // valor a retoranar del acceso
jl, t548, t549, L44;
jmp, , , L45;
L44:

jl, t551, t557, L46;
jmp, , , L47;

L46:

// ----------------- Resolviendo acceso local 
+, P, 1, t558; // pos del objeto
=>, t558, t560, stack; //apuntador al heap del obejto
=>, t560, t561, heap; // recuperando pos incial del objeto
+, t561, 3, t560;
=>, t560, t562, heap; // valor a retoranar del acceso
+, P, 0, t563;
=>, t563, t564, stack; 
+, P, 6, t565;
+, t564, 0, t566;
<=, t565, t564, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t567; // size de funcion actual
+, t567, 1, t568; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t569; // pos del objeto
=>, t569, t571, stack; //apuntador al heap del obejto
=>, t571, t572, heap; // recuperando pos incial del objeto
+, t572, 3, t571;
=>, t571, t573, heap; // valor a retoranar del acceso
<=, t568, t573, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t574;
=>, t574, t575, stack; // valor del return
-, P, 6, P;
<=, t560, t575, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
+, P, 0, t576;
=>, t576, t577, stack; 
+, P, 6, t578;
+, t577, 0, t579;
<=, t578, t577, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t580; // size de funcion actual
+, t580, 1, t581; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t582; // pos de node2
=>, t582, t583, stack; // valor de lo que trae en el stack node2
<=, t581, t583, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t584;
=>, t584, t585, stack; // valor del return
-, P, 6, P;
+, P, 5, t586; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t586, t585, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L43; // salida del if
L45:
L47:

L43:
// Resolviendo una cadena 
+, H, 0, t587; //apuntaodr a cadena 
+, H, 1, t588; //apu donde inicia la cadena
<=, t587, t588, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t589; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 40, heap; //guardadndo (
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t587);
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t590; // pos de node2
=>, t590, t591, stack; // valor de lo que trae en el stack node2
+, P, 5, t592; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t592, t591, stack; //asignando el retorno con su valor
jmp, , , L18;

L18:
end, , Tree_Node_insert_Node_entero




begin, , , Tree_vacio_postOrder_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t593; // pos de node2
=>, t593, t594, stack; // valor de lo que trae en el stack node2
jne, t594, 36, L50;
jmp, , , L51;
L50:

// Resolviendo una cadena 
+, H, 0, t595; //apuntaodr a cadena 
+, H, 1, t596; //apu donde inicia la cadena
<=, t595, t596, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 18, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t597; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t595);
// ----------------- Resolviendo acceso local 
+, P, 1, t598; // pos del objeto
=>, t598, t600, stack; //apuntador al heap del obejto
=>, t600, t601, heap; // recuperando pos incial del objeto
+, t601, 0, t600;
=>, t600, t602, heap; // valor a retoranar del acceso
print("%d", t602);
+, P, 0, t603;
=>, t603, t604, stack; 
+, P, 3, t605;
+, t604, 0, t606;
<=, t605, t604, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t607; // size de funcion actual
+, t607, 1, t608; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t609; // pos del objeto
=>, t609, t611, stack; //apuntador al heap del obejto
=>, t611, t612, heap; // recuperando pos incial del objeto
+, t612, 2, t611;
=>, t611, t613, heap; // valor a retoranar del acceso
<=, t608, t613, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_vacio_postOrder_Node;
+, P, 2, t614;
=>, t614, t615, stack; // valor del return
-, P, 3, P;
+, P, 0, t616;
=>, t616, t617, stack; 
+, P, 3, t618;
+, t617, 0, t619;
<=, t618, t617, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t620; // size de funcion actual
+, t620, 1, t621; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t622; // pos del objeto
=>, t622, t624, stack; //apuntador al heap del obejto
=>, t624, t625, heap; // recuperando pos incial del objeto
+, t625, 3, t624;
=>, t624, t626, heap; // valor a retoranar del acceso
<=, t621, t626, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_vacio_postOrder_Node;
+, P, 2, t627;
=>, t627, t628, stack; // valor del return
-, P, 3, P;
jmp, , , L49; // salida del if
L51:

L49:

L48:
end, , Tree_vacio_postOrder_Node


