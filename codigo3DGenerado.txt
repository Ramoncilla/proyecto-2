

begin, , , Operaciones_vacio_cantar

// Resolviendo una cadena 
+, H, 0, t1; //apuntaodr a cadena 
+, H, 1, t2; //apu donde inicia la cadena
<=, t1, t2, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 9, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t3; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t1);

L1:
end, , Operaciones_vacio_cantar




begin, , , Operaciones_vacio_operaciones


L2:
end, , Operaciones_vacio_operaciones




begin, , , Operaciones_vacio_aritmeticas

// Resolviendo una cadena 
+, H, 0, t4; //apuntaodr a cadena 
+, H, 1, t5; //apu donde inicia la cadena
<=, t4, t5, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 36, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t6; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t4);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t7; // pos de temp1
*, 3, 7, t8;
/, 8, 2, t9;
-, t8, t9, t10;
-, 5, 10, t11;
*, 8, t11, t12;
-, t10, t12, t13;
<=, t7, t13, stack; // asignando a temp1
// ------------------------ Creando arreglo local texto
+, P, 2, t14; //pos de arreglo texto
<=, t14, H, stack; // ingrensando al stack apunt del heap para texto
+, H, 1, t15;
<=, H, t15, heap; //insetnado donde inicia el arreglo texto
+, H, 1, H;
// calculando el tamanho del arreglo
-, 50, 1, t16; //calculando el n real
-, t16, 0, t17; //iReal columna 0
+, t17, 1, t17; //size del arreglo texto
<=, H, t17, heap; // insertando el tamanio del arreglo linealizado texto
+, H, 1, H;
+, h, t17, h; // reservnado el espacio del arreglo texto
+, P, 2, t20; // pos del arreglo 
=>, t20, t21, stack; //apuntador al heap del arreglo
=>, t21, t22, heap; // apuntador del heap al heap donde inicia la cadena
=>, t22, t18, heap; // size del arreglo texto
+, t22, 1, t19; // pos 0 donde inicia el arreglo texto
// Resolviendo una cadena 
+, H, 0, t23; //apuntaodr a cadena 
+, H, 1, t24; //apu donde inicia la cadena
<=, t23, t24, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 13, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t25; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 46, heap; //guardadndo .
+, H, 1, H;
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 51, heap; //guardadndo 3
+, H, 1, H;
<=, H, 48, heap; //guardadndo 0
+, H, 1, H;
<=, H, 37, heap; //guardadndo %
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t23, t26, heap; // pos que apunta al size de la cadena
=>, t26, t27, heap; // size de la cadena
+, t26, 1, t28; // Pos 0 de la cadena
=>, t28, t29, heap; // sacandor el caracter del heap cadena
jle, t27, t18, L4;
jmp, , , L5;
jmp, , , L4;
L4:
jne, t29, 36, L6;
jmp, , , L7;
jmp, , , L6;
L6:
<=, t19, t29, heap; // guardando el caracter 
+, t19, 1, t19; // incremnetnado la pos del arreglo
+, t28, 1, t28; // incrementando la pos de la cadena
=>, t28, t29, heap; // sacandor el caracter del heap cadena
jmp, , , L4;
jmp, , , L7;
L7:
jmp, , , L5;
L5:
+, P, 2, t30;
=>, t30, t31, stack; 
=>, t31, t32, heap; 
=>, t32, t33, heap; // valor de size del arreglo texto
+, t32, 1, t34; // apuntador donde inicia el arreglo texto
=>, t34, t35, heap; // primer caracter del arreglo texto
+, H, 0, t36;
+, H, 1, t37;
<=, t36, t37, heap; 
+, H, 1, H;
+, 0, 0, t38;
<=, H, t38, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L8:
jne, t35, 36, L9;
jmp, , , L10;
L9:
<=, H, t35, heap; // ingresando el caracter 
+, H, 1, H;
+, t38, 1, t38; // incrementando en uno el size de la nueva cadena
+, t34, 1, t34;
=>, t34, t35, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L8;
L10:
<=, t37, t38, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t39; // pos de temp1
=>, t39, t40, stack; // valor de lo que trae en el stack temp1
// Resolviendo una cadena 
+, H, 0, t41; //apuntaodr a cadena 
+, H, 1, t42; //apu donde inicia la cadena
<=, t41, t42, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t43; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t44; //apuntaodr a cadena 
+, H, 1, t45; //apu donde inicia la cadena
<=, t44, t45, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t46; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// ---------------------------  Convertir a caden aun decimal ----
%#, t40, 0, t47; // parte entera del numero t40
!#, t40, 0, t48; // parte decimal del numero t40
// ---------------------------- Convertir parte entera a cadena ----------------
jne, 0, t47, L11; //1546545456
jmp, , , L12;
L11:
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t49; // inicio cad1 (inversa)
+, H, 1, t50;
<=, t49, t50, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t47, 0, t51;
+, 0, 0, t52;
+, 0, 0, t53;
+, 0, 0, t54;
+, t47, 0, t55;
L13:
jl, t52, t51, L14;
jmp, , , L15;
L14:
%%, t55, 0, t53;
+, t53, 48, t56;
<=, H, t56, heap;
+, H, 1, H; 
##, t55, 0, t55;
+, t52, 1, t52;
jmp, , , L13;
L15:
<=, H, 36, heap; 
+, H, 1, H;
<=, t50, t51, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t51, 0, t57;
+, t57, 0, t58;
+, t50, t57, t59; // pos inicial del primero caracter de la cadena
=>, t59, t60, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t61;
+, H, 1, t62;
<=, t61, t62, heap; 
+, H, 1, H;
+, H, 1, H;
L16:
jl, 0, t58, L17;
jmp, , , L18;
L17:
<=, H, t60, heap; // guardando caracterr actual
+, H, 1, H;
-, t59, 1, t59;
=>, t59, t60, heap;
-, t58, 1, t58;
jmp, , , L16;
L18:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t62, t57, heap;
jmp, , , L19;
L12:
// -------------------------------- crear cadena de 0 ----------------
+, H, 0, t61; // inicio cad1 (inversa)
+, H, 1, t62;
<=, t61, t62, heap;
+, H, 1, H;
<=, t62, 0, heap;
+, H, 1, H;
<=, H, 48, heap;
+, H, 1, H;
<=, H, 36, heap;
+, H, 1, H;
L19:
// ----------------------  Crear cadena para el punto ------------------
+, H, 0, t63; //apuntador de cadena
+, H, 1, t64; // posicion donde iniciara la cadena
<=, t63, t64, heap; //insertando apuntador del heap donde incia la cadena
+, H, 1, H; // incrementando h
<=, H, 1, heap; //ingrensado el tamanho de la cadena nueva 
+, H, 1, H; // incrementando h
<=, H, 46, heap; // ingresnado caracter al heap
+, H, 1, H; // incrementando h
<=, H, 36, heap; //caracter de escape de la nueva cadena
+, H, 1, H; // incrementando h
// ----------------------- Concatenar parte entera con punto -----------------------
//Iniciando a concatnar cadenas 
=>, t61, t65, heap;
=>, t65, t66, heap; // size cadena1
+, t65, 1, t67; // pos 0 de la cadena 1
=>, t63, t68, heap;
=>, t68, t69, heap; // size cadena2
+, t68, 1, t70; // pos 0 de la cadena 2
+, t66, t69, t71; // size de la nueva cadena
=>, t67, t72, heap; // primer caracter de la cadena 1
=>, t70, t73, heap; // primer caracter de la cadena 2
+, H, 0, t74; // posicion de retorno de la cadena
+, H, 1, t75;
<=, t74, t75, heap;
+, H, 1, H;
<=, H, t71, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L20;
L20:
jne, t72, 36, L21;
jmp, , , L22;
jmp, , , L21;
L21:
<=, H, t72, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t67, 1, t67;
=>, t67, t72, heap;
jmp, , , L20;
jmp, , , L22;
L22:
jmp, , , L23;
L23:
jne, t73, 36, L24;
jmp, , , L25;
jmp, , , L24;
L24:
<=, H, t73, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t70, 1, t70;
=>, t70, t73, heap;
jmp, , , L23;
jmp, , , L25;
L25:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
// ------------------------------ Crear Cadena para parte decimal -------------------------
jne, 0, t48, L26; //1546545456
jmp, , , L27;
L26:
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t76; // inicio cad1 (inversa)
+, H, 1, t77;
<=, t76, t77, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t48, 0, t78;
+, 0, 0, t79;
+, 0, 0, t80;
+, 0, 0, t81;
+, t48, 0, t82;
L28:
jl, t79, t78, L29;
jmp, , , L30;
L29:
%%, t82, 0, t80;
+, t80, 48, t83;
<=, H, t83, heap;
+, H, 1, H; 
##, t82, 0, t82;
+, t79, 1, t79;
jmp, , , L28;
L30:
<=, H, 36, heap; 
+, H, 1, H;
<=, t77, t78, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t78, 0, t84;
+, t84, 0, t85;
+, t77, t84, t86; // pos inicial del primero caracter de la cadena
=>, t86, t87, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t88;
+, H, 1, t89;
<=, t88, t89, heap; 
+, H, 1, H;
+, H, 1, H;
L31:
jl, 0, t85, L32;
jmp, , , L33;
L32:
<=, H, t87, heap; // guardando caracterr actual
+, H, 1, H;
-, t86, 1, t86;
=>, t86, t87, heap;
-, t85, 1, t85;
jmp, , , L31;
L33:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t89, t84, heap;
jmp, , , L34;
L27:
// -------------------------------- crear cadena de 0 ----------------
+, H, 0, t88; // inicio cad1 (inversa)
+, H, 1, t89;
<=, t88, t89, heap;
+, H, 1, H;
<=, t89, 0, heap;
+, H, 1, H;
<=, H, 48, heap;
+, H, 1, H;
<=, H, 36, heap;
+, H, 1, H;
L34:
// -------------------------- Concatenar parte entera con punto y parte decimal --------------------
//Iniciando a concatnar cadenas 
=>, t74, t90, heap;
=>, t90, t91, heap; // size cadena1
+, t90, 1, t92; // pos 0 de la cadena 1
=>, t88, t93, heap;
=>, t93, t94, heap; // size cadena2
+, t93, 1, t95; // pos 0 de la cadena 2
+, t91, t94, t96; // size de la nueva cadena
=>, t92, t97, heap; // primer caracter de la cadena 1
=>, t95, t98, heap; // primer caracter de la cadena 2
+, H, 0, t99; // posicion de retorno de la cadena
+, H, 1, t100;
<=, t99, t100, heap;
+, H, 1, H;
<=, H, t96, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L35;
L35:
jne, t97, 36, L36;
jmp, , , L37;
jmp, , , L36;
L36:
<=, H, t97, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t92, 1, t92;
=>, t92, t97, heap;
jmp, , , L35;
jmp, , , L37;
L37:
jmp, , , L38;
L38:
jne, t98, 36, L39;
jmp, , , L40;
jmp, , , L39;
L39:
<=, H, t98, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t95, 1, t95;
=>, t95, t98, heap;
jmp, , , L38;
jmp, , , L40;
L40:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t41, t101, heap;
=>, t101, t102, heap; // size cadena1
+, t101, 1, t103; // pos 0 de la cadena 1
=>, t99, t104, heap;
=>, t104, t105, heap; // size cadena2
+, t104, 1, t106; // pos 0 de la cadena 2
+, t102, t105, t107; // size de la nueva cadena
=>, t103, t108, heap; // primer caracter de la cadena 1
=>, t106, t109, heap; // primer caracter de la cadena 2
+, H, 0, t110; // posicion de retorno de la cadena
+, H, 1, t111;
<=, t110, t111, heap;
+, H, 1, H;
<=, H, t107, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L41;
L41:
jne, t108, 36, L42;
jmp, , , L43;
jmp, , , L42;
L42:
<=, H, t108, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t103, 1, t103;
=>, t103, t108, heap;
jmp, , , L41;
jmp, , , L43;
L43:
jmp, , , L44;
L44:
jne, t109, 36, L45;
jmp, , , L46;
jmp, , , L45;
L45:
<=, H, t109, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t106, 1, t106;
=>, t106, t109, heap;
jmp, , , L44;
jmp, , , L46;
L46:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t110, t112, heap;
=>, t112, t113, heap; // size cadena1
+, t112, 1, t114; // pos 0 de la cadena 1
=>, t44, t115, heap;
=>, t115, t116, heap; // size cadena2
+, t115, 1, t117; // pos 0 de la cadena 2
+, t113, t116, t118; // size de la nueva cadena
=>, t114, t119, heap; // primer caracter de la cadena 1
=>, t117, t120, heap; // primer caracter de la cadena 2
+, H, 0, t121; // posicion de retorno de la cadena
+, H, 1, t122;
<=, t121, t122, heap;
+, H, 1, H;
<=, H, t118, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L47;
L47:
jne, t119, 36, L48;
jmp, , , L49;
jmp, , , L48;
L48:
<=, H, t119, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t114, 1, t114;
=>, t114, t119, heap;
jmp, , , L47;
jmp, , , L49;
L49:
jmp, , , L50;
L50:
jne, t120, 36, L51;
jmp, , , L52;
jmp, , , L51;
L51:
<=, H, t120, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t117, 1, t117;
=>, t117, t120, heap;
jmp, , , L50;
jmp, , , L52;
L52:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t36, t123, heap;
=>, t123, t124, heap; // size cadena1
+, t123, 1, t125; // pos 0 de la cadena 1
=>, t121, t126, heap;
=>, t126, t127, heap; // size cadena2
+, t126, 1, t128; // pos 0 de la cadena 2
+, t124, t127, t129; // size de la nueva cadena
=>, t125, t130, heap; // primer caracter de la cadena 1
=>, t128, t131, heap; // primer caracter de la cadena 2
+, H, 0, t132; // posicion de retorno de la cadena
+, H, 1, t133;
<=, t132, t133, heap;
+, H, 1, H;
<=, H, t129, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L53;
L53:
jne, t130, 36, L54;
jmp, , , L55;
jmp, , , L54;
L54:
<=, H, t130, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t125, 1, t125;
=>, t125, t130, heap;
jmp, , , L53;
jmp, , , L55;
L55:
jmp, , , L56;
L56:
jne, t131, 36, L57;
jmp, , , L58;
jmp, , , L57;
L57:
<=, H, t131, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t128, 1, t128;
=>, t128, t131, heap;
jmp, , , L56;
jmp, , , L58;
L58:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t136; // pos del arreglo 
=>, t136, t137, stack; //apuntador al heap del arreglo
=>, t137, t138, heap; // apuntador del heap al heap donde inicia la cadena
=>, t138, t134, heap; // size del arreglo texto
+, t138, 1, t135; // pos 0 donde inicia el arreglo texto
=>, t132, t139, heap; // pos que apunta al size de la cadena
=>, t139, t140, heap; // size de la cadena
+, t139, 1, t141; // Pos 0 de la cadena
=>, t141, t142, heap; // sacandor el caracter del heap cadena
jle, t140, t134, L59;
jmp, , , L60;
jmp, , , L59;
L59:
jne, t142, 36, L61;
jmp, , , L62;
jmp, , , L61;
L61:
<=, t135, t142, heap; // guardando el caracter 
+, t135, 1, t135; // incremnetnado la pos del arreglo
+, t141, 1, t141; // incrementando la pos de la cadena
=>, t141, t142, heap; // sacandor el caracter del heap cadena
jmp, , , L59;
jmp, , , L62;
L62:
jmp, , , L60;
L60:
+, P, 2, t143;
=>, t143, t144, stack; 
=>, t144, t145, heap; 
=>, t145, t146, heap; // valor de size del arreglo texto
+, t145, 1, t147; // apuntador donde inicia el arreglo texto
=>, t147, t148, heap; // primer caracter del arreglo texto
+, H, 0, t149;
+, H, 1, t150;
<=, t149, t150, heap; 
+, H, 1, H;
+, 0, 0, t151;
<=, H, t151, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L63:
jne, t148, 36, L64;
jmp, , , L65;
L64:
<=, H, t148, heap; // ingresando el caracter 
+, H, 1, H;
+, t151, 1, t151; // incrementando en uno el size de la nueva cadena
+, t147, 1, t147;
=>, t147, t148, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L63;
L65:
<=, t150, t151, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t149);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t152; // pos de temp2
*, 3, 9, t153;
+, 0, t153, t154;
-, t154, 18, t155;
^, 3, 3, t156;
+, t155, t156, t157;
<=, t152, t157, stack; // asignando a temp2
// Resolviendo una cadena 
+, H, 0, t158; //apuntaodr a cadena 
+, H, 1, t159; //apu donde inicia la cadena
<=, t158, t159, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 13, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t160; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 46, heap; //guardadndo .
+, H, 1, H;
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 51, heap; //guardadndo 3
+, H, 1, H;
<=, H, 48, heap; //guardadndo 0
+, H, 1, H;
<=, H, 37, heap; //guardadndo %
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 2, t163; // pos del arreglo 
=>, t163, t164, stack; //apuntador al heap del arreglo
=>, t164, t165, heap; // apuntador del heap al heap donde inicia la cadena
=>, t165, t161, heap; // size del arreglo texto
+, t165, 1, t162; // pos 0 donde inicia el arreglo texto
=>, t158, t166, heap; // pos que apunta al size de la cadena
=>, t166, t167, heap; // size de la cadena
+, t166, 1, t168; // Pos 0 de la cadena
=>, t168, t169, heap; // sacandor el caracter del heap cadena
jle, t167, t161, L66;
jmp, , , L67;
jmp, , , L66;
L66:
jne, t169, 36, L68;
jmp, , , L69;
jmp, , , L68;
L68:
<=, t162, t169, heap; // guardando el caracter 
+, t162, 1, t162; // incremnetnado la pos del arreglo
+, t168, 1, t168; // incrementando la pos de la cadena
=>, t168, t169, heap; // sacandor el caracter del heap cadena
jmp, , , L66;
jmp, , , L69;
L69:
jmp, , , L67;
L67:
+, P, 2, t170;
=>, t170, t171, stack; 
=>, t171, t172, heap; 
=>, t172, t173, heap; // valor de size del arreglo texto
+, t172, 1, t174; // apuntador donde inicia el arreglo texto
=>, t174, t175, heap; // primer caracter del arreglo texto
+, H, 0, t176;
+, H, 1, t177;
<=, t176, t177, heap; 
+, H, 1, H;
+, 0, 0, t178;
<=, H, t178, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L70:
jne, t175, 36, L71;
jmp, , , L72;
L71:
<=, H, t175, heap; // ingresando el caracter 
+, H, 1, H;
+, t178, 1, t178; // incrementando en uno el size de la nueva cadena
+, t174, 1, t174;
=>, t174, t175, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L70;
L72:
<=, t177, t178, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t179; // pos de temp2
=>, t179, t180, stack; // valor de lo que trae en el stack temp2
// Resolviendo una cadena 
+, H, 0, t181; //apuntaodr a cadena 
+, H, 1, t182; //apu donde inicia la cadena
<=, t181, t182, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t183; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t184; //apuntaodr a cadena 
+, H, 1, t185; //apu donde inicia la cadena
<=, t184, t185, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t186; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
jne, 0, t180, L73; //1546545456
jmp, , , L74;
L73:
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t187; // inicio cad1 (inversa)
+, H, 1, t188;
<=, t187, t188, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t180, 0, t189;
+, 0, 0, t190;
+, 0, 0, t191;
+, 0, 0, t192;
+, t180, 0, t193;
L75:
jl, t190, t189, L76;
jmp, , , L77;
L76:
%%, t193, 0, t191;
+, t191, 48, t194;
<=, H, t194, heap;
+, H, 1, H; 
##, t193, 0, t193;
+, t190, 1, t190;
jmp, , , L75;
L77:
<=, H, 36, heap; 
+, H, 1, H;
<=, t188, t189, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t189, 0, t195;
+, t195, 0, t196;
+, t188, t195, t197; // pos inicial del primero caracter de la cadena
=>, t197, t198, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t199;
+, H, 1, t200;
<=, t199, t200, heap; 
+, H, 1, H;
+, H, 1, H;
L78:
jl, 0, t196, L79;
jmp, , , L80;
L79:
<=, H, t198, heap; // guardando caracterr actual
+, H, 1, H;
-, t197, 1, t197;
=>, t197, t198, heap;
-, t196, 1, t196;
jmp, , , L78;
L80:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t200, t195, heap;
jmp, , , L81;
L74:
// -------------------------------- crear cadena de 0 ----------------
+, H, 0, t199; // inicio cad1 (inversa)
+, H, 1, t200;
<=, t199, t200, heap;
+, H, 1, H;
<=, t200, 0, heap;
+, H, 1, H;
<=, H, 48, heap;
+, H, 1, H;
<=, H, 36, heap;
+, H, 1, H;
L81:
//Iniciando a concatnar cadenas 
=>, t181, t201, heap;
=>, t201, t202, heap; // size cadena1
+, t201, 1, t203; // pos 0 de la cadena 1
=>, t199, t204, heap;
=>, t204, t205, heap; // size cadena2
+, t204, 1, t206; // pos 0 de la cadena 2
+, t202, t205, t207; // size de la nueva cadena
=>, t203, t208, heap; // primer caracter de la cadena 1
=>, t206, t209, heap; // primer caracter de la cadena 2
+, H, 0, t210; // posicion de retorno de la cadena
+, H, 1, t211;
<=, t210, t211, heap;
+, H, 1, H;
<=, H, t207, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L82;
L82:
jne, t208, 36, L83;
jmp, , , L84;
jmp, , , L83;
L83:
<=, H, t208, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t203, 1, t203;
=>, t203, t208, heap;
jmp, , , L82;
jmp, , , L84;
L84:
jmp, , , L85;
L85:
jne, t209, 36, L86;
jmp, , , L87;
jmp, , , L86;
L86:
<=, H, t209, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t206, 1, t206;
=>, t206, t209, heap;
jmp, , , L85;
jmp, , , L87;
L87:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t210, t212, heap;
=>, t212, t213, heap; // size cadena1
+, t212, 1, t214; // pos 0 de la cadena 1
=>, t184, t215, heap;
=>, t215, t216, heap; // size cadena2
+, t215, 1, t217; // pos 0 de la cadena 2
+, t213, t216, t218; // size de la nueva cadena
=>, t214, t219, heap; // primer caracter de la cadena 1
=>, t217, t220, heap; // primer caracter de la cadena 2
+, H, 0, t221; // posicion de retorno de la cadena
+, H, 1, t222;
<=, t221, t222, heap;
+, H, 1, H;
<=, H, t218, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L88;
L88:
jne, t219, 36, L89;
jmp, , , L90;
jmp, , , L89;
L89:
<=, H, t219, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t214, 1, t214;
=>, t214, t219, heap;
jmp, , , L88;
jmp, , , L90;
L90:
jmp, , , L91;
L91:
jne, t220, 36, L92;
jmp, , , L93;
jmp, , , L92;
L92:
<=, H, t220, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t217, 1, t217;
=>, t217, t220, heap;
jmp, , , L91;
jmp, , , L93;
L93:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t176, t223, heap;
=>, t223, t224, heap; // size cadena1
+, t223, 1, t225; // pos 0 de la cadena 1
=>, t221, t226, heap;
=>, t226, t227, heap; // size cadena2
+, t226, 1, t228; // pos 0 de la cadena 2
+, t224, t227, t229; // size de la nueva cadena
=>, t225, t230, heap; // primer caracter de la cadena 1
=>, t228, t231, heap; // primer caracter de la cadena 2
+, H, 0, t232; // posicion de retorno de la cadena
+, H, 1, t233;
<=, t232, t233, heap;
+, H, 1, H;
<=, H, t229, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L94;
L94:
jne, t230, 36, L95;
jmp, , , L96;
jmp, , , L95;
L95:
<=, H, t230, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t225, 1, t225;
=>, t225, t230, heap;
jmp, , , L94;
jmp, , , L96;
L96:
jmp, , , L97;
L97:
jne, t231, 36, L98;
jmp, , , L99;
jmp, , , L98;
L98:
<=, H, t231, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t228, 1, t228;
=>, t228, t231, heap;
jmp, , , L97;
jmp, , , L99;
L99:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t236; // pos del arreglo 
=>, t236, t237, stack; //apuntador al heap del arreglo
=>, t237, t238, heap; // apuntador del heap al heap donde inicia la cadena
=>, t238, t234, heap; // size del arreglo texto
+, t238, 1, t235; // pos 0 donde inicia el arreglo texto
=>, t232, t239, heap; // pos que apunta al size de la cadena
=>, t239, t240, heap; // size de la cadena
+, t239, 1, t241; // Pos 0 de la cadena
=>, t241, t242, heap; // sacandor el caracter del heap cadena
jle, t240, t234, L100;
jmp, , , L101;
jmp, , , L100;
L100:
jne, t242, 36, L102;
jmp, , , L103;
jmp, , , L102;
L102:
<=, t235, t242, heap; // guardando el caracter 
+, t235, 1, t235; // incremnetnado la pos del arreglo
+, t241, 1, t241; // incrementando la pos de la cadena
=>, t241, t242, heap; // sacandor el caracter del heap cadena
jmp, , , L100;
jmp, , , L103;
L103:
jmp, , , L101;
L101:
+, P, 2, t243;
=>, t243, t244, stack; 
=>, t244, t245, heap; 
=>, t245, t246, heap; // valor de size del arreglo texto
+, t245, 1, t247; // apuntador donde inicia el arreglo texto
=>, t247, t248, heap; // primer caracter del arreglo texto
+, H, 0, t249;
+, H, 1, t250;
<=, t249, t250, heap; 
+, H, 1, H;
+, 0, 0, t251;
<=, H, t251, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L104:
jne, t248, 36, L105;
jmp, , , L106;
L105:
<=, H, t248, heap; // ingresando el caracter 
+, H, 1, H;
+, t251, 1, t251; // incrementando en uno el size de la nueva cadena
+, t247, 1, t247;
=>, t247, t248, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L104;
L106:
<=, t250, t251, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t249);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t252; // pos de temp3
-, 8, 8, t253;
^, 2, 3, t254;
/, t254, 4, t255;
+, t253, t255, t256;
*, t256, 4, t257;
<=, t252, t257, stack; // asignando a temp3
// Resolviendo una cadena 
+, H, 0, t258; //apuntaodr a cadena 
+, H, 1, t259; //apu donde inicia la cadena
<=, t258, t259, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 13, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t260; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 46, heap; //guardadndo .
+, H, 1, H;
<=, H, 51, heap; //guardadndo 3
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 48, heap; //guardadndo 0
+, H, 1, H;
<=, H, 37, heap; //guardadndo %
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 62, heap; //guardadndo >
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 2, t263; // pos del arreglo 
=>, t263, t264, stack; //apuntador al heap del arreglo
=>, t264, t265, heap; // apuntador del heap al heap donde inicia la cadena
=>, t265, t261, heap; // size del arreglo texto
+, t265, 1, t262; // pos 0 donde inicia el arreglo texto
=>, t258, t266, heap; // pos que apunta al size de la cadena
=>, t266, t267, heap; // size de la cadena
+, t266, 1, t268; // Pos 0 de la cadena
=>, t268, t269, heap; // sacandor el caracter del heap cadena
jle, t267, t261, L107;
jmp, , , L108;
jmp, , , L107;
L107:
jne, t269, 36, L109;
jmp, , , L110;
jmp, , , L109;
L109:
<=, t262, t269, heap; // guardando el caracter 
+, t262, 1, t262; // incremnetnado la pos del arreglo
+, t268, 1, t268; // incrementando la pos de la cadena
=>, t268, t269, heap; // sacandor el caracter del heap cadena
jmp, , , L107;
jmp, , , L110;
L110:
jmp, , , L108;
L108:
+, P, 2, t270;
=>, t270, t271, stack; 
=>, t271, t272, heap; 
=>, t272, t273, heap; // valor de size del arreglo texto
+, t272, 1, t274; // apuntador donde inicia el arreglo texto
=>, t274, t275, heap; // primer caracter del arreglo texto
+, H, 0, t276;
+, H, 1, t277;
<=, t276, t277, heap; 
+, H, 1, H;
+, 0, 0, t278;
<=, H, t278, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L111:
jne, t275, 36, L112;
jmp, , , L113;
L112:
<=, H, t275, heap; // ingresando el caracter 
+, H, 1, H;
+, t278, 1, t278; // incrementando en uno el size de la nueva cadena
+, t274, 1, t274;
=>, t274, t275, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L111;
L113:
<=, t277, t278, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t279; // pos de temp3
=>, t279, t280, stack; // valor de lo que trae en el stack temp3
// Resolviendo una cadena 
+, H, 0, t281; //apuntaodr a cadena 
+, H, 1, t282; //apu donde inicia la cadena
<=, t281, t282, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t283; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t284; //apuntaodr a cadena 
+, H, 1, t285; //apu donde inicia la cadena
<=, t284, t285, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t286; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// ---------------------------  Convertir a caden aun decimal ----
%#, t280, 0, t287; // parte entera del numero t280
!#, t280, 0, t288; // parte decimal del numero t280
// ---------------------------- Convertir parte entera a cadena ----------------
jne, 0, t287, L114; //1546545456
jmp, , , L115;
L114:
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t289; // inicio cad1 (inversa)
+, H, 1, t290;
<=, t289, t290, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t287, 0, t291;
+, 0, 0, t292;
+, 0, 0, t293;
+, 0, 0, t294;
+, t287, 0, t295;
L116:
jl, t292, t291, L117;
jmp, , , L118;
L117:
%%, t295, 0, t293;
+, t293, 48, t296;
<=, H, t296, heap;
+, H, 1, H; 
##, t295, 0, t295;
+, t292, 1, t292;
jmp, , , L116;
L118:
<=, H, 36, heap; 
+, H, 1, H;
<=, t290, t291, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t291, 0, t297;
+, t297, 0, t298;
+, t290, t297, t299; // pos inicial del primero caracter de la cadena
=>, t299, t300, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t301;
+, H, 1, t302;
<=, t301, t302, heap; 
+, H, 1, H;
+, H, 1, H;
L119:
jl, 0, t298, L120;
jmp, , , L121;
L120:
<=, H, t300, heap; // guardando caracterr actual
+, H, 1, H;
-, t299, 1, t299;
=>, t299, t300, heap;
-, t298, 1, t298;
jmp, , , L119;
L121:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t302, t297, heap;
jmp, , , L122;
L115:
// -------------------------------- crear cadena de 0 ----------------
+, H, 0, t301; // inicio cad1 (inversa)
+, H, 1, t302;
<=, t301, t302, heap;
+, H, 1, H;
<=, t302, 0, heap;
+, H, 1, H;
<=, H, 48, heap;
+, H, 1, H;
<=, H, 36, heap;
+, H, 1, H;
L122:
// ----------------------  Crear cadena para el punto ------------------
+, H, 0, t303; //apuntador de cadena
+, H, 1, t304; // posicion donde iniciara la cadena
<=, t303, t304, heap; //insertando apuntador del heap donde incia la cadena
+, H, 1, H; // incrementando h
<=, H, 1, heap; //ingrensado el tamanho de la cadena nueva 
+, H, 1, H; // incrementando h
<=, H, 46, heap; // ingresnado caracter al heap
+, H, 1, H; // incrementando h
<=, H, 36, heap; //caracter de escape de la nueva cadena
+, H, 1, H; // incrementando h
// ----------------------- Concatenar parte entera con punto -----------------------
//Iniciando a concatnar cadenas 
=>, t301, t305, heap;
=>, t305, t306, heap; // size cadena1
+, t305, 1, t307; // pos 0 de la cadena 1
=>, t303, t308, heap;
=>, t308, t309, heap; // size cadena2
+, t308, 1, t310; // pos 0 de la cadena 2
+, t306, t309, t311; // size de la nueva cadena
=>, t307, t312, heap; // primer caracter de la cadena 1
=>, t310, t313, heap; // primer caracter de la cadena 2
+, H, 0, t314; // posicion de retorno de la cadena
+, H, 1, t315;
<=, t314, t315, heap;
+, H, 1, H;
<=, H, t311, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L123;
L123:
jne, t312, 36, L124;
jmp, , , L125;
jmp, , , L124;
L124:
<=, H, t312, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t307, 1, t307;
=>, t307, t312, heap;
jmp, , , L123;
jmp, , , L125;
L125:
jmp, , , L126;
L126:
jne, t313, 36, L127;
jmp, , , L128;
jmp, , , L127;
L127:
<=, H, t313, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t310, 1, t310;
=>, t310, t313, heap;
jmp, , , L126;
jmp, , , L128;
L128:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
// ------------------------------ Crear Cadena para parte decimal -------------------------
jne, 0, t288, L129; //1546545456
jmp, , , L130;
L129:
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t316; // inicio cad1 (inversa)
+, H, 1, t317;
<=, t316, t317, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t288, 0, t318;
+, 0, 0, t319;
+, 0, 0, t320;
+, 0, 0, t321;
+, t288, 0, t322;
L131:
jl, t319, t318, L132;
jmp, , , L133;
L132:
%%, t322, 0, t320;
+, t320, 48, t323;
<=, H, t323, heap;
+, H, 1, H; 
##, t322, 0, t322;
+, t319, 1, t319;
jmp, , , L131;
L133:
<=, H, 36, heap; 
+, H, 1, H;
<=, t317, t318, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t318, 0, t324;
+, t324, 0, t325;
+, t317, t324, t326; // pos inicial del primero caracter de la cadena
=>, t326, t327, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t328;
+, H, 1, t329;
<=, t328, t329, heap; 
+, H, 1, H;
+, H, 1, H;
L134:
jl, 0, t325, L135;
jmp, , , L136;
L135:
<=, H, t327, heap; // guardando caracterr actual
+, H, 1, H;
-, t326, 1, t326;
=>, t326, t327, heap;
-, t325, 1, t325;
jmp, , , L134;
L136:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t329, t324, heap;
jmp, , , L137;
L130:
// -------------------------------- crear cadena de 0 ----------------
+, H, 0, t328; // inicio cad1 (inversa)
+, H, 1, t329;
<=, t328, t329, heap;
+, H, 1, H;
<=, t329, 0, heap;
+, H, 1, H;
<=, H, 48, heap;
+, H, 1, H;
<=, H, 36, heap;
+, H, 1, H;
L137:
// -------------------------- Concatenar parte entera con punto y parte decimal --------------------
//Iniciando a concatnar cadenas 
=>, t314, t330, heap;
=>, t330, t331, heap; // size cadena1
+, t330, 1, t332; // pos 0 de la cadena 1
=>, t328, t333, heap;
=>, t333, t334, heap; // size cadena2
+, t333, 1, t335; // pos 0 de la cadena 2
+, t331, t334, t336; // size de la nueva cadena
=>, t332, t337, heap; // primer caracter de la cadena 1
=>, t335, t338, heap; // primer caracter de la cadena 2
+, H, 0, t339; // posicion de retorno de la cadena
+, H, 1, t340;
<=, t339, t340, heap;
+, H, 1, H;
<=, H, t336, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L138;
L138:
jne, t337, 36, L139;
jmp, , , L140;
jmp, , , L139;
L139:
<=, H, t337, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t332, 1, t332;
=>, t332, t337, heap;
jmp, , , L138;
jmp, , , L140;
L140:
jmp, , , L141;
L141:
jne, t338, 36, L142;
jmp, , , L143;
jmp, , , L142;
L142:
<=, H, t338, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t335, 1, t335;
=>, t335, t338, heap;
jmp, , , L141;
jmp, , , L143;
L143:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t281, t341, heap;
=>, t341, t342, heap; // size cadena1
+, t341, 1, t343; // pos 0 de la cadena 1
=>, t339, t344, heap;
=>, t344, t345, heap; // size cadena2
+, t344, 1, t346; // pos 0 de la cadena 2
+, t342, t345, t347; // size de la nueva cadena
=>, t343, t348, heap; // primer caracter de la cadena 1
=>, t346, t349, heap; // primer caracter de la cadena 2
+, H, 0, t350; // posicion de retorno de la cadena
+, H, 1, t351;
<=, t350, t351, heap;
+, H, 1, H;
<=, H, t347, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L144;
L144:
jne, t348, 36, L145;
jmp, , , L146;
jmp, , , L145;
L145:
<=, H, t348, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t343, 1, t343;
=>, t343, t348, heap;
jmp, , , L144;
jmp, , , L146;
L146:
jmp, , , L147;
L147:
jne, t349, 36, L148;
jmp, , , L149;
jmp, , , L148;
L148:
<=, H, t349, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t346, 1, t346;
=>, t346, t349, heap;
jmp, , , L147;
jmp, , , L149;
L149:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t350, t352, heap;
=>, t352, t353, heap; // size cadena1
+, t352, 1, t354; // pos 0 de la cadena 1
=>, t284, t355, heap;
=>, t355, t356, heap; // size cadena2
+, t355, 1, t357; // pos 0 de la cadena 2
+, t353, t356, t358; // size de la nueva cadena
=>, t354, t359, heap; // primer caracter de la cadena 1
=>, t357, t360, heap; // primer caracter de la cadena 2
+, H, 0, t361; // posicion de retorno de la cadena
+, H, 1, t362;
<=, t361, t362, heap;
+, H, 1, H;
<=, H, t358, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L150;
L150:
jne, t359, 36, L151;
jmp, , , L152;
jmp, , , L151;
L151:
<=, H, t359, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t354, 1, t354;
=>, t354, t359, heap;
jmp, , , L150;
jmp, , , L152;
L152:
jmp, , , L153;
L153:
jne, t360, 36, L154;
jmp, , , L155;
jmp, , , L154;
L154:
<=, H, t360, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t357, 1, t357;
=>, t357, t360, heap;
jmp, , , L153;
jmp, , , L155;
L155:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t276, t363, heap;
=>, t363, t364, heap; // size cadena1
+, t363, 1, t365; // pos 0 de la cadena 1
=>, t361, t366, heap;
=>, t366, t367, heap; // size cadena2
+, t366, 1, t368; // pos 0 de la cadena 2
+, t364, t367, t369; // size de la nueva cadena
=>, t365, t370, heap; // primer caracter de la cadena 1
=>, t368, t371, heap; // primer caracter de la cadena 2
+, H, 0, t372; // posicion de retorno de la cadena
+, H, 1, t373;
<=, t372, t373, heap;
+, H, 1, H;
<=, H, t369, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L156;
L156:
jne, t370, 36, L157;
jmp, , , L158;
jmp, , , L157;
L157:
<=, H, t370, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t365, 1, t365;
=>, t365, t370, heap;
jmp, , , L156;
jmp, , , L158;
L158:
jmp, , , L159;
L159:
jne, t371, 36, L160;
jmp, , , L161;
jmp, , , L160;
L160:
<=, H, t371, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t368, 1, t368;
=>, t368, t371, heap;
jmp, , , L159;
jmp, , , L161;
L161:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t376; // pos del arreglo 
=>, t376, t377, stack; //apuntador al heap del arreglo
=>, t377, t378, heap; // apuntador del heap al heap donde inicia la cadena
=>, t378, t374, heap; // size del arreglo texto
+, t378, 1, t375; // pos 0 donde inicia el arreglo texto
=>, t372, t379, heap; // pos que apunta al size de la cadena
=>, t379, t380, heap; // size de la cadena
+, t379, 1, t381; // Pos 0 de la cadena
=>, t381, t382, heap; // sacandor el caracter del heap cadena
jle, t380, t374, L162;
jmp, , , L163;
jmp, , , L162;
L162:
jne, t382, 36, L164;
jmp, , , L165;
jmp, , , L164;
L164:
<=, t375, t382, heap; // guardando el caracter 
+, t375, 1, t375; // incremnetnado la pos del arreglo
+, t381, 1, t381; // incrementando la pos de la cadena
=>, t381, t382, heap; // sacandor el caracter del heap cadena
jmp, , , L162;
jmp, , , L165;
L165:
jmp, , , L163;
L163:
+, P, 2, t383;
=>, t383, t384, stack; 
=>, t384, t385, heap; 
=>, t385, t386, heap; // valor de size del arreglo texto
+, t385, 1, t387; // apuntador donde inicia el arreglo texto
=>, t387, t388, heap; // primer caracter del arreglo texto
+, H, 0, t389;
+, H, 1, t390;
<=, t389, t390, heap; 
+, H, 1, H;
+, 0, 0, t391;
<=, H, t391, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L166:
jne, t388, 36, L167;
jmp, , , L168;
L167:
<=, H, t388, heap; // ingresando el caracter 
+, H, 1, H;
+, t391, 1, t391; // incrementando en uno el size de la nueva cadena
+, t387, 1, t387;
=>, t387, t388, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L166;
L168:
<=, t390, t391, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t389);

L3:
end, , Operaciones_vacio_aritmeticas




begin, , , Operaciones_vacio_operaciones_relacionales

// Resolviendo una cadena 
+, H, 0, t392; //apuntaodr a cadena 
+, H, 1, t393; //apu donde inicia la cadena
<=, t392, t393, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 36, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t394; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t392);
-, 2, 10, t395;
jge, t395, 0, L171;
jmp, , , L172;
L171:

// Resolviendo una cadena 
+, H, 0, t396; //apuntaodr a cadena 
+, H, 1, t397; //apu donde inicia la cadena
<=, t396, t397, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t398; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t396);
jmp, , , L170; // salida del if
L172:

+, 15, 8, t399;
-, t399, 12, t400;
-, 22, 12, t401;
*, 5, 2, t402;
+, t401, t402, t403;
-, t403, 9, t404;
je, t400, t404, L174;
jmp, , , L175;
L174:

-, 11, 2, t405;
jne, 10, t405, L177;
jmp, , , L178;
L177:

// Resolviendo una cadena 
+, H, 0, t406; //apuntaodr a cadena 
+, H, 1, t407; //apu donde inicia la cadena
<=, t406, t407, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 17, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t408; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 69, heap; //guardadndo E
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 84, heap; //guardadndo T
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t406);
jmp, , , L176; // salida del if
L178:

// Resolviendo una cadena 
+, H, 0, t409; //apuntaodr a cadena 
+, H, 1, t410; //apu donde inicia la cadena
<=, t409, t410, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t411; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t409);
L176:
jmp, , , L173; // salida del if
L175:

je, 1, 1, L180;
jmp, , , L181;
L180:

// Resolviendo una cadena 
+, H, 0, t412; //apuntaodr a cadena 
+, H, 1, t413; //apu donde inicia la cadena
<=, t412, t413, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t414; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t412);
jmp, , , L179; // salida del if
L181:

// Resolviendo una cadena 
+, H, 0, t415; //apuntaodr a cadena 
+, H, 1, t416; //apu donde inicia la cadena
<=, t415, t416, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t417; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t415);
L179:
L173:
L170:

L169:
end, , Operaciones_vacio_operaciones_relacionales




begin, , , Operaciones_vacio_operaciones_logicas

// Resolviendo una cadena 
+, H, 0, t418; //apuntaodr a cadena 
+, H, 1, t419; //apu donde inicia la cadena
<=, t418, t419, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 32, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t420; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 54, heap; //guardadndo 6
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 76, heap; //guardadndo L
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 103, heap; //guardadndo g
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t418);
*, 15, 2, t421;
/, 98, 2, t424;
-, 6, 1, t425;
je, 15, 14, L184;
jmp, , , L185;
L185:

jge, t421, 15, L186;
jmp, , , L187;
L186:

+, 1, 0, t422;
jmp, , , L191;
L187:

+, 0, 0, t422;
jmp, , , L191;
jmp, , , L191;
L191:
jl, 12, 24, L188;
jmp, , , L189;
L188:

+, 1, 0, t423;
jmp, , , L192;
L189:

+, 0, 0, t423;
jmp, , , L192;
jmp, , , L192;
L192:
jne, t422, t423, L193;jmp, , , L194;
L194:

je, t424, 15, L195;
jmp, , , L196;
L196:

jne, 15, t425, L197;
jmp, , , L198;



L184:
L193:
L195:
L198:

// Resolviendo una cadena 
+, H, 0, t426; //apuntaodr a cadena 
+, H, 1, t427; //apu donde inicia la cadena
<=, t426, t427, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 17, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t428; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 69, heap; //guardadndo E
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 84, heap; //guardadndo T
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t426);
jmp, , , L183; // salida del if
L197:

// Resolviendo una cadena 
+, H, 0, t429; //apuntaodr a cadena 
+, H, 1, t430; //apu donde inicia la cadena
<=, t429, t430, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t431; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t429);
L183:

L182:
end, , Operaciones_vacio_operaciones_logicas




begin, , , Operaciones_vacio_operaciones_conjuntas

// Resolviendo una cadena 
+, H, 0, t432; //apuntaodr a cadena 
+, H, 1, t433; //apu donde inicia la cadena
<=, t432, t433, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 24, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t434; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 55, heap; //guardadndo 7
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 106, heap; //guardadndo j
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t432);
*, 5, 3, t435;
-, t435, 1, t436;
-, 6, 1, t437;
je, t436, 14, L201;
jmp, , , L202;
L202:

je, 15, t437, L203;
jmp, , , L204;

L203:

// Resolviendo una cadena 
+, H, 0, t438; //apuntaodr a cadena 
+, H, 1, t439; //apu donde inicia la cadena
<=, t438, t439, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t440; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t438);
jmp, , , L200; // salida del if
L201:
L204:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t441; // pos de var
<=, t441, 41, stack; // asignando a var
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t442; // pos de var2
<=, t442, 954, stack; // asignando a var2
// ------------------------ Creando arreglo local salida
+, P, 3, t443; //pos de arreglo salida
<=, t443, H, stack; // ingrensando al stack apunt del heap para salida
+, H, 1, t444;
<=, H, t444, heap; //insetnado donde inicia el arreglo salida
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t445; //calculando el n real
-, t445, 0, t446; //iReal columna 0
+, t446, 1, t446; //size del arreglo salida
<=, H, t446, heap; // insertando el tamanio del arreglo linealizado salida
+, H, 1, H;
+, h, t446, h; // reservnado el espacio del arreglo salida
+, P, 3, t449; // pos del arreglo 
=>, t449, t450, stack; //apuntador al heap del arreglo
=>, t450, t451, heap; // apuntador del heap al heap donde inicia la cadena
=>, t451, t447, heap; // size del arreglo salida
+, t451, 1, t448; // pos 0 donde inicia el arreglo salida
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t452; // pos de var
=>, t452, t453, stack; // valor de lo que trae en el stack var
jne, 0, t453, L205; //1546545456
jmp, , , L206;
L205:
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t454; // inicio cad1 (inversa)
+, H, 1, t455;
<=, t454, t455, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t453, 0, t456;
+, 0, 0, t457;
+, 0, 0, t458;
+, 0, 0, t459;
+, t453, 0, t460;
L207:
jl, t457, t456, L208;
jmp, , , L209;
L208:
%%, t460, 0, t458;
+, t458, 48, t461;
<=, H, t461, heap;
+, H, 1, H; 
##, t460, 0, t460;
+, t457, 1, t457;
jmp, , , L207;
L209:
<=, H, 36, heap; 
+, H, 1, H;
<=, t455, t456, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t456, 0, t462;
+, t462, 0, t463;
+, t455, t462, t464; // pos inicial del primero caracter de la cadena
=>, t464, t465, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t466;
+, H, 1, t467;
<=, t466, t467, heap; 
+, H, 1, H;
+, H, 1, H;
L210:
jl, 0, t463, L211;
jmp, , , L212;
L211:
<=, H, t465, heap; // guardando caracterr actual
+, H, 1, H;
-, t464, 1, t464;
=>, t464, t465, heap;
-, t463, 1, t463;
jmp, , , L210;
L212:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t467, t462, heap;
jmp, , , L213;
L206:
// -------------------------------- crear cadena de 0 ----------------
+, H, 0, t466; // inicio cad1 (inversa)
+, H, 1, t467;
<=, t466, t467, heap;
+, H, 1, H;
<=, t467, 0, heap;
+, H, 1, H;
<=, H, 48, heap;
+, H, 1, H;
<=, H, 36, heap;
+, H, 1, H;
L213:
=>, t466, t468, heap; // pos que apunta al size de la cadena
=>, t468, t469, heap; // size de la cadena
+, t468, 1, t470; // Pos 0 de la cadena
=>, t470, t471, heap; // sacandor el caracter del heap cadena
jle, t469, t447, L214;
jmp, , , L215;
jmp, , , L214;
L214:
jne, t471, 36, L216;
jmp, , , L217;
jmp, , , L216;
L216:
<=, t448, t471, heap; // guardando el caracter 
+, t448, 1, t448; // incremnetnado la pos del arreglo
+, t470, 1, t470; // incrementando la pos de la cadena
=>, t470, t471, heap; // sacandor el caracter del heap cadena
jmp, , , L214;
jmp, , , L217;
L217:
jmp, , , L215;
L215:
+, P, 3, t472;
=>, t472, t473, stack; 
=>, t473, t474, heap; 
=>, t474, t475, heap; // valor de size del arreglo salida
+, t474, 1, t476; // apuntador donde inicia el arreglo salida
=>, t476, t477, heap; // primer caracter del arreglo salida
+, H, 0, t478;
+, H, 1, t479;
<=, t478, t479, heap; 
+, H, 1, H;
+, 0, 0, t480;
<=, H, t480, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L218:
jne, t477, 36, L219;
jmp, , , L220;
L219:
<=, H, t477, heap; // ingresando el caracter 
+, H, 1, H;
+, t480, 1, t480; // incrementando en uno el size de la nueva cadena
+, t476, 1, t476;
=>, t476, t477, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L218;
L220:
<=, t479, t480, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t481; // pos de var2
=>, t481, t482, stack; // valor de lo que trae en el stack var2
// Resolviendo una cadena 
+, H, 0, t483; //apuntaodr a cadena 
+, H, 1, t484; //apu donde inicia la cadena
<=, t483, t484, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t485; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t486; //apuntaodr a cadena 
+, H, 1, t487; //apu donde inicia la cadena
<=, t486, t487, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t488; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
jne, 0, t482, L221; //1546545456
jmp, , , L222;
L221:
// -------------------------------- Inicio un casteo a entero ----------------
+, H, 0, t489; // inicio cad1 (inversa)
+, H, 1, t490;
<=, t489, t490, heap;
+, H, 1, H;
+, H, 1, H;
//----- convertir a entero
log10, t482, 0, t491;
+, 0, 0, t492;
+, 0, 0, t493;
+, 0, 0, t494;
+, t482, 0, t495;
L223:
jl, t492, t491, L224;
jmp, , , L225;
L224:
%%, t495, 0, t493;
+, t493, 48, t496;
<=, H, t496, heap;
+, H, 1, H; 
##, t495, 0, t495;
+, t492, 1, t492;
jmp, , , L223;
L225:
<=, H, 36, heap; 
+, H, 1, H;
<=, t490, t491, heap; // size de la cadena del numero numero
// ---------- Voltear la cadena resultante---------
+, t491, 0, t497;
+, t497, 0, t498;
+, t490, t497, t499; // pos inicial del primero caracter de la cadena
=>, t499, t500, heap; // caracter acutla de la cadena
// ----------- Inicinado cadena resultante ---------
+, H, 0, t501;
+, H, 1, t502;
<=, t501, t502, heap; 
+, H, 1, H;
+, H, 1, H;
L226:
jl, 0, t498, L227;
jmp, , , L228;
L227:
<=, H, t500, heap; // guardando caracterr actual
+, H, 1, H;
-, t499, 1, t499;
=>, t499, t500, heap;
-, t498, 1, t498;
jmp, , , L226;
L228:
<=, H, 36, heap; // caracter de escape de la cadena resultante 
+, H, 1, H;
<=, t502, t497, heap;
jmp, , , L229;
L222:
// -------------------------------- crear cadena de 0 ----------------
+, H, 0, t501; // inicio cad1 (inversa)
+, H, 1, t502;
<=, t501, t502, heap;
+, H, 1, H;
<=, t502, 0, heap;
+, H, 1, H;
<=, H, 48, heap;
+, H, 1, H;
<=, H, 36, heap;
+, H, 1, H;
L229:
//Iniciando a concatnar cadenas 
=>, t483, t503, heap;
=>, t503, t504, heap; // size cadena1
+, t503, 1, t505; // pos 0 de la cadena 1
=>, t501, t506, heap;
=>, t506, t507, heap; // size cadena2
+, t506, 1, t508; // pos 0 de la cadena 2
+, t504, t507, t509; // size de la nueva cadena
=>, t505, t510, heap; // primer caracter de la cadena 1
=>, t508, t511, heap; // primer caracter de la cadena 2
+, H, 0, t512; // posicion de retorno de la cadena
+, H, 1, t513;
<=, t512, t513, heap;
+, H, 1, H;
<=, H, t509, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L230;
L230:
jne, t510, 36, L231;
jmp, , , L232;
jmp, , , L231;
L231:
<=, H, t510, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t505, 1, t505;
=>, t505, t510, heap;
jmp, , , L230;
jmp, , , L232;
L232:
jmp, , , L233;
L233:
jne, t511, 36, L234;
jmp, , , L235;
jmp, , , L234;
L234:
<=, H, t511, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t508, 1, t508;
=>, t508, t511, heap;
jmp, , , L233;
jmp, , , L235;
L235:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t512, t514, heap;
=>, t514, t515, heap; // size cadena1
+, t514, 1, t516; // pos 0 de la cadena 1
=>, t486, t517, heap;
=>, t517, t518, heap; // size cadena2
+, t517, 1, t519; // pos 0 de la cadena 2
+, t515, t518, t520; // size de la nueva cadena
=>, t516, t521, heap; // primer caracter de la cadena 1
=>, t519, t522, heap; // primer caracter de la cadena 2
+, H, 0, t523; // posicion de retorno de la cadena
+, H, 1, t524;
<=, t523, t524, heap;
+, H, 1, H;
<=, H, t520, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L236;
L236:
jne, t521, 36, L237;
jmp, , , L238;
jmp, , , L237;
L237:
<=, H, t521, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t516, 1, t516;
=>, t516, t521, heap;
jmp, , , L236;
jmp, , , L238;
L238:
jmp, , , L239;
L239:
jne, t522, 36, L240;
jmp, , , L241;
jmp, , , L240;
L240:
<=, H, t522, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t519, 1, t519;
=>, t519, t522, heap;
jmp, , , L239;
jmp, , , L241;
L241:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
//Iniciando a concatnar cadenas 
=>, t478, t525, heap;
=>, t525, t526, heap; // size cadena1
+, t525, 1, t527; // pos 0 de la cadena 1
=>, t523, t528, heap;
=>, t528, t529, heap; // size cadena2
+, t528, 1, t530; // pos 0 de la cadena 2
+, t526, t529, t531; // size de la nueva cadena
=>, t527, t532, heap; // primer caracter de la cadena 1
=>, t530, t533, heap; // primer caracter de la cadena 2
+, H, 0, t534; // posicion de retorno de la cadena
+, H, 1, t535;
<=, t534, t535, heap;
+, H, 1, H;
<=, H, t531, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L242;
L242:
jne, t532, 36, L243;
jmp, , , L244;
jmp, , , L243;
L243:
<=, H, t532, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t527, 1, t527;
=>, t527, t532, heap;
jmp, , , L242;
jmp, , , L244;
L244:
jmp, , , L245;
L245:
jne, t533, 36, L246;
jmp, , , L247;
jmp, , , L246;
L246:
<=, H, t533, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t530, 1, t530;
=>, t530, t533, heap;
jmp, , , L245;
jmp, , , L247;
L247:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 3, t538; // pos del arreglo 
=>, t538, t539, stack; //apuntador al heap del arreglo
=>, t539, t540, heap; // apuntador del heap al heap donde inicia la cadena
=>, t540, t536, heap; // size del arreglo salida
+, t540, 1, t537; // pos 0 donde inicia el arreglo salida
=>, t534, t541, heap; // pos que apunta al size de la cadena
=>, t541, t542, heap; // size de la cadena
+, t541, 1, t543; // Pos 0 de la cadena
=>, t543, t544, heap; // sacandor el caracter del heap cadena
jle, t542, t536, L248;
jmp, , , L249;
jmp, , , L248;
L248:
jne, t544, 36, L250;
jmp, , , L251;
jmp, , , L250;
L250:
<=, t537, t544, heap; // guardando el caracter 
+, t537, 1, t537; // incremnetnado la pos del arreglo
+, t543, 1, t543; // incrementando la pos de la cadena
=>, t543, t544, heap; // sacandor el caracter del heap cadena
jmp, , , L248;
jmp, , , L251;
L251:
jmp, , , L249;
L249:
+, P, 3, t545;
=>, t545, t546, stack; 
=>, t546, t547, heap; 
=>, t547, t548, heap; // valor de size del arreglo salida
+, t547, 1, t549; // apuntador donde inicia el arreglo salida
=>, t549, t550, heap; // primer caracter del arreglo salida
+, H, 0, t551;
+, H, 1, t552;
<=, t551, t552, heap; 
+, H, 1, H;
+, 0, 0, t553;
<=, H, t553, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L252:
jne, t550, 36, L253;
jmp, , , L254;
L253:
<=, H, t550, heap; // ingresando el caracter 
+, H, 1, H;
+, t553, 1, t553; // incrementando en uno el size de la nueva cadena
+, t549, 1, t549;
=>, t549, t550, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L252;
L254:
<=, t552, t553, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t551);
+, P, 3, t554;
=>, t554, t555, stack; 
=>, t555, t556, heap; 
=>, t556, t557, heap; // valor de size del arreglo salida
+, t556, 1, t558; // apuntador donde inicia el arreglo salida
=>, t558, t559, heap; // primer caracter del arreglo salida
+, H, 0, t560;
+, H, 1, t561;
<=, t560, t561, heap; 
+, H, 1, H;
+, 0, 0, t562;
<=, H, t562, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L256:
jne, t559, 36, L257;
jmp, , , L258;
L257:
<=, H, t559, heap; // ingresando el caracter 
+, H, 1, H;
+, t562, 1, t562; // incrementando en uno el size de la nueva cadena
+, t558, 1, t558;
=>, t558, t559, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L256;
L258:
<=, t561, t562, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t563; //apuntaodr a cadena 
+, H, 1, t564; //apu donde inicia la cadena
<=, t563, t564, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t565; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 57, heap; //guardadndo 9
+, H, 1, H;
<=, H, 53, heap; //guardadndo 5
+, H, 1, H;
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
// ------------ Obtenieido suma de caracteres de una cadena --------
=>, t563, t566, heap; // apunt al heap donde inicia la cadena
+, t566, 1, t567; // pos donde incia la cadena
=>, t567, t568, heap; // valor caracter  de la cadena
+, 0, 0, t569; //acumulador de la cadena
jmp, , , L261;
L261: //etiquera ciclo suma cadena
jne, t568, 36, L262;
jmp, , , L263;
L262:
+, t569, t568, t569; // sumando los caracteres 
+, t567, 1, t567; // sumando una posicion
=>, t567, t568, heap; // obteniendo el valor del caracter 
jmp, , , L261;
L263:
// ------------ Obtenieido suma de caracteres de una cadena --------
=>, t560, t570, heap; // apunt al heap donde inicia la cadena
+, t570, 1, t571; // pos donde incia la cadena
=>, t571, t572, heap; // valor caracter  de la cadena
+, 0, 0, t573; //acumulador de la cadena
jmp, , , L264;
L264: //etiquera ciclo suma cadena
jne, t572, 36, L265;
jmp, , , L266;
L265:
+, t573, t572, t573; // sumando los caracteres 
+, t571, 1, t571; // sumando una posicion
=>, t571, t572, heap; // obteniendo el valor del caracter 
jmp, , , L264;
L266:
je, t573, t569, L259;
jmp, , , L260;
L259:

// Resolviendo una cadena 
+, H, 0, t574; //apuntaodr a cadena 
+, H, 1, t575; //apu donde inicia la cadena
<=, t574, t575, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 16, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t576; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 57, heap; //guardadndo 9
+, H, 1, H;
<=, H, 53, heap; //guardadndo 5
+, H, 1, H;
<=, H, 52, heap; //guardadndo 4
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t574);
jmp, , , L255; // salida del if
L260:

// Resolviendo una cadena 
+, H, 0, t577; //apuntaodr a cadena 
+, H, 1, t578; //apu donde inicia la cadena
<=, t577, t578, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 19, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t579; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t577);
L255:
L200:

L199:
end, , Operaciones_vacio_operaciones_conjuntas




begin, , , Inicio_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t580; // pos de op
<=, t580, h, stack; //guardando referencia del heap para el objeto op
+, h, 1, t581; // guardo la posicion donde inicia el objeto 
<=, h, t581, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 0, h; // reservando espacio para el objeto op
//Ingresando referencia al this del objeto op
+, p, 0, t582; // pos de op
=>, t582, t583, stack; // obteniendo apuntador de op
+, p, 2, t584; // simulando cambio de ambito
+, t584, 0, t585; //pos del this de op
<=, t585, t583, stack; // insertando apuntador del heap al stack del obeto op
// No posee parametros 
+, p, 2, p; // simulando cambio de ambito
call, , , Operaciones_vacio_operaciones;
-, p, 2, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t586; // pos del objeto
=>, t586, t588, stack; //apuntador al heap del obejto
+, P, 6, t589;
+, t589, 0, t590;
<=, t590, t588, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 6, P;
call, , , Operaciones_vacio_aritmeticas;
+, P, 5, t591;
=>, t591, t592, stack; // valor del return
-, P, 6, P;
=>, t591, t593, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 0, t594; // pos del objeto
=>, t594, t596, stack; //apuntador al heap del obejto
+, P, 2, t597;
+, t597, 0, t598;
<=, t598, t596, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 2, P;
call, , , Operaciones_vacio_operaciones_relacionales;
+, P, 1, t599;
=>, t599, t600, stack; // valor del return
-, P, 2, P;
=>, t599, t601, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 0, t602; // pos del objeto
=>, t602, t604, stack; //apuntador al heap del obejto
+, P, 2, t605;
+, t605, 0, t606;
<=, t606, t604, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 2, P;
call, , , Operaciones_vacio_operaciones_logicas;
+, P, 1, t607;
=>, t607, t608, stack; // valor del return
-, P, 2, P;
=>, t607, t609, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 0, t610; // pos del objeto
=>, t610, t612, stack; //apuntador al heap del obejto
+, P, 5, t613;
+, t613, 0, t614;
<=, t614, t612, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 5, P;
call, , , Operaciones_vacio_operaciones_conjuntas;
+, P, 4, t615;
=>, t615, t616, stack; // valor del return
-, P, 5, P;
=>, t615, t617, stack; // valor a retoranar del acceso
// ----------- Instancia a una variable local --------------
+, p, 1, t618; // pos de fun
<=, t618, h, stack; //guardando referencia del heap para el objeto fun
+, h, 1, t619; // guardo la posicion donde inicia el objeto 
<=, h, t619, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 0, h; // reservando espacio para el objeto fun
//Ingresando referencia al this del objeto fun
+, p, 1, t620; // pos de fun
=>, t620, t621, stack; // obteniendo apuntador de fun
+, p, 2, t622; // simulando cambio de ambito
+, t622, 0, t623; //pos del this de fun
<=, t623, t621, stack; // insertando apuntador del heap al stack del obeto fun
// No posee parametros 
+, p, 2, p; // simulando cambio de ambito
call, , , Funciones_vacio_funciones;
-, p, 2, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 1, t624; // pos del objeto
=>, t624, t626, stack; //apuntador al heap del obejto
+, P, 3, t627;
+, t627, 0, t628;
<=, t628, t626, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 3, P;
call, , , Funciones_vacio_saludo;
+, P, 2, t629;
=>, t629, t630, stack; // valor del return
-, P, 3, P;
=>, t629, t631, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 1, t632; // pos del objeto
=>, t632, t634, stack; //apuntador al heap del obejto
+, P, 7, t635;
+, t635, 0, t636;
<=, t636, t634, stack; // pasadon como refeenria el valor del this
// No posee parametros 
+, P, 7, P;
call, , , Funciones_vacio_ciclo_vida;
+, P, 6, t637;
=>, t637, t638, stack; // valor del return
-, P, 7, P;
=>, t637, t639, stack; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 1, t640; // pos del objeto
=>, t640, t642, stack; //apuntador al heap del obejto
+, P, 4, t643;
+, t643, 0, t644;
<=, t644, t642, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 4, t645; // size de funcion actual
+, t645, 1, t646; //pos del parametro 1
<=, t646, 10, stack; // asignado al stack el parametro
+, P, 4, P;
call, , , Funciones_entero_factorial2_entero;
+, P, 3, t647;
=>, t647, t648, stack; // valor del return
-, P, 4, P;
=>, t647, t649, stack; // valor a retoranar del acceso
print("%d", t649);

L267:
end, , Inicio_PRINCIPAL




begin, , , Funciones_vacio_funciones


L268:
end, , Funciones_vacio_funciones




begin, , , Funciones_entero_factorial2_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t650; // pos de n
=>, t650, t651, stack; // valor de lo que trae en el stack n
je, t651, 0, L271;
jmp, , , L272;
L271:

// RESOLVIENDO UN RETORNO
+, P, 3, t652; // pos de retorno de a funcion Funciones_entero_factorial2_entero
<=, t652, 1, stack; //asignando el retorno con su valor
jmp, , , L269;
jmp, , , L270; // salida del if
L272:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t653; // pos de i
+, P, 0, t654;
=>, t654, t655, stack; 
+, P, 4, t656;
+, t655, 0, t657;
<=, t656, t655, stack; 
// Asignando parametros de llamada a funcion  
+, p, 4, t658; // size de funcion actual
+, t658, 1, t659; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t660; // pos de n
=>, t660, t661, stack; // valor de lo que trae en el stack n
-, t661, 1, t662;
<=, t659, t662, stack; // asignado al stack el parametro
+, P, 4, P;
call, , , Funciones_entero_factorial2_entero;
+, P, 3, t663;
=>, t663, t664, stack; // valor del return
-, P, 4, P;
<=, t653, t664, stack; // asignando a i
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t665; // pos de n
=>, t665, t666, stack; // valor de lo que trae en el stack n
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t667; // pos de i
=>, t667, t668, stack; // valor de lo que trae en el stack i
*, t666, t668, t669;
+, P, 3, t670; // pos de retorno de a funcion Funciones_entero_factorial2_entero
<=, t670, t669, stack; //asignando el retorno con su valor
jmp, , , L269;
L270:

L269:
end, , Funciones_entero_factorial2_entero




begin, , , Funciones_entero_factorial_entero

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t671; // pos de fact
<=, t671, 1, stack; // asignando a fact
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t672; // pos de n
=>, t672, t673, stack; // valor de lo que trae en el stack n
je, t673, 0, L275;
jmp, , , L276;
L275:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t674; // pos de fact
<=, t674, 1, stack; // asignando a fact
jmp, , , L274; // salida del if
L276:

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t675; // pos de n
=>, t675, t676, stack; // valor de lo que trae en el stack n
 // ------------------ Inicio ciclo repetir contando -----------------
+, P, 3, t677; // pos de k
<=, t677, 1, stack; // asignando con el valor de desde la vairable k
=>, t677, t678, stack; // obteniendo el valor de  desde k
jne, t678, t676, L277;
jmp, , , L278;
L277:
jl, t678, t676, L279;
jmp, , , L280;
L279:
+, 1, 0, t679;
jmp, , , L281;
L280:
+, -1, 0, t679;
jmp, , , L281;
L281:
-, t676, t678, t680;
*, t680, t679, t680;
+, 0, 0, t681; // iniciando la viairrble pivote del ciclo repetir contando
L282:
jle, t681, t680, L283;
jmp, , , L284;
L283:
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t682; // pos de fact
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t683; // pos de fact
=>, t683, t684, stack; // valor de lo que trae en el stack fact
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t685; // pos de k
=>, t685, t686, stack; // valor de lo que trae en el stack k
*, t684, t686, t687;
<=, t682, t687, stack; // asignando a fact
L285:
+, t678, t679, t678; // nuevo valor de la variable del ciclo k
+, t681, 1, t681;
<=, t677, t678, stack; // asignando a k
jmp, , , L282;
L284:
L278:
L286:
 // ------------------ Fin ciclo repetir contando-----------------
L274:
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t688; // pos de fact
=>, t688, t689, stack; // valor de lo que trae en el stack fact
+, P, 4, t690; // pos de retorno de a funcion Funciones_entero_factorial_entero
<=, t690, t689, stack; //asignando el retorno con su valor
jmp, , , L273;

L273:
end, , Funciones_entero_factorial_entero




begin, , , Funciones_vacio_saludo

// Resolviendo una cadena 
+, H, 0, t691; //apuntaodr a cadena 
+, H, 1, t692; //apu donde inicia la cadena
<=, t691, t692, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 10, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t693; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 48, heap; //guardadndo 0
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t691);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t694; // pos de conta
<=, t694, 0, stack; // asignando a conta
// ---------- Resolver Hacer Mientras ----------- 
L288:
// --------------------- Inicio evaluar_si --------------------------
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t695; // pos de conta
=>, t695, t696, stack; // valor de lo que trae en el stack conta
je, t696, 0, L292; // verdadero del caso 1
jmp, , , L296; // falsa del caso 1
L296:
je, t696, 1, L293; // verdadero del caso 2
jmp, , , L297; // falsa del caso 2
L297:
je, t696, 2, L294; // verdadero del caso 3
jmp, , , L298; // falsa del caso 3
L298:
je, t696, 3, L295; // verdadero del caso 4
jmp, , , L299; // falsa del caso 4
L299:
jmp, , , L300; // ir al por defecto
L292:
// Resolviendo una cadena 
+, H, 0, t697; //apuntaodr a cadena 
+, H, 1, t698; //apu donde inicia la cadena
<=, t697, t698, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t699; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 69, heap; //guardadndo E
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t697);
jmp, , , L291; // haciendo un romper 
L293:
// Resolviendo una cadena 
+, H, 0, t700; //apuntaodr a cadena 
+, H, 1, t701; //apu donde inicia la cadena
<=, t700, t701, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 7, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t702; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t700);
jmp, , , L291; // haciendo un romper 
L294:
// Resolviendo una cadena 
+, H, 0, t703; //apuntaodr a cadena 
+, H, 1, t704; //apu donde inicia la cadena
<=, t703, t704, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 3, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t705; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t703);
jmp, , , L291; // haciendo un romper 
L295:
// Resolviendo una cadena 
+, H, 0, t706; //apuntaodr a cadena 
+, H, 1, t707; //apu donde inicia la cadena
<=, t706, t707, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 11, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t708; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 79, heap; //guardadndo O
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 82, heap; //guardadndo R
+, H, 1, H;
<=, H, 69, heap; //guardadndo E
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 84, heap; //guardadndo T
+, H, 1, H;
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t706);
jmp, , , L291; // haciendo un romper 
L300:
// Resolviendo una cadena 
+, H, 0, t709; //apuntaodr a cadena 
+, H, 1, t710; //apu donde inicia la cadena
<=, t709, t710, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 20, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t711; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 83, heap; //guardadndo S
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 33, heap; //guardadndo !
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t709);
L291: // break de evaluar _si
// --------------------- Fin evaluar_si --------------------------
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t712; // pos de conta
=>, t712, t713, stack; // valor de lo que trae en el stack conta
+, t713, 1, t714;
<=, t712, t714, STACK; // asignando operaicon con unario
L290: //etiqueta del conituar
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t715; // pos de conta
=>, t715, t716, stack; // valor de lo que trae en el stack conta
jl, t716, 4, L301;
jmp, , , L302;
L301:

jmp, , , L288;
L302:

L289:

L287:
end, , Funciones_vacio_saludo




begin, , , Funciones_vacio_ciclo_vida

// Resolviendo una cadena 
+, H, 0, t717; //apuntaodr a cadena 
+, H, 1, t718; //apu donde inicia la cadena
<=, t717, t718, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 14, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t719; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 49, heap; //guardadndo 1
+, H, 1, H;
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 41, heap; //guardadndo )
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 95, heap; //guardadndo _
+, H, 1, H;
<=, H, 118, heap; //guardadndo v
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t717);
// ----------- Instancia a una variable local --------------
+, p, 1, t720; // pos de carlos
<=, t720, h, stack; //guardando referencia del heap para el objeto carlos
+, h, 1, t721; // guardo la posicion donde inicia el objeto 
<=, h, t721, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 5, h; // reservando espacio para el objeto carlos
//Ingresando referencia al this del objeto carlos
+, p, 1, t722; // pos de carlos
=>, t722, t723, stack; // obteniendo apuntador de carlos
+, p, 7, t724; // simulando cambio de ambito
+, t724, 0, t725; //pos del this de carlos
<=, t725, t723, stack; // insertando apuntador del heap al stack del obeto carlos
// Asignando parametros  
+, p, 7, t726; // size de funcion actual
+, t726, 1, t727; //pos del parametro 1
<=, t727, 16, stack; // asignado al stack el parametro
+, p, 7, t728; // size de funcion actual
+, t728, 2, t729; //pos del parametro 2
// declarando parametros  arreglo de tipo nombre2
// ------------------------ Creando arreglo local nombre2
+, P, t729, t730; //pos de arreglo nombre2
<=, t730, H, stack; // ingrensando al stack apunt del heap para nombre2
+, H, 1, t731;
<=, H, t731, heap; //insetnado donde inicia el arreglo nombre2
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t732; //calculando el n real
-, t732, 0, t733; //iReal columna 0
+, t733, 1, t733; //size del arreglo nombre2
<=, H, t733, heap; // insertando el tamanio del arreglo linealizado nombre2
+, H, 1, H;
+, h, t733, h; // reservnado el espacio del arreglo nombre2
// Resolviendo una cadena 
+, H, 0, t734; //apuntaodr a cadena 
+, H, 1, t735; //apu donde inicia la cadena
<=, t734, t735, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t736; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 74, heap; //guardadndo J
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t729, t734, stack; // asignado al stack el parametro
+, p, 7, t737; // size de funcion actual
+, t737, 3, t738; //pos del parametro 3
// declarando parametros  arreglo de tipo apellido2
// ------------------------ Creando arreglo local apellido2
+, P, t738, t739; //pos de arreglo apellido2
<=, t739, H, stack; // ingrensando al stack apunt del heap para apellido2
+, H, 1, t740;
<=, H, t740, heap; //insetnado donde inicia el arreglo apellido2
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t741; //calculando el n real
-, t741, 0, t742; //iReal columna 0
+, t742, 1, t742; //size del arreglo apellido2
<=, H, t742, heap; // insertando el tamanio del arreglo linealizado apellido2
+, H, 1, H;
+, h, t742, h; // reservnado el espacio del arreglo apellido2
// Resolviendo una cadena 
+, H, 0, t743; //apuntaodr a cadena 
+, H, 1, t744; //apu donde inicia la cadena
<=, t743, t744, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t745; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 77, heap; //guardadndo M
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t738, t743, stack; // asignado al stack el parametro
+, p, 7, t746; // size de funcion actual
+, t746, 4, t747; //pos del parametro 4
<=, t747, 77, stack; // asignado al stack el parametro
+, p, 7, p; // simulando cambio de ambito
call, , , Persona_vacio_Persona_entero_caracter_caracter_caracter;
-, p, 7, p; // regresando al ambito acutal

// ----------- Instancia a una variable local --------------
+, p, 2, t748; // pos de Josefina
<=, t748, h, stack; //guardando referencia del heap para el objeto Josefina
+, h, 1, t749; // guardo la posicion donde inicia el objeto 
<=, h, t749, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 5, h; // reservando espacio para el objeto Josefina
//Ingresando referencia al this del objeto Josefina
+, p, 2, t750; // pos de Josefina
=>, t750, t751, stack; // obteniendo apuntador de Josefina
+, p, 7, t752; // simulando cambio de ambito
+, t752, 0, t753; //pos del this de Josefina
<=, t753, t751, stack; // insertando apuntador del heap al stack del obeto Josefina
// Asignando parametros  
+, p, 7, t754; // size de funcion actual
+, t754, 1, t755; //pos del parametro 1
<=, t755, 15, stack; // asignado al stack el parametro
+, p, 7, t756; // size de funcion actual
+, t756, 2, t757; //pos del parametro 2
// declarando parametros  arreglo de tipo nombre2
// ------------------------ Creando arreglo local nombre2
+, P, t757, t758; //pos de arreglo nombre2
<=, t758, H, stack; // ingrensando al stack apunt del heap para nombre2
+, H, 1, t759;
<=, H, t759, heap; //insetnado donde inicia el arreglo nombre2
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t760; //calculando el n real
-, t760, 0, t761; //iReal columna 0
+, t761, 1, t761; //size del arreglo nombre2
<=, H, t761, heap; // insertando el tamanio del arreglo linealizado nombre2
+, H, 1, H;
+, h, t761, h; // reservnado el espacio del arreglo nombre2
// Resolviendo una cadena 
+, H, 0, t762; //apuntaodr a cadena 
+, H, 1, t763; //apu donde inicia la cadena
<=, t762, t763, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t764; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 76, heap; //guardadndo L
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t757, t762, stack; // asignado al stack el parametro
+, p, 7, t765; // size de funcion actual
+, t765, 3, t766; //pos del parametro 3
// declarando parametros  arreglo de tipo apellido2
// ------------------------ Creando arreglo local apellido2
+, P, t766, t767; //pos de arreglo apellido2
<=, t767, H, stack; // ingrensando al stack apunt del heap para apellido2
+, H, 1, t768;
<=, H, t768, heap; //insetnado donde inicia el arreglo apellido2
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t769; //calculando el n real
-, t769, 0, t770; //iReal columna 0
+, t770, 1, t770; //size del arreglo apellido2
<=, H, t770, heap; // insertando el tamanio del arreglo linealizado apellido2
+, H, 1, H;
+, h, t770, h; // reservnado el espacio del arreglo apellido2
// Resolviendo una cadena 
+, H, 0, t771; //apuntaodr a cadena 
+, H, 1, t772; //apu donde inicia la cadena
<=, t771, t772, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t773; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 84, heap; //guardadndo T
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t766, t771, stack; // asignado al stack el parametro
+, p, 7, t774; // size de funcion actual
+, t774, 4, t775; //pos del parametro 4
<=, t775, 70, stack; // asignado al stack el parametro
+, p, 7, p; // simulando cambio de ambito
call, , , Persona_vacio_Persona_entero_caracter_caracter_caracter;
-, p, 7, p; // regresando al ambito acutal

// ----------- Instancia a una variable local --------------
+, p, 3, t776; // pos de Carlitos
<=, t776, h, stack; //guardando referencia del heap para el objeto Carlitos
+, h, 1, t777; // guardo la posicion donde inicia el objeto 
<=, h, t777, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 5, h; // reservando espacio para el objeto Carlitos
//Ingresando referencia al this del objeto Carlitos
+, p, 3, t778; // pos de Carlitos
=>, t778, t779, stack; // obteniendo apuntador de Carlitos
+, p, 7, t780; // simulando cambio de ambito
+, t780, 0, t781; //pos del this de Carlitos
<=, t781, t779, stack; // insertando apuntador del heap al stack del obeto Carlitos
// No posee parametros 
+, p, 7, p; // simulando cambio de ambito
call, , , Persona_vacio_Persona;
-, p, 7, p; // regresando al ambito acutal

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t782; // pos de cont
<=, t782, 0, stack; // asignando a cont
// Resolviendo un repetur mientras
jmp, , ,L304; //regresando a la etiqueral del ciclo repetir- mientras
L304:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t783; // pos de cont
=>, t783, t784, stack; // valor de lo que trae en el stack cont
jl, t784, 4, L305;
jmp, , , L306;
L305:

// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t785; // pos de cont
=>, t785, t786, stack; // valor de lo que trae en el stack cont
+, t786, 1, t787;
<=, t785, t787, STACK; // asignando operaicon con unario
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t788; // pos de cont
=>, t788, t789, stack; // valor de lo que trae en el stack cont
je, t789, 4, L308;
jmp, , , L309;
L308:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t790; // pos de Carlitos
// ----------------- Resolviendo acceso local 
+, P, 1, t791; // pos del objeto
=>, t791, t793, stack; //apuntador al heap del obejto
+, P, 6, t794;
+, t794, 0, t795;
<=, t795, t793, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 6, t796; // size de funcion actual
+, t796, 1, t797; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t798; // pos de Josefina
=>, t798, t799, stack; // valor de lo que trae en el stack Josefina
<=, t797, t799, stack; // asignado al stack el parametro
+, p, 6, t800; // size de funcion actual
+, t800, 2, t801; //pos del parametro 2
// declarando parametros  arreglo de tipo nombre
// ------------------------ Creando arreglo local nombre
+, P, t801, t802; //pos de arreglo nombre
<=, t802, H, stack; // ingrensando al stack apunt del heap para nombre
+, H, 1, t803;
<=, H, t803, heap; //insetnado donde inicia el arreglo nombre
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t804; //calculando el n real
-, t804, 0, t805; //iReal columna 0
+, t805, 1, t805; //size del arreglo nombre
<=, H, t805, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, h, t805, h; // reservnado el espacio del arreglo nombre
// Resolviendo una cadena 
+, H, 0, t806; //apuntaodr a cadena 
+, H, 1, t807; //apu donde inicia la cadena
<=, t806, t807, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t808; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
<=, t801, t806, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Persona_Persona_reproducir_Persona_caracter;
+, P, 5, t809;
=>, t809, t810, stack; // valor del return
-, P, 6, P;
=>, t809, t811, stack; // valor a retoranar del acceso
<=, t790, t811, stack; // asignando a Carlitos
// ----------------- Resolviendo acceso local 
+, P, 2, t812; // pos del objeto
=>, t812, t814, stack; //apuntador al heap del obejto
+, P, 4, t815;
+, t815, 0, t816;
<=, t816, t814, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 4, t817; // size de funcion actual
+, t817, 1, t818; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t819; // pos de Carlos
=>, t819, t820, stack; // valor de lo que trae en el stack Carlos
<=, t818, t820, stack; // asignado al stack el parametro
+, P, 4, P;
call, , , Persona_vacio_matrimonio_Persona;
+, P, 3, t821;
=>, t821, t822, stack; // valor del return
-, P, 4, P;
=>, t821, t823, stack; // valor a retoranar del acceso
// ------------------------ Creando arreglo local text
+, P, 5, t824; //pos de arreglo text
<=, t824, H, stack; // ingrensando al stack apunt del heap para text
+, H, 1, t825;
<=, H, t825, heap; //insetnado donde inicia el arreglo text
+, H, 1, H;
// calculando el tamanho del arreglo
-, 80, 1, t826; //calculando el n real
-, t826, 0, t827; //iReal columna 0
+, t827, 1, t827; //size del arreglo text
<=, H, t827, heap; // insertando el tamanio del arreglo linealizado text
+, H, 1, H;
+, h, t827, h; // reservnado el espacio del arreglo text
+, P, 5, t830; // pos del arreglo 
=>, t830, t831, stack; //apuntador al heap del arreglo
=>, t831, t832, heap; // apuntador del heap al heap donde inicia la cadena
=>, t832, t828, heap; // size del arreglo text
+, t832, 1, t829; // pos 0 donde inicia el arreglo text
// Resolviendo una cadena 
+, H, 0, t833; //apuntaodr a cadena 
+, H, 1, t834; //apu donde inicia la cadena
<=, t833, t834, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 13, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t835; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 78, heap; //guardadndo N
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 72, heap; //guardadndo H
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 106, heap; //guardadndo j
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t833, t836, heap; // pos que apunta al size de la cadena
=>, t836, t837, heap; // size de la cadena
+, t836, 1, t838; // Pos 0 de la cadena
=>, t838, t839, heap; // sacandor el caracter del heap cadena
jle, t837, t828, L310;
jmp, , , L311;
jmp, , , L310;
L310:
jne, t839, 36, L312;
jmp, , , L313;
jmp, , , L312;
L312:
<=, t829, t839, heap; // guardando el caracter 
+, t829, 1, t829; // incremnetnado la pos del arreglo
+, t838, 1, t838; // incrementando la pos de la cadena
=>, t838, t839, heap; // sacandor el caracter del heap cadena
jmp, , , L310;
jmp, , , L313;
L313:
jmp, , , L311;
L311:
// ----------------- Resolviendo acceso local 
+, P, 3, t840; // pos del objeto
=>, t840, t842, stack; //apuntador al heap del obejto
=>, t842, t843, heap; // recuperando pos incial del objeto
+, t843, 0, t842;
=>, t842, t844, heap; // valor a retoranar del acceso
print("%a", t842);
+, P, 5, t845;
=>, t845, t846, stack; 
=>, t846, t847, heap; 
=>, t847, t848, heap; // valor de size del arreglo text
+, t847, 1, t849; // apuntador donde inicia el arreglo text
=>, t849, t850, heap; // primer caracter del arreglo text
+, H, 0, t851;
+, H, 1, t852;
<=, t851, t852, heap; 
+, H, 1, H;
+, 0, 0, t853;
<=, H, t853, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L314:
jne, t850, 36, L315;
jmp, , , L316;
L315:
<=, H, t850, heap; // ingresando el caracter 
+, H, 1, H;
+, t853, 1, t853; // incrementando en uno el size de la nueva cadena
+, t849, 1, t849;
=>, t849, t850, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L314;
L316:
<=, t852, t853, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 3, t854; // pos del objeto
=>, t854, t856, stack; //apuntador al heap del obejto
=>, t856, t857, heap; // recuperando pos incial del objeto
+, t857, 0, t856;
=>, t856, t858, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t859;
+, H, 1, t860;
<=, t859, t860, heap;
+, H, 1, H;
+, H, 1, H;
=>, t856, t861, heap; 
+, t861, 1, t862;
=>, t862, t863, heap; // caracter actual
+, 0, 0, t864;
L317:
jne, t863, 36, L318;
jmp, , , L319;
L318:
+, t864, 1, t864;
<=, H, t863, heap;
+, H, 1, H;
+, t862, 1, t862;
=>, t862, t863, heap; // caracter actual
jmp, , , L317;
L319:
<=, H, 36, heap;
+, H, 1, H;
<=, t860, t864, heap;
//Iniciando a concatnar cadenas 
=>, t851, t865, heap;
=>, t865, t866, heap; // size cadena1
+, t865, 1, t867; // pos 0 de la cadena 1
=>, t859, t868, heap;
=>, t868, t869, heap; // size cadena2
+, t868, 1, t870; // pos 0 de la cadena 2
+, t866, t869, t871; // size de la nueva cadena
=>, t867, t872, heap; // primer caracter de la cadena 1
=>, t870, t873, heap; // primer caracter de la cadena 2
+, H, 0, t874; // posicion de retorno de la cadena
+, H, 1, t875;
<=, t874, t875, heap;
+, H, 1, H;
<=, H, t871, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L320;
L320:
jne, t872, 36, L321;
jmp, , , L322;
jmp, , , L321;
L321:
<=, H, t872, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t867, 1, t867;
=>, t867, t872, heap;
jmp, , , L320;
jmp, , , L322;
L322:
jmp, , , L323;
L323:
jne, t873, 36, L324;
jmp, , , L325;
jmp, , , L324;
L324:
<=, H, t873, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t870, 1, t870;
=>, t870, t873, heap;
jmp, , , L323;
jmp, , , L325;
L325:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 5, t878; // pos del arreglo 
=>, t878, t879, stack; //apuntador al heap del arreglo
=>, t879, t880, heap; // apuntador del heap al heap donde inicia la cadena
=>, t880, t876, heap; // size del arreglo text
+, t880, 1, t877; // pos 0 donde inicia el arreglo text
=>, t874, t881, heap; // pos que apunta al size de la cadena
=>, t881, t882, heap; // size de la cadena
+, t881, 1, t883; // Pos 0 de la cadena
=>, t883, t884, heap; // sacandor el caracter del heap cadena
jle, t882, t876, L326;
jmp, , , L327;
jmp, , , L326;
L326:
jne, t884, 36, L328;
jmp, , , L329;
jmp, , , L328;
L328:
<=, t877, t884, heap; // guardando el caracter 
+, t877, 1, t877; // incremnetnado la pos del arreglo
+, t883, 1, t883; // incrementando la pos de la cadena
=>, t883, t884, heap; // sacandor el caracter del heap cadena
jmp, , , L326;
jmp, , , L329;
L329:
jmp, , , L327;
L327:
+, P, 5, t885;
=>, t885, t886, stack; 
=>, t886, t887, heap; 
=>, t887, t888, heap; // valor de size del arreglo text
+, t887, 1, t889; // apuntador donde inicia el arreglo text
=>, t889, t890, heap; // primer caracter del arreglo text
+, H, 0, t891;
+, H, 1, t892;
<=, t891, t892, heap; 
+, H, 1, H;
+, 0, 0, t893;
<=, H, t893, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L330:
jne, t890, 36, L331;
jmp, , , L332;
L331:
<=, H, t890, heap; // ingresando el caracter 
+, H, 1, H;
+, t893, 1, t893; // incrementando en uno el size de la nueva cadena
+, t889, 1, t889;
=>, t889, t890, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L330;
L332:
<=, t892, t893, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 3, t894; // pos del objeto
=>, t894, t896, stack; //apuntador al heap del obejto
=>, t896, t897, heap; // recuperando pos incial del objeto
+, t897, 4, t896;
=>, t896, t898, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t899;
+, H, 1, t900;
<=, t899, t900, heap;
+, H, 1, H;
+, H, 1, H;
=>, t896, t901, heap; 
+, t901, 1, t902;
=>, t902, t903, heap; // caracter actual
+, 0, 0, t904;
L333:
jne, t903, 36, L334;
jmp, , , L335;
L334:
+, t904, 1, t904;
<=, H, t903, heap;
+, H, 1, H;
+, t902, 1, t902;
=>, t902, t903, heap; // caracter actual
jmp, , , L333;
L335:
<=, H, 36, heap;
+, H, 1, H;
<=, t900, t904, heap;
//Iniciando a concatnar cadenas 
=>, t891, t905, heap;
=>, t905, t906, heap; // size cadena1
+, t905, 1, t907; // pos 0 de la cadena 1
=>, t899, t908, heap;
=>, t908, t909, heap; // size cadena2
+, t908, 1, t910; // pos 0 de la cadena 2
+, t906, t909, t911; // size de la nueva cadena
=>, t907, t912, heap; // primer caracter de la cadena 1
=>, t910, t913, heap; // primer caracter de la cadena 2
+, H, 0, t914; // posicion de retorno de la cadena
+, H, 1, t915;
<=, t914, t915, heap;
+, H, 1, H;
<=, H, t911, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L336;
L336:
jne, t912, 36, L337;
jmp, , , L338;
jmp, , , L337;
L337:
<=, H, t912, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t907, 1, t907;
=>, t907, t912, heap;
jmp, , , L336;
jmp, , , L338;
L338:
jmp, , , L339;
L339:
jne, t913, 36, L340;
jmp, , , L341;
jmp, , , L340;
L340:
<=, H, t913, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t910, 1, t910;
=>, t910, t913, heap;
jmp, , , L339;
jmp, , , L341;
L341:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 5, t918; // pos del arreglo 
=>, t918, t919, stack; //apuntador al heap del arreglo
=>, t919, t920, heap; // apuntador del heap al heap donde inicia la cadena
=>, t920, t916, heap; // size del arreglo text
+, t920, 1, t917; // pos 0 donde inicia el arreglo text
=>, t914, t921, heap; // pos que apunta al size de la cadena
=>, t921, t922, heap; // size de la cadena
+, t921, 1, t923; // Pos 0 de la cadena
=>, t923, t924, heap; // sacandor el caracter del heap cadena
jle, t922, t916, L342;
jmp, , , L343;
jmp, , , L342;
L342:
jne, t924, 36, L344;
jmp, , , L345;
jmp, , , L344;
L344:
<=, t917, t924, heap; // guardando el caracter 
+, t917, 1, t917; // incremnetnado la pos del arreglo
+, t923, 1, t923; // incrementando la pos de la cadena
=>, t923, t924, heap; // sacandor el caracter del heap cadena
jmp, , , L342;
jmp, , , L345;
L345:
jmp, , , L343;
L343:
+, P, 5, t925;
=>, t925, t926, stack; 
=>, t926, t927, heap; 
=>, t927, t928, heap; // valor de size del arreglo text
+, t927, 1, t929; // apuntador donde inicia el arreglo text
=>, t929, t930, heap; // primer caracter del arreglo text
+, H, 0, t931;
+, H, 1, t932;
<=, t931, t932, heap; 
+, H, 1, H;
+, 0, 0, t933;
<=, H, t933, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L346:
jne, t930, 36, L347;
jmp, , , L348;
L347:
<=, H, t930, heap; // ingresando el caracter 
+, H, 1, H;
+, t933, 1, t933; // incrementando en uno el size de la nueva cadena
+, t929, 1, t929;
=>, t929, t930, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L346;
L348:
<=, t932, t933, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t931);
// Resolviendo una cadena 
+, H, 0, t934; //apuntaodr a cadena 
+, H, 1, t935; //apu donde inicia la cadena
<=, t934, t935, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 15, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t936; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 78, heap; //guardadndo N
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 112, heap; //guardadndo p
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 5, t939; // pos del arreglo 
=>, t939, t940, stack; //apuntador al heap del arreglo
=>, t940, t941, heap; // apuntador del heap al heap donde inicia la cadena
=>, t941, t937, heap; // size del arreglo text
+, t941, 1, t938; // pos 0 donde inicia el arreglo text
=>, t934, t942, heap; // pos que apunta al size de la cadena
=>, t942, t943, heap; // size de la cadena
+, t942, 1, t944; // Pos 0 de la cadena
=>, t944, t945, heap; // sacandor el caracter del heap cadena
jle, t943, t937, L349;
jmp, , , L350;
jmp, , , L349;
L349:
jne, t945, 36, L351;
jmp, , , L352;
jmp, , , L351;
L351:
<=, t938, t945, heap; // guardando el caracter 
+, t938, 1, t938; // incremnetnado la pos del arreglo
+, t944, 1, t944; // incrementando la pos de la cadena
=>, t944, t945, heap; // sacandor el caracter del heap cadena
jmp, , , L349;
jmp, , , L352;
L352:
jmp, , , L350;
L350:
// ----------------- Resolviendo acceso local 
+, P, 2, t946; // pos del objeto
=>, t946, t948, stack; //apuntador al heap del obejto
=>, t948, t949, heap; // recuperando pos incial del objeto
+, t949, 0, t948;
=>, t948, t950, heap; // valor a retoranar del acceso
print("%a", t948);
+, P, 5, t951;
=>, t951, t952, stack; 
=>, t952, t953, heap; 
=>, t953, t954, heap; // valor de size del arreglo text
+, t953, 1, t955; // apuntador donde inicia el arreglo text
=>, t955, t956, heap; // primer caracter del arreglo text
+, H, 0, t957;
+, H, 1, t958;
<=, t957, t958, heap; 
+, H, 1, H;
+, 0, 0, t959;
<=, H, t959, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L353:
jne, t956, 36, L354;
jmp, , , L355;
L354:
<=, H, t956, heap; // ingresando el caracter 
+, H, 1, H;
+, t959, 1, t959; // incrementando en uno el size de la nueva cadena
+, t955, 1, t955;
=>, t955, t956, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L353;
L355:
<=, t958, t959, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 2, t960; // pos del objeto
=>, t960, t962, stack; //apuntador al heap del obejto
=>, t962, t963, heap; // recuperando pos incial del objeto
+, t963, 0, t962;
=>, t962, t964, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t965;
+, H, 1, t966;
<=, t965, t966, heap;
+, H, 1, H;
+, H, 1, H;
=>, t962, t967, heap; 
+, t967, 1, t968;
=>, t968, t969, heap; // caracter actual
+, 0, 0, t970;
L356:
jne, t969, 36, L357;
jmp, , , L358;
L357:
+, t970, 1, t970;
<=, H, t969, heap;
+, H, 1, H;
+, t968, 1, t968;
=>, t968, t969, heap; // caracter actual
jmp, , , L356;
L358:
<=, H, 36, heap;
+, H, 1, H;
<=, t966, t970, heap;
//Iniciando a concatnar cadenas 
=>, t957, t971, heap;
=>, t971, t972, heap; // size cadena1
+, t971, 1, t973; // pos 0 de la cadena 1
=>, t965, t974, heap;
=>, t974, t975, heap; // size cadena2
+, t974, 1, t976; // pos 0 de la cadena 2
+, t972, t975, t977; // size de la nueva cadena
=>, t973, t978, heap; // primer caracter de la cadena 1
=>, t976, t979, heap; // primer caracter de la cadena 2
+, H, 0, t980; // posicion de retorno de la cadena
+, H, 1, t981;
<=, t980, t981, heap;
+, H, 1, H;
<=, H, t977, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L359;
L359:
jne, t978, 36, L360;
jmp, , , L361;
jmp, , , L360;
L360:
<=, H, t978, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t973, 1, t973;
=>, t973, t978, heap;
jmp, , , L359;
jmp, , , L361;
L361:
jmp, , , L362;
L362:
jne, t979, 36, L363;
jmp, , , L364;
jmp, , , L363;
L363:
<=, H, t979, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t976, 1, t976;
=>, t976, t979, heap;
jmp, , , L362;
jmp, , , L364;
L364:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 5, t984; // pos del arreglo 
=>, t984, t985, stack; //apuntador al heap del arreglo
=>, t985, t986, heap; // apuntador del heap al heap donde inicia la cadena
=>, t986, t982, heap; // size del arreglo text
+, t986, 1, t983; // pos 0 donde inicia el arreglo text
=>, t980, t987, heap; // pos que apunta al size de la cadena
=>, t987, t988, heap; // size de la cadena
+, t987, 1, t989; // Pos 0 de la cadena
=>, t989, t990, heap; // sacandor el caracter del heap cadena
jle, t988, t982, L365;
jmp, , , L366;
jmp, , , L365;
L365:
jne, t990, 36, L367;
jmp, , , L368;
jmp, , , L367;
L367:
<=, t983, t990, heap; // guardando el caracter 
+, t983, 1, t983; // incremnetnado la pos del arreglo
+, t989, 1, t989; // incrementando la pos de la cadena
=>, t989, t990, heap; // sacandor el caracter del heap cadena
jmp, , , L365;
jmp, , , L368;
L368:
jmp, , , L366;
L366:
+, P, 5, t991;
=>, t991, t992, stack; 
=>, t992, t993, heap; 
=>, t993, t994, heap; // valor de size del arreglo text
+, t993, 1, t995; // apuntador donde inicia el arreglo text
=>, t995, t996, heap; // primer caracter del arreglo text
+, H, 0, t997;
+, H, 1, t998;
<=, t997, t998, heap; 
+, H, 1, H;
+, 0, 0, t999;
<=, H, t999, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L369:
jne, t996, 36, L370;
jmp, , , L371;
L370:
<=, H, t996, heap; // ingresando el caracter 
+, H, 1, H;
+, t999, 1, t999; // incrementando en uno el size de la nueva cadena
+, t995, 1, t995;
=>, t995, t996, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L369;
L371:
<=, t998, t999, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 2, t1000; // pos del objeto
=>, t1000, t1002, stack; //apuntador al heap del obejto
=>, t1002, t1003, heap; // recuperando pos incial del objeto
+, t1003, 4, t1002;
=>, t1002, t1004, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t1005;
+, H, 1, t1006;
<=, t1005, t1006, heap;
+, H, 1, H;
+, H, 1, H;
=>, t1002, t1007, heap; 
+, t1007, 1, t1008;
=>, t1008, t1009, heap; // caracter actual
+, 0, 0, t1010;
L372:
jne, t1009, 36, L373;
jmp, , , L374;
L373:
+, t1010, 1, t1010;
<=, H, t1009, heap;
+, H, 1, H;
+, t1008, 1, t1008;
=>, t1008, t1009, heap; // caracter actual
jmp, , , L372;
L374:
<=, H, 36, heap;
+, H, 1, H;
<=, t1006, t1010, heap;
//Iniciando a concatnar cadenas 
=>, t997, t1011, heap;
=>, t1011, t1012, heap; // size cadena1
+, t1011, 1, t1013; // pos 0 de la cadena 1
=>, t1005, t1014, heap;
=>, t1014, t1015, heap; // size cadena2
+, t1014, 1, t1016; // pos 0 de la cadena 2
+, t1012, t1015, t1017; // size de la nueva cadena
=>, t1013, t1018, heap; // primer caracter de la cadena 1
=>, t1016, t1019, heap; // primer caracter de la cadena 2
+, H, 0, t1020; // posicion de retorno de la cadena
+, H, 1, t1021;
<=, t1020, t1021, heap;
+, H, 1, H;
<=, H, t1017, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L375;
L375:
jne, t1018, 36, L376;
jmp, , , L377;
jmp, , , L376;
L376:
<=, H, t1018, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1013, 1, t1013;
=>, t1013, t1018, heap;
jmp, , , L375;
jmp, , , L377;
L377:
jmp, , , L378;
L378:
jne, t1019, 36, L379;
jmp, , , L380;
jmp, , , L379;
L379:
<=, H, t1019, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1016, 1, t1016;
=>, t1016, t1019, heap;
jmp, , , L378;
jmp, , , L380;
L380:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 5, t1024; // pos del arreglo 
=>, t1024, t1025, stack; //apuntador al heap del arreglo
=>, t1025, t1026, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1026, t1022, heap; // size del arreglo text
+, t1026, 1, t1023; // pos 0 donde inicia el arreglo text
=>, t1020, t1027, heap; // pos que apunta al size de la cadena
=>, t1027, t1028, heap; // size de la cadena
+, t1027, 1, t1029; // Pos 0 de la cadena
=>, t1029, t1030, heap; // sacandor el caracter del heap cadena
jle, t1028, t1022, L381;
jmp, , , L382;
jmp, , , L381;
L381:
jne, t1030, 36, L383;
jmp, , , L384;
jmp, , , L383;
L383:
<=, t1023, t1030, heap; // guardando el caracter 
+, t1023, 1, t1023; // incremnetnado la pos del arreglo
+, t1029, 1, t1029; // incrementando la pos de la cadena
=>, t1029, t1030, heap; // sacandor el caracter del heap cadena
jmp, , , L381;
jmp, , , L384;
L384:
jmp, , , L382;
L382:
+, P, 5, t1031;
=>, t1031, t1032, stack; 
=>, t1032, t1033, heap; 
=>, t1033, t1034, heap; // valor de size del arreglo text
+, t1033, 1, t1035; // apuntador donde inicia el arreglo text
=>, t1035, t1036, heap; // primer caracter del arreglo text
+, H, 0, t1037;
+, H, 1, t1038;
<=, t1037, t1038, heap; 
+, H, 1, H;
+, 0, 0, t1039;
<=, H, t1039, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L385:
jne, t1036, 36, L386;
jmp, , , L387;
L386:
<=, H, t1036, heap; // ingresando el caracter 
+, H, 1, H;
+, t1039, 1, t1039; // incrementando en uno el size de la nueva cadena
+, t1035, 1, t1035;
=>, t1035, t1036, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L385;
L387:
<=, t1038, t1039, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t1037);
jmp, , , L307; // salida del if
L309:

L307:
jmp, , ,L304; //regresando a la etiqueral del ciclo repetir mientras
L306:


L303:
end, , Funciones_vacio_ciclo_vida




begin, , , Funciones_entero_fibonacci_recursivo_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1040; // pos de n
=>, t1040, t1041, stack; // valor de lo que trae en el stack n
je, t1041, 0, L390;
jmp, , , L391;
L390:

// RESOLVIENDO UN RETORNO
+, P, 2, t1042; // pos de retorno de a funcion Funciones_entero_fibonacci_recursivo_entero
<=, t1042, 0, stack; //asignando el retorno con su valor
jmp, , , L388;
jmp, , , L389; // salida del if
L391:

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1043; // pos de n
=>, t1043, t1044, stack; // valor de lo que trae en el stack n
je, t1044, 1, L393;
jmp, , , L394;
L393:

// RESOLVIENDO UN RETORNO
+, P, 2, t1045; // pos de retorno de a funcion Funciones_entero_fibonacci_recursivo_entero
<=, t1045, 1, stack; //asignando el retorno con su valor
jmp, , , L388;
jmp, , , L392; // salida del if
L394:

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1046; // pos de n
=>, t1046, t1047, stack; // valor de lo que trae en el stack n
jg, t1047, 1, L396;
jmp, , , L397;
L396:

// RESOLVIENDO UN RETORNO
+, P, 0, t1048;
=>, t1048, t1049, stack; 
+, P, 3, t1050;
+, t1049, 0, t1051;
<=, t1050, t1049, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t1052; // size de funcion actual
+, t1052, 1, t1053; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1054; // pos de n
=>, t1054, t1055, stack; // valor de lo que trae en el stack n
-, t1055, 1, t1056;
<=, t1053, t1056, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Funciones_entero_fibonacci_recursivo_entero;
+, P, 2, t1057;
=>, t1057, t1058, stack; // valor del return
-, P, 3, P;
+, P, 0, t1059;
=>, t1059, t1060, stack; 
+, P, 3, t1061;
+, t1060, 0, t1062;
<=, t1061, t1060, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t1063; // size de funcion actual
+, t1063, 1, t1064; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1065; // pos de n
=>, t1065, t1066, stack; // valor de lo que trae en el stack n
-, t1066, 2, t1067;
<=, t1064, t1067, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Funciones_entero_fibonacci_recursivo_entero;
+, P, 2, t1068;
=>, t1068, t1069, stack; // valor del return
-, P, 3, P;
+, t1058, t1069, t1070;
+, P, 2, t1071; // pos de retorno de a funcion Funciones_entero_fibonacci_recursivo_entero
<=, t1071, t1070, stack; //asignando el retorno con su valor
jmp, , , L388;
jmp, , , L395; // salida del if
L397:

L395:
L392:
L389:
// RESOLVIENDO UN RETORNO
*, 1, -1, t1072;
+, P, 2, t1073; // pos de retorno de a funcion Funciones_entero_fibonacci_recursivo_entero
<=, t1073, t1072, stack; //asignando el retorno con su valor
jmp, , , L388;

L388:
end, , Funciones_entero_fibonacci_recursivo_entero




begin, , , Funciones_vacio_pedir_num

// Resolviendo una cadena 
+, H, 0, t1074; //apuntaodr a cadena 
+, H, 1, t1075; //apu donde inicia la cadena
<=, t1074, t1075, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 9, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1076; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 109, heap; //guardadndo m
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t1074);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t1077; // pos de num
<=, t1077, 0, stack; // asignando a num
// ---------- Resolver Hacer Mientras ----------- 
L399:
L401: //etiqueta del conituar
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1078; // pos de num
=>, t1078, t1079, stack; // valor de lo que trae en el stack num
je, t1079, 7, L402;
jmp, , , L403;
L403:

jmp, , , L399;
L402:

L400:

L398:
end, , Funciones_vacio_pedir_num




begin, , , Humano_vacio_nacer

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1080; // pos this 
=>, t1080, t1081, stack; // obtenido apuntador al heap 
=>, t1081, t1082, heap; // apuntador 
+, t1082, 0, t1083; // pos de edad
=>, t1083, t1084, heap; // obtengo el valor que se encuentre en el heap 
<=, t1083, 0, HEAP; // asignando variable 
// Resolviendo una cadena 
+, H, 0, t1085; //apuntaodr a cadena 
+, H, 1, t1086; //apu donde inicia la cadena
<=, t1085, t1086, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 14, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1087; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 121, heap; //guardadndo y
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t1085);

L404:
end, , Humano_vacio_nacer




begin, , , Persona_vacio_Persona

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t1088; //pos this del arreglo
=>, t1088, t1089, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1089, t1090, heap;//apuntando donde en verdad inicia el arreglo
+, t1090, 0, t1091; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t1091, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1092; //calculando el n real
-, t1092, 0, t1093; //iReal columna 0
+, t1093, 1, t1093; //size del arreglo nombre
<=, H, t1093, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t1093, 0, t1094; // anhadiendo una posicion mas
+, h, t1094, h; // reservnado el espacio del arreglo nombre
// ----------------------- Creando arreglo atributo DPI
+, P, 0, t1095; //pos this del arreglo
=>, t1095, t1096, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1096, t1097, heap;//apuntando donde en verdad inicia el arreglo
+, t1097, 3, t1098; //pos del heap que guarda apuntador del heap para el arreglo DPI
<=, t1098, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1099; //calculando el n real
-, t1099, 0, t1100; //iReal columna 0
+, t1100, 1, t1100; //size del arreglo DPI
<=, H, t1100, heap; // insertando el tamanio del arreglo linealizado DPI
+, H, 1, H;
+, t1100, 0, t1101; // anhadiendo una posicion mas
+, h, t1101, h; // reservnado el espacio del arreglo DPI
// ----------------------- Creando arreglo atributo apellido
+, P, 0, t1102; //pos this del arreglo
=>, t1102, t1103, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1103, t1104, heap;//apuntando donde en verdad inicia el arreglo
+, t1104, 4, t1105; //pos del heap que guarda apuntador del heap para el arreglo apellido
<=, t1105, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1106; //calculando el n real
-, t1106, 0, t1107; //iReal columna 0
+, t1107, 1, t1107; //size del arreglo apellido
<=, H, t1107, heap; // insertando el tamanio del arreglo linealizado apellido
+, H, 1, H;
+, t1107, 0, t1108; // anhadiendo una posicion mas
+, h, t1108, h; // reservnado el espacio del arreglo apellido
+, P, 0, t1109;
=>, t1109, t1110, stack; 
+, P, 2, t1111;
+, t1110, 0, t1112;
<=, t1111, t1110, stack; 
// No posee parametros 
+, P, 2, P;
call, , , Persona_vacio_nacer;
+, P, 1, t1113;
=>, t1113, t1114, stack; // valor del return
-, P, 2, P;
// Resolviendo una cadena 
+, H, 0, t1115; //apuntaodr a cadena 
+, H, 1, t1116; //apu donde inicia la cadena
<=, t1115, t1116, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 0, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1117; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 0, t1120; // pos this del objeto 
=>, t1120, t1121, stack; // apuntador al heap del objeto 
=>, t1121, t1122, heap; // apunt al heap donde inica el objeto
+, t1122, 0, t1123; //apuntador a posicion donde incia el arreglo
=>, t1123, t1124, heap; // inicia el arreglo
=>, t1124, t1118, heap; // size del arreglo nombre
+, t1124, 1, t1119; //Pos 0 del arreglo
=>, t1115, t1125, heap; // pos que apunta al size de la cadena
=>, t1125, t1126, heap; // size de la cadena
+, t1125, 1, t1127; // Pos 0 de la cadena
=>, t1127, t1128, heap; // sacandor el caracter del heap cadena
jle, t1126, t1118, L406;
jmp, , , L407;
jmp, , , L406;
L406:
jne, t1128, 36, L408;
jmp, , , L409;
jmp, , , L408;
L408:
<=, t1119, t1128, heap; // guardando el caracter 
+, t1119, 1, t1119; // incremnetnado la pos del arreglo
+, t1127, 1, t1127; // incrementando la pos de la cadena
=>, t1127, t1128, heap; // sacandor el caracter del heap cadena
jmp, , , L406;
jmp, , , L409;
L409:
jmp, , , L407;
L407:
// Asignando atributo genero
+, p, 0, t1129; //pos this 
=>, t1129, t1130, stack; // apuntador al heap
=>, t1130, t1131, heap; // apuntador donde inicia el objeto
+, t1131, 2, t1132; // pos real  de genero
<=, t1132, 77, heap; //guardando en el heap el valor del atributo

L405:
end, , Persona_vacio_Persona




begin, , , Persona_vacio_Persona_entero_caracter_caracter_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t1133; //pos this del arreglo
=>, t1133, t1134, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1134, t1135, heap;//apuntando donde en verdad inicia el arreglo
+, t1135, 0, t1136; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t1136, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1137; //calculando el n real
-, t1137, 0, t1138; //iReal columna 0
+, t1138, 1, t1138; //size del arreglo nombre
<=, H, t1138, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t1138, 0, t1139; // anhadiendo una posicion mas
+, h, t1139, h; // reservnado el espacio del arreglo nombre
// ----------------------- Creando arreglo atributo DPI
+, P, 0, t1140; //pos this del arreglo
=>, t1140, t1141, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1141, t1142, heap;//apuntando donde en verdad inicia el arreglo
+, t1142, 3, t1143; //pos del heap que guarda apuntador del heap para el arreglo DPI
<=, t1143, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1144; //calculando el n real
-, t1144, 0, t1145; //iReal columna 0
+, t1145, 1, t1145; //size del arreglo DPI
<=, H, t1145, heap; // insertando el tamanio del arreglo linealizado DPI
+, H, 1, H;
+, t1145, 0, t1146; // anhadiendo una posicion mas
+, h, t1146, h; // reservnado el espacio del arreglo DPI
// ----------------------- Creando arreglo atributo apellido
+, P, 0, t1147; //pos this del arreglo
=>, t1147, t1148, stack; //obteniendo apuntador de arreglo en eel heap
=>, t1148, t1149, heap;//apuntando donde en verdad inicia el arreglo
+, t1149, 4, t1150; //pos del heap que guarda apuntador del heap para el arreglo apellido
<=, t1150, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t1151; //calculando el n real
-, t1151, 0, t1152; //iReal columna 0
+, t1152, 1, t1152; //size del arreglo apellido
<=, H, t1152, heap; // insertando el tamanio del arreglo linealizado apellido
+, H, 1, H;
+, t1152, 0, t1153; // anhadiendo una posicion mas
+, h, t1153, h; // reservnado el espacio del arreglo apellido
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1154; // pos this 
=>, t1154, t1155, stack; // obtenido apuntador al heap 
=>, t1155, t1156, heap; // apuntador 
+, t1156, 1, t1157; // pos de edad
=>, t1157, t1158, heap; // obtengo el valor que se encuentre en el heap 
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t1159; // pos de edad
=>, t1159, t1160, stack; // valor de lo que trae en el stack edad
<=, t1157, t1160, HEAP; // asignando variable 
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1161; // pos this 
=>, t1161, t1162, stack; // obtenido apuntador al heap 
=>, t1162, t1163, heap; // apuntador 
+, t1163, 0, t1164; // pos de nombre
=>, t1164, t1165, heap; // obtengo el valor que se encuentre en el heap 
+, P, 2, t1166;
=>, t1166, t1167, stack; 
=>, t1167, t1168, heap; 
=>, t1168, t1169, heap; // valor de size del arreglo nombre2
+, t1168, 1, t1170; // apuntador donde inicia el arreglo nombre2
=>, t1170, t1171, heap; // primer caracter del arreglo nombre2
+, H, 0, t1172;
+, H, 1, t1173;
<=, t1172, t1173, heap; 
+, H, 1, H;
+, 0, 0, t1174;
<=, H, t1174, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L411:
jne, t1171, 36, L412;
jmp, , , L413;
L412:
<=, H, t1171, heap; // ingresando el caracter 
+, H, 1, H;
+, t1174, 1, t1174; // incrementando en uno el size de la nueva cadena
+, t1170, 1, t1170;
=>, t1170, t1171, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L411;
L413:
<=, t1173, t1174, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t1164, 1, t1175;
// -------------------- Arreglo global asignar :) 
=>, t1164, t1176, heap; // inicia el arreglo
=>, t1176, t1177, heap; // size del arreglo 
+, t1176, 1, t1178; //Pos 0 del arreglo
=>, t1172, t1179, heap; // pos que apunta al size de la cadena
=>, t1179, t1180, heap; // size de la cadena
+, t1179, 1, t1181; // Pos 0 de la cadena
=>, t1181, t1182, heap; // sacandor el caracter del heap cadena
jle, t1180, t1177, L414;
jmp, , , L415;
jmp, , , L414;
L414:
jne, t1182, 36, L416;
jmp, , , L417;
jmp, , , L416;
L416:
<=, t1178, t1182, heap; // guardando el caracter 
+, t1178, 1, t1178; // incremnetnado la pos del arreglo
+, t1181, 1, t1181; // incrementando la pos de la cadena
=>, t1181, t1182, heap; // sacandor el caracter del heap cadena
jmp, , , L414;
jmp, , , L417;
L417:
jmp, , , L415;
L415:
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1183; // pos this 
=>, t1183, t1184, stack; // obtenido apuntador al heap 
=>, t1184, t1185, heap; // apuntador 
+, t1185, 4, t1186; // pos de apellido
=>, t1186, t1187, heap; // obtengo el valor que se encuentre en el heap 
+, P, 3, t1188;
=>, t1188, t1189, stack; 
=>, t1189, t1190, heap; 
=>, t1190, t1191, heap; // valor de size del arreglo apellido2
+, t1190, 1, t1192; // apuntador donde inicia el arreglo apellido2
=>, t1192, t1193, heap; // primer caracter del arreglo apellido2
+, H, 0, t1194;
+, H, 1, t1195;
<=, t1194, t1195, heap; 
+, H, 1, H;
+, 0, 0, t1196;
<=, H, t1196, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L418:
jne, t1193, 36, L419;
jmp, , , L420;
L419:
<=, H, t1193, heap; // ingresando el caracter 
+, H, 1, H;
+, t1196, 1, t1196; // incrementando en uno el size de la nueva cadena
+, t1192, 1, t1192;
=>, t1192, t1193, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L418;
L420:
<=, t1195, t1196, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t1186, 1, t1197;
// -------------------- Arreglo global asignar :) 
=>, t1186, t1198, heap; // inicia el arreglo
=>, t1198, t1199, heap; // size del arreglo 
+, t1198, 1, t1200; //Pos 0 del arreglo
=>, t1194, t1201, heap; // pos que apunta al size de la cadena
=>, t1201, t1202, heap; // size de la cadena
+, t1201, 1, t1203; // Pos 0 de la cadena
=>, t1203, t1204, heap; // sacandor el caracter del heap cadena
jle, t1202, t1199, L421;
jmp, , , L422;
jmp, , , L421;
L421:
jne, t1204, 36, L423;
jmp, , , L424;
jmp, , , L423;
L423:
<=, t1200, t1204, heap; // guardando el caracter 
+, t1200, 1, t1200; // incremnetnado la pos del arreglo
+, t1203, 1, t1203; // incrementando la pos de la cadena
=>, t1203, t1204, heap; // sacandor el caracter del heap cadena
jmp, , , L421;
jmp, , , L424;
L424:
jmp, , , L422;
L422:
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1205; // pos this 
=>, t1205, t1206, stack; // obtenido apuntador al heap 
=>, t1206, t1207, heap; // apuntador 
+, t1207, 2, t1208; // pos de genero
=>, t1208, t1209, heap; // obtengo el valor que se encuentre en el heap 
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t1210; // pos de genero
=>, t1210, t1211, stack; // valor de lo que trae en el stack genero
<=, t1208, t1211, HEAP; // asignando variable 

L410:
end, , Persona_vacio_Persona_entero_caracter_caracter_caracter




begin, , , Persona_caracter_concat_caracter_caracter

// ------------------------ Creando arreglo local ret
+, P, 3, t1212; //pos de arreglo ret
<=, t1212, H, stack; // ingrensando al stack apunt del heap para ret
+, H, 1, t1213;
<=, H, t1213, heap; //insetnado donde inicia el arreglo ret
+, H, 1, H;
// calculando el tamanho del arreglo
-, 60, 1, t1214; //calculando el n real
-, t1214, 0, t1215; //iReal columna 0
+, t1215, 1, t1215; //size del arreglo ret
<=, H, t1215, heap; // insertando el tamanio del arreglo linealizado ret
+, H, 1, H;
+, h, t1215, h; // reservnado el espacio del arreglo ret
+, P, 3, t1218; // pos del arreglo 
=>, t1218, t1219, stack; //apuntador al heap del arreglo
=>, t1219, t1220, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1220, t1216, heap; // size del arreglo ret
+, t1220, 1, t1217; // pos 0 donde inicia el arreglo ret
+, P, 0, t1221;
=>, t1221, t1222, stack; 
=>, t1222, t1223, heap; 
+, t1223, 0, t1224;
=>, t1224, t1225, heap; 
=>, t1225, t1226, heap; 
+, t1225, 1, t1227; 
=>, t1227, t1228, heap; // primer caracter del arreglo nombre
+, H, 0, t1229;
+, H, 1, t1230;
<=, t1229, t1230, heap; 
+, H, 1, H;
+, 0, 0, t1231;
<=, H, t1231, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L426:
jne, t1228, 36, L427;
jmp, , , L428;
L427:
<=, H, t1228, heap; // ingresando el caracter 
+, H, 1, H;
+, t1231, 1, t1231; // incrementando en uno el size de la nueva cadena
+, t1227, 1, t1227;
=>, t1227, t1228, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L426;
L428:
<=, t1230, t1231, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
=>, t1229, t1232, heap; // pos que apunta al size de la cadena
=>, t1232, t1233, heap; // size de la cadena
+, t1232, 1, t1234; // Pos 0 de la cadena
=>, t1234, t1235, heap; // sacandor el caracter del heap cadena
jle, t1233, t1216, L429;
jmp, , , L430;
jmp, , , L429;
L429:
jne, t1235, 36, L431;
jmp, , , L432;
jmp, , , L431;
L431:
<=, t1217, t1235, heap; // guardando el caracter 
+, t1217, 1, t1217; // incremnetnado la pos del arreglo
+, t1234, 1, t1234; // incrementando la pos de la cadena
=>, t1234, t1235, heap; // sacandor el caracter del heap cadena
jmp, , , L429;
jmp, , , L432;
L432:
jmp, , , L430;
L430:
+, P, 3, t1236;
=>, t1236, t1237, stack; 
=>, t1237, t1238, heap; 
=>, t1238, t1239, heap; // valor de size del arreglo ret
+, t1238, 1, t1240; // apuntador donde inicia el arreglo ret
=>, t1240, t1241, heap; // primer caracter del arreglo ret
+, H, 0, t1242;
+, H, 1, t1243;
<=, t1242, t1243, heap; 
+, H, 1, H;
+, 0, 0, t1244;
<=, H, t1244, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L433:
jne, t1241, 36, L434;
jmp, , , L435;
L434:
<=, H, t1241, heap; // ingresando el caracter 
+, H, 1, H;
+, t1244, 1, t1244; // incrementando en uno el size de la nueva cadena
+, t1240, 1, t1240;
=>, t1240, t1241, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L433;
L435:
<=, t1243, t1244, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t1245; //apuntaodr a cadena 
+, H, 1, t1246; //apu donde inicia la cadena
<=, t1245, t1246, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1247; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
//Iniciando a concatnar cadenas 
=>, t1242, t1248, heap;
=>, t1248, t1249, heap; // size cadena1
+, t1248, 1, t1250; // pos 0 de la cadena 1
=>, t1245, t1251, heap;
=>, t1251, t1252, heap; // size cadena2
+, t1251, 1, t1253; // pos 0 de la cadena 2
+, t1249, t1252, t1254; // size de la nueva cadena
=>, t1250, t1255, heap; // primer caracter de la cadena 1
=>, t1253, t1256, heap; // primer caracter de la cadena 2
+, H, 0, t1257; // posicion de retorno de la cadena
+, H, 1, t1258;
<=, t1257, t1258, heap;
+, H, 1, H;
<=, H, t1254, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L436;
L436:
jne, t1255, 36, L437;
jmp, , , L438;
jmp, , , L437;
L437:
<=, H, t1255, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1250, 1, t1250;
=>, t1250, t1255, heap;
jmp, , , L436;
jmp, , , L438;
L438:
jmp, , , L439;
L439:
jne, t1256, 36, L440;
jmp, , , L441;
jmp, , , L440;
L440:
<=, H, t1256, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1253, 1, t1253;
=>, t1253, t1256, heap;
jmp, , , L439;
jmp, , , L441;
L441:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 3, t1261; // pos del arreglo 
=>, t1261, t1262, stack; //apuntador al heap del arreglo
=>, t1262, t1263, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1263, t1259, heap; // size del arreglo ret
+, t1263, 1, t1260; // pos 0 donde inicia el arreglo ret
=>, t1257, t1264, heap; // pos que apunta al size de la cadena
=>, t1264, t1265, heap; // size de la cadena
+, t1264, 1, t1266; // Pos 0 de la cadena
=>, t1266, t1267, heap; // sacandor el caracter del heap cadena
jle, t1265, t1259, L442;
jmp, , , L443;
jmp, , , L442;
L442:
jne, t1267, 36, L444;
jmp, , , L445;
jmp, , , L444;
L444:
<=, t1260, t1267, heap; // guardando el caracter 
+, t1260, 1, t1260; // incremnetnado la pos del arreglo
+, t1266, 1, t1266; // incrementando la pos de la cadena
=>, t1266, t1267, heap; // sacandor el caracter del heap cadena
jmp, , , L442;
jmp, , , L445;
L445:
jmp, , , L443;
L443:
+, P, 3, t1268;
=>, t1268, t1269, stack; 
=>, t1269, t1270, heap; 
=>, t1270, t1271, heap; // valor de size del arreglo ret
+, t1270, 1, t1272; // apuntador donde inicia el arreglo ret
=>, t1272, t1273, heap; // primer caracter del arreglo ret
+, H, 0, t1274;
+, H, 1, t1275;
<=, t1274, t1275, heap; 
+, H, 1, H;
+, 0, 0, t1276;
<=, H, t1276, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L446:
jne, t1273, 36, L447;
jmp, , , L448;
L447:
<=, H, t1273, heap; // ingresando el caracter 
+, H, 1, H;
+, t1276, 1, t1276; // incrementando en uno el size de la nueva cadena
+, t1272, 1, t1272;
=>, t1272, t1273, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L446;
L448:
<=, t1275, t1276, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
+, P, 2, t1277;
=>, t1277, t1278, stack; 
=>, t1278, t1279, heap; 
=>, t1279, t1280, heap; // valor de size del arreglo apellidos
+, t1279, 1, t1281; // apuntador donde inicia el arreglo apellidos
=>, t1281, t1282, heap; // primer caracter del arreglo apellidos
+, H, 0, t1283;
+, H, 1, t1284;
<=, t1283, t1284, heap; 
+, H, 1, H;
+, 0, 0, t1285;
<=, H, t1285, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L449:
jne, t1282, 36, L450;
jmp, , , L451;
L450:
<=, H, t1282, heap; // ingresando el caracter 
+, H, 1, H;
+, t1285, 1, t1285; // incrementando en uno el size de la nueva cadena
+, t1281, 1, t1281;
=>, t1281, t1282, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L449;
L451:
<=, t1284, t1285, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
//Iniciando a concatnar cadenas 
=>, t1274, t1286, heap;
=>, t1286, t1287, heap; // size cadena1
+, t1286, 1, t1288; // pos 0 de la cadena 1
=>, t1283, t1289, heap;
=>, t1289, t1290, heap; // size cadena2
+, t1289, 1, t1291; // pos 0 de la cadena 2
+, t1287, t1290, t1292; // size de la nueva cadena
=>, t1288, t1293, heap; // primer caracter de la cadena 1
=>, t1291, t1294, heap; // primer caracter de la cadena 2
+, H, 0, t1295; // posicion de retorno de la cadena
+, H, 1, t1296;
<=, t1295, t1296, heap;
+, H, 1, H;
<=, H, t1292, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L452;
L452:
jne, t1293, 36, L453;
jmp, , , L454;
jmp, , , L453;
L453:
<=, H, t1293, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1288, 1, t1288;
=>, t1288, t1293, heap;
jmp, , , L452;
jmp, , , L454;
L454:
jmp, , , L455;
L455:
jne, t1294, 36, L456;
jmp, , , L457;
jmp, , , L456;
L456:
<=, H, t1294, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1291, 1, t1291;
=>, t1291, t1294, heap;
jmp, , , L455;
jmp, , , L457;
L457:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 3, t1299; // pos del arreglo 
=>, t1299, t1300, stack; //apuntador al heap del arreglo
=>, t1300, t1301, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1301, t1297, heap; // size del arreglo ret
+, t1301, 1, t1298; // pos 0 donde inicia el arreglo ret
=>, t1295, t1302, heap; // pos que apunta al size de la cadena
=>, t1302, t1303, heap; // size de la cadena
+, t1302, 1, t1304; // Pos 0 de la cadena
=>, t1304, t1305, heap; // sacandor el caracter del heap cadena
jle, t1303, t1297, L458;
jmp, , , L459;
jmp, , , L458;
L458:
jne, t1305, 36, L460;
jmp, , , L461;
jmp, , , L460;
L460:
<=, t1298, t1305, heap; // guardando el caracter 
+, t1298, 1, t1298; // incremnetnado la pos del arreglo
+, t1304, 1, t1304; // incrementando la pos de la cadena
=>, t1304, t1305, heap; // sacandor el caracter del heap cadena
jmp, , , L458;
jmp, , , L461;
L461:
jmp, , , L459;
L459:
// RESOLVIENDO UN RETORNO
+, P, 3, t1306;
=>, t1306, t1307, stack; 
=>, t1307, t1308, heap; 
=>, t1308, t1309, heap; // valor de size del arreglo ret
+, t1308, 1, t1310; // apuntador donde inicia el arreglo ret
=>, t1310, t1311, heap; // primer caracter del arreglo ret
+, H, 0, t1312;
+, H, 1, t1313;
<=, t1312, t1313, heap; 
+, H, 1, H;
+, 0, 0, t1314;
<=, H, t1314, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L462:
jne, t1311, 36, L463;
jmp, , , L464;
L463:
<=, H, t1311, heap; // ingresando el caracter 
+, H, 1, H;
+, t1314, 1, t1314; // incrementando en uno el size de la nueva cadena
+, t1310, 1, t1310;
=>, t1310, t1311, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L462;
L464:
<=, t1313, t1314, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;

L425:
end, , Persona_caracter_concat_caracter_caracter




begin, , , Persona_Persona_reproducir_Persona_caracter

+, P, 2, t1315;
=>, t1315, t1316, stack; 
=>, t1316, t1317, heap; 
=>, t1317, t1318, heap; // valor de size del arreglo nombre
+, t1317, 1, t1319; // apuntador donde inicia el arreglo nombre
=>, t1319, t1320, heap; // primer caracter del arreglo nombre
+, H, 0, t1321;
+, H, 1, t1322;
<=, t1321, t1322, heap; 
+, H, 1, H;
+, 0, 0, t1323;
<=, H, t1323, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L466:
jne, t1320, 36, L467;
jmp, , , L468;
L467:
<=, H, t1320, heap; // ingresando el caracter 
+, H, 1, H;
+, t1323, 1, t1323; // incrementando en uno el size de la nueva cadena
+, t1319, 1, t1319;
=>, t1319, t1320, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L466;
L468:
<=, t1322, t1323, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
print("%s", t1321);
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1324; // pos this 
=>, t1324, t1325, stack; // obtenido apuntador al heap 
=>, t1325, t1326, heap; // apuntador 
+, t1326, 2, t1327; // pos de genero
=>, t1327, t1328, heap; // obtengo el valor que se encuentre en el heap 
// ----------------- Resolviendo acceso local 
+, P, 1, t1329; // pos del objeto
=>, t1329, t1331, stack; //apuntador al heap del obejto
=>, t1331, t1332, heap; // recuperando pos incial del objeto
+, t1332, 2, t1331;
=>, t1331, t1333, heap; // valor a retoranar del acceso
jne, t1328, t1333, L470;
jmp, , , L471;
L470:

// ----------- Instancia a una variable local --------------
+, p, 3, t1334; // pos de bebe
<=, t1334, h, stack; //guardando referencia del heap para el objeto bebe
+, h, 1, t1335; // guardo la posicion donde inicia el objeto 
<=, h, t1335, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 5, h; // reservando espacio para el objeto bebe
//Ingresando referencia al this del objeto bebe
+, p, 3, t1336; // pos de bebe
=>, t1336, t1337, stack; // obteniendo apuntador de bebe
+, p, 6, t1338; // simulando cambio de ambito
+, t1338, 0, t1339; //pos del this de bebe
<=, t1339, t1337, stack; // insertando apuntador del heap al stack del obeto bebe
// No posee parametros 
+, p, 6, p; // simulando cambio de ambito
call, , , Persona_vacio_Persona;
-, p, 6, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 3, t1340; // pos del objeto
=>, t1340, t1342, stack; //apuntador al heap del obejto
=>, t1342, t1343, heap; // recuperando pos incial del objeto
+, t1343, 0, t1342;
=>, t1342, t1344, heap; // valor a retoranar del acceso
+, P, 2, t1345;
=>, t1345, t1346, stack; 
=>, t1346, t1347, heap; 
=>, t1347, t1348, heap; // valor de size del arreglo nombre
+, t1347, 1, t1349; // apuntador donde inicia el arreglo nombre
=>, t1349, t1350, heap; // primer caracter del arreglo nombre
+, H, 0, t1351;
+, H, 1, t1352;
<=, t1351, t1352, heap; 
+, H, 1, H;
+, 0, 0, t1353;
<=, H, t1353, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L472:
jne, t1350, 36, L473;
jmp, , , L474;
L473:
<=, H, t1350, heap; // ingresando el caracter 
+, H, 1, H;
+, t1353, 1, t1353; // incrementando en uno el size de la nueva cadena
+, t1349, 1, t1349;
=>, t1349, t1350, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L472;
L474:
<=, t1352, t1353, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t1342, 1, t1354;
// -------------------- Arreglo global asignar :) 
=>, t1342, t1355, heap; // inicia el arreglo
=>, t1355, t1356, heap; // size del arreglo 
+, t1355, 1, t1357; //Pos 0 del arreglo
=>, t1351, t1358, heap; // pos que apunta al size de la cadena
=>, t1358, t1359, heap; // size de la cadena
+, t1358, 1, t1360; // Pos 0 de la cadena
=>, t1360, t1361, heap; // sacandor el caracter del heap cadena
jle, t1359, t1356, L475;
jmp, , , L476;
jmp, , , L475;
L475:
jne, t1361, 36, L477;
jmp, , , L478;
jmp, , , L477;
L477:
<=, t1357, t1361, heap; // guardando el caracter 
+, t1357, 1, t1357; // incremnetnado la pos del arreglo
+, t1360, 1, t1360; // incrementando la pos de la cadena
=>, t1360, t1361, heap; // sacandor el caracter del heap cadena
jmp, , , L475;
jmp, , , L478;
L478:
jmp, , , L476;
L476:
// ----------------- Resolviendo acceso local 
+, P, 3, t1362; // pos del objeto
=>, t1362, t1364, stack; //apuntador al heap del obejto
=>, t1364, t1365, heap; // recuperando pos incial del objeto
+, t1365, 4, t1364;
=>, t1364, t1366, heap; // valor a retoranar del acceso
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1367; // pos this 
=>, t1367, t1368, stack; // obtenido apuntador al heap 
=>, t1368, t1369, heap; // apuntador 
+, t1369, 4, t1370; // pos de apellido
=>, t1370, t1371, heap; // obtengo el valor que se encuentre en el heap 
<=, t1364, t1371, heap; // asignando variable 
// ------------------------ Creando arreglo local ape
+, P, 4, t1372; //pos de arreglo ape
<=, t1372, H, stack; // ingrensando al stack apunt del heap para ape
+, H, 1, t1373;
<=, H, t1373, heap; //insetnado donde inicia el arreglo ape
+, H, 1, H;
// calculando el tamanho del arreglo
-, 60, 1, t1374; //calculando el n real
-, t1374, 0, t1375; //iReal columna 0
+, t1375, 1, t1375; //size del arreglo ape
<=, H, t1375, heap; // insertando el tamanio del arreglo linealizado ape
+, H, 1, H;
+, h, t1375, h; // reservnado el espacio del arreglo ape
+, P, 4, t1378; // pos del arreglo 
=>, t1378, t1379, stack; //apuntador al heap del arreglo
=>, t1379, t1380, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1380, t1376, heap; // size del arreglo ape
+, t1380, 1, t1377; // pos 0 donde inicia el arreglo ape
// ----------------- Resolviendo acceso local 
+, P, 3, t1381; // pos del objeto
=>, t1381, t1383, stack; //apuntador al heap del obejto
=>, t1383, t1384, heap; // recuperando pos incial del objeto
+, t1384, 4, t1383;
=>, t1383, t1385, heap; // valor a retoranar del acceso
+, P, 4, t1386;
=>, t1386, t1387, stack; 
=>, t1387, t1388, heap; 
=>, t1388, t1389, heap; // valor de size del arreglo ape
+, t1388, 1, t1390; // apuntador donde inicia el arreglo ape
=>, t1390, t1391, heap; // primer caracter del arreglo ape
+, H, 0, t1392;
+, H, 1, t1393;
<=, t1392, t1393, heap; 
+, H, 1, H;
+, 0, 0, t1394;
<=, H, t1394, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L479:
jne, t1391, 36, L480;
jmp, , , L481;
L480:
<=, H, t1391, heap; // ingresando el caracter 
+, H, 1, H;
+, t1394, 1, t1394; // incrementando en uno el size de la nueva cadena
+, t1390, 1, t1390;
=>, t1390, t1391, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L479;
L481:
<=, t1393, t1394, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t1395; //apuntaodr a cadena 
+, H, 1, t1396; //apu donde inicia la cadena
<=, t1395, t1396, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 1, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1397; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
//Iniciando a concatnar cadenas 
=>, t1392, t1398, heap;
=>, t1398, t1399, heap; // size cadena1
+, t1398, 1, t1400; // pos 0 de la cadena 1
=>, t1395, t1401, heap;
=>, t1401, t1402, heap; // size cadena2
+, t1401, 1, t1403; // pos 0 de la cadena 2
+, t1399, t1402, t1404; // size de la nueva cadena
=>, t1400, t1405, heap; // primer caracter de la cadena 1
=>, t1403, t1406, heap; // primer caracter de la cadena 2
+, H, 0, t1407; // posicion de retorno de la cadena
+, H, 1, t1408;
<=, t1407, t1408, heap;
+, H, 1, H;
<=, H, t1404, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L482;
L482:
jne, t1405, 36, L483;
jmp, , , L484;
jmp, , , L483;
L483:
<=, H, t1405, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1400, 1, t1400;
=>, t1400, t1405, heap;
jmp, , , L482;
jmp, , , L484;
L484:
jmp, , , L485;
L485:
jne, t1406, 36, L486;
jmp, , , L487;
jmp, , , L486;
L486:
<=, H, t1406, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1403, 1, t1403;
=>, t1403, t1406, heap;
jmp, , , L485;
jmp, , , L487;
L487:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 4, t1411; // pos del arreglo 
=>, t1411, t1412, stack; //apuntador al heap del arreglo
=>, t1412, t1413, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1413, t1409, heap; // size del arreglo ape
+, t1413, 1, t1410; // pos 0 donde inicia el arreglo ape
=>, t1407, t1414, heap; // pos que apunta al size de la cadena
=>, t1414, t1415, heap; // size de la cadena
+, t1414, 1, t1416; // Pos 0 de la cadena
=>, t1416, t1417, heap; // sacandor el caracter del heap cadena
jle, t1415, t1409, L488;
jmp, , , L489;
jmp, , , L488;
L488:
jne, t1417, 36, L490;
jmp, , , L491;
jmp, , , L490;
L490:
<=, t1410, t1417, heap; // guardando el caracter 
+, t1410, 1, t1410; // incremnetnado la pos del arreglo
+, t1416, 1, t1416; // incrementando la pos de la cadena
=>, t1416, t1417, heap; // sacandor el caracter del heap cadena
jmp, , , L488;
jmp, , , L491;
L491:
jmp, , , L489;
L489:
+, P, 4, t1418;
=>, t1418, t1419, stack; 
=>, t1419, t1420, heap; 
=>, t1420, t1421, heap; // valor de size del arreglo ape
+, t1420, 1, t1422; // apuntador donde inicia el arreglo ape
=>, t1422, t1423, heap; // primer caracter del arreglo ape
+, H, 0, t1424;
+, H, 1, t1425;
<=, t1424, t1425, heap; 
+, H, 1, H;
+, 0, 0, t1426;
<=, H, t1426, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L492:
jne, t1423, 36, L493;
jmp, , , L494;
L493:
<=, H, t1423, heap; // ingresando el caracter 
+, H, 1, H;
+, t1426, 1, t1426; // incrementando en uno el size de la nueva cadena
+, t1422, 1, t1422;
=>, t1422, t1423, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L492;
L494:
<=, t1425, t1426, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 1, t1427; // pos del objeto
=>, t1427, t1429, stack; //apuntador al heap del obejto
=>, t1429, t1430, heap; // recuperando pos incial del objeto
+, t1430, 4, t1429;
=>, t1429, t1431, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t1432;
+, H, 1, t1433;
<=, t1432, t1433, heap;
+, H, 1, H;
+, H, 1, H;
=>, t1429, t1434, heap; 
+, t1434, 1, t1435;
=>, t1435, t1436, heap; // caracter actual
+, 0, 0, t1437;
L495:
jne, t1436, 36, L496;
jmp, , , L497;
L496:
+, t1437, 1, t1437;
<=, H, t1436, heap;
+, H, 1, H;
+, t1435, 1, t1435;
=>, t1435, t1436, heap; // caracter actual
jmp, , , L495;
L497:
<=, H, 36, heap;
+, H, 1, H;
<=, t1433, t1437, heap;
//Iniciando a concatnar cadenas 
=>, t1424, t1438, heap;
=>, t1438, t1439, heap; // size cadena1
+, t1438, 1, t1440; // pos 0 de la cadena 1
=>, t1432, t1441, heap;
=>, t1441, t1442, heap; // size cadena2
+, t1441, 1, t1443; // pos 0 de la cadena 2
+, t1439, t1442, t1444; // size de la nueva cadena
=>, t1440, t1445, heap; // primer caracter de la cadena 1
=>, t1443, t1446, heap; // primer caracter de la cadena 2
+, H, 0, t1447; // posicion de retorno de la cadena
+, H, 1, t1448;
<=, t1447, t1448, heap;
+, H, 1, H;
<=, H, t1444, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L498;
L498:
jne, t1445, 36, L499;
jmp, , , L500;
jmp, , , L499;
L499:
<=, H, t1445, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1440, 1, t1440;
=>, t1440, t1445, heap;
jmp, , , L498;
jmp, , , L500;
L500:
jmp, , , L501;
L501:
jne, t1446, 36, L502;
jmp, , , L503;
jmp, , , L502;
L502:
<=, H, t1446, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1443, 1, t1443;
=>, t1443, t1446, heap;
jmp, , , L501;
jmp, , , L503;
L503:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 4, t1451; // pos del arreglo 
=>, t1451, t1452, stack; //apuntador al heap del arreglo
=>, t1452, t1453, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1453, t1449, heap; // size del arreglo ape
+, t1453, 1, t1450; // pos 0 donde inicia el arreglo ape
=>, t1447, t1454, heap; // pos que apunta al size de la cadena
=>, t1454, t1455, heap; // size de la cadena
+, t1454, 1, t1456; // Pos 0 de la cadena
=>, t1456, t1457, heap; // sacandor el caracter del heap cadena
jle, t1455, t1449, L504;
jmp, , , L505;
jmp, , , L504;
L504:
jne, t1457, 36, L506;
jmp, , , L507;
jmp, , , L506;
L506:
<=, t1450, t1457, heap; // guardando el caracter 
+, t1450, 1, t1450; // incremnetnado la pos del arreglo
+, t1456, 1, t1456; // incrementando la pos de la cadena
=>, t1456, t1457, heap; // sacandor el caracter del heap cadena
jmp, , , L504;
jmp, , , L507;
L507:
jmp, , , L505;
L505:
// ----------------- Resolviendo acceso local 
+, P, 3, t1458; // pos del objeto
=>, t1458, t1460, stack; //apuntador al heap del obejto
=>, t1460, t1461, heap; // recuperando pos incial del objeto
+, t1461, 4, t1460;
=>, t1460, t1462, heap; // valor a retoranar del acceso
+, P, 4, t1463;
=>, t1463, t1464, stack; 
=>, t1464, t1465, heap; 
=>, t1465, t1466, heap; // valor de size del arreglo ape
+, t1465, 1, t1467; // apuntador donde inicia el arreglo ape
=>, t1467, t1468, heap; // primer caracter del arreglo ape
+, H, 0, t1469;
+, H, 1, t1470;
<=, t1469, t1470, heap; 
+, H, 1, H;
+, 0, 0, t1471;
<=, H, t1471, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L508:
jne, t1468, 36, L509;
jmp, , , L510;
L509:
<=, H, t1468, heap; // ingresando el caracter 
+, H, 1, H;
+, t1471, 1, t1471; // incrementando en uno el size de la nueva cadena
+, t1467, 1, t1467;
=>, t1467, t1468, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L508;
L510:
<=, t1470, t1471, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
-, t1460, 1, t1472;
// -------------------- Arreglo global asignar :) 
=>, t1460, t1473, heap; // inicia el arreglo
=>, t1473, t1474, heap; // size del arreglo 
+, t1473, 1, t1475; //Pos 0 del arreglo
=>, t1469, t1476, heap; // pos que apunta al size de la cadena
=>, t1476, t1477, heap; // size de la cadena
+, t1476, 1, t1478; // Pos 0 de la cadena
=>, t1478, t1479, heap; // sacandor el caracter del heap cadena
jle, t1477, t1474, L511;
jmp, , , L512;
jmp, , , L511;
L511:
jne, t1479, 36, L513;
jmp, , , L514;
jmp, , , L513;
L513:
<=, t1475, t1479, heap; // guardando el caracter 
+, t1475, 1, t1475; // incremnetnado la pos del arreglo
+, t1478, 1, t1478; // incrementando la pos de la cadena
=>, t1478, t1479, heap; // sacandor el caracter del heap cadena
jmp, , , L511;
jmp, , , L514;
L514:
jmp, , , L512;
L512:
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t1480; // pos de bebe
=>, t1480, t1481, stack; // valor de lo que trae en el stack bebe
+, P, 5, t1482; // pos de retorno de a funcion Persona_Persona_reproducir_Persona_caracter
<=, t1482, t1481, stack; //asignando el retorno con su valor
jmp, , , L465;
jmp, , , L469; // salida del if
L471:

L469:
// RESOLVIENDO UN RETORNO

L465:
end, , Persona_Persona_reproducir_Persona_caracter




begin, , , Persona_vacio_matrimonio_Persona

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1483; // pos this 
=>, t1483, t1484, stack; // obtenido apuntador al heap 
=>, t1484, t1485, heap; // apuntador 
+, t1485, 2, t1486; // pos de genero
=>, t1486, t1487, heap; // obtengo el valor que se encuentre en el heap 
je, t1487, 70, L517;
jmp, , , L518;
L517:

// ------------------------ Creando arreglo local ape
+, P, 2, t1488; //pos de arreglo ape
<=, t1488, H, stack; // ingrensando al stack apunt del heap para ape
+, H, 1, t1489;
<=, H, t1489, heap; //insetnado donde inicia el arreglo ape
+, H, 1, H;
// calculando el tamanho del arreglo
-, 15, 1, t1490; //calculando el n real
-, t1490, 0, t1491; //iReal columna 0
+, t1491, 1, t1491; //size del arreglo ape
<=, H, t1491, heap; // insertando el tamanio del arreglo linealizado ape
+, H, 1, H;
+, h, t1491, h; // reservnado el espacio del arreglo ape
+, P, 2, t1494; // pos del arreglo 
=>, t1494, t1495, stack; //apuntador al heap del arreglo
=>, t1495, t1496, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1496, t1492, heap; // size del arreglo ape
+, t1496, 1, t1493; // pos 0 donde inicia el arreglo ape
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1497; // pos this 
=>, t1497, t1498, stack; // obtenido apuntador al heap 
=>, t1498, t1499, heap; // apuntador 
+, t1499, 4, t1500; // pos de apellido
=>, t1500, t1501, heap; // obtengo el valor que se encuentre en el heap 
+, P, 2, t1502;
=>, t1502, t1503, stack; 
=>, t1503, t1504, heap; 
=>, t1504, t1505, heap; // valor de size del arreglo ape
+, t1504, 1, t1506; // apuntador donde inicia el arreglo ape
=>, t1506, t1507, heap; // primer caracter del arreglo ape
+, H, 0, t1508;
+, H, 1, t1509;
<=, t1508, t1509, heap; 
+, H, 1, H;
+, 0, 0, t1510;
<=, H, t1510, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L519:
jne, t1507, 36, L520;
jmp, , , L521;
L520:
<=, H, t1507, heap; // ingresando el caracter 
+, H, 1, H;
+, t1510, 1, t1510; // incrementando en uno el size de la nueva cadena
+, t1506, 1, t1506;
=>, t1506, t1507, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L519;
L521:
<=, t1509, t1510, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// Resolviendo una cadena 
+, H, 0, t1511; //apuntaodr a cadena 
+, H, 1, t1512; //apu donde inicia la cadena
<=, t1511, t1512, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1513; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
//Iniciando a concatnar cadenas 
=>, t1508, t1514, heap;
=>, t1514, t1515, heap; // size cadena1
+, t1514, 1, t1516; // pos 0 de la cadena 1
=>, t1511, t1517, heap;
=>, t1517, t1518, heap; // size cadena2
+, t1517, 1, t1519; // pos 0 de la cadena 2
+, t1515, t1518, t1520; // size de la nueva cadena
=>, t1516, t1521, heap; // primer caracter de la cadena 1
=>, t1519, t1522, heap; // primer caracter de la cadena 2
+, H, 0, t1523; // posicion de retorno de la cadena
+, H, 1, t1524;
<=, t1523, t1524, heap;
+, H, 1, H;
<=, H, t1520, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L522;
L522:
jne, t1521, 36, L523;
jmp, , , L524;
jmp, , , L523;
L523:
<=, H, t1521, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1516, 1, t1516;
=>, t1516, t1521, heap;
jmp, , , L522;
jmp, , , L524;
L524:
jmp, , , L525;
L525:
jne, t1522, 36, L526;
jmp, , , L527;
jmp, , , L526;
L526:
<=, H, t1522, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1519, 1, t1519;
=>, t1519, t1522, heap;
jmp, , , L525;
jmp, , , L527;
L527:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t1527; // pos del arreglo 
=>, t1527, t1528, stack; //apuntador al heap del arreglo
=>, t1528, t1529, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1529, t1525, heap; // size del arreglo ape
+, t1529, 1, t1526; // pos 0 donde inicia el arreglo ape
=>, t1523, t1530, heap; // pos que apunta al size de la cadena
=>, t1530, t1531, heap; // size de la cadena
+, t1530, 1, t1532; // Pos 0 de la cadena
=>, t1532, t1533, heap; // sacandor el caracter del heap cadena
jle, t1531, t1525, L528;
jmp, , , L529;
jmp, , , L528;
L528:
jne, t1533, 36, L530;
jmp, , , L531;
jmp, , , L530;
L530:
<=, t1526, t1533, heap; // guardando el caracter 
+, t1526, 1, t1526; // incremnetnado la pos del arreglo
+, t1532, 1, t1532; // incrementando la pos de la cadena
=>, t1532, t1533, heap; // sacandor el caracter del heap cadena
jmp, , , L528;
jmp, , , L531;
L531:
jmp, , , L529;
L529:
+, P, 2, t1534;
=>, t1534, t1535, stack; 
=>, t1535, t1536, heap; 
=>, t1536, t1537, heap; // valor de size del arreglo ape
+, t1536, 1, t1538; // apuntador donde inicia el arreglo ape
=>, t1538, t1539, heap; // primer caracter del arreglo ape
+, H, 0, t1540;
+, H, 1, t1541;
<=, t1540, t1541, heap; 
+, H, 1, H;
+, 0, 0, t1542;
<=, H, t1542, heap; //asignanando temporalemnte size 0 de la cadena
+, H, 1, H;
L532:
jne, t1539, 36, L533;
jmp, , , L534;
L533:
<=, H, t1539, heap; // ingresando el caracter 
+, H, 1, H;
+, t1542, 1, t1542; // incrementando en uno el size de la nueva cadena
+, t1538, 1, t1538;
=>, t1538, t1539, heap; // obteniendio el nuevo caractere del arreglo
jmp, , , L532;
L534:
<=, t1541, t1542, heap; // ingresando el size de la nueva cadena 
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
<=, H, 36, heap; // ingresando el caracter de escape de la nueva cadena
+, H, 1, H;
// ----------------- Resolviendo acceso local 
+, P, 1, t1543; // pos del objeto
=>, t1543, t1545, stack; //apuntador al heap del obejto
=>, t1545, t1546, heap; // recuperando pos incial del objeto
+, t1546, 4, t1545;
=>, t1545, t1547, heap; // valor a retoranar del acceso
//------------------------------ Conversion cadena de la referencia ------------------------
+, H, 0, t1548;
+, H, 1, t1549;
<=, t1548, t1549, heap;
+, H, 1, H;
+, H, 1, H;
=>, t1545, t1550, heap; 
+, t1550, 1, t1551;
=>, t1551, t1552, heap; // caracter actual
+, 0, 0, t1553;
L535:
jne, t1552, 36, L536;
jmp, , , L537;
L536:
+, t1553, 1, t1553;
<=, H, t1552, heap;
+, H, 1, H;
+, t1551, 1, t1551;
=>, t1551, t1552, heap; // caracter actual
jmp, , , L535;
L537:
<=, H, 36, heap;
+, H, 1, H;
<=, t1549, t1553, heap;
//Iniciando a concatnar cadenas 
=>, t1540, t1554, heap;
=>, t1554, t1555, heap; // size cadena1
+, t1554, 1, t1556; // pos 0 de la cadena 1
=>, t1548, t1557, heap;
=>, t1557, t1558, heap; // size cadena2
+, t1557, 1, t1559; // pos 0 de la cadena 2
+, t1555, t1558, t1560; // size de la nueva cadena
=>, t1556, t1561, heap; // primer caracter de la cadena 1
=>, t1559, t1562, heap; // primer caracter de la cadena 2
+, H, 0, t1563; // posicion de retorno de la cadena
+, H, 1, t1564;
<=, t1563, t1564, heap;
+, H, 1, H;
<=, H, t1560, heap; //guardo el size de la nueva cadena
+, H, 1, H;
jmp, , , L538;
L538:
jne, t1561, 36, L539;
jmp, , , L540;
jmp, , , L539;
L539:
<=, H, t1561, heap; //asignando caracter a la nueva cadena de la cadena 1
+, H, 1, H;
+, t1556, 1, t1556;
=>, t1556, t1561, heap;
jmp, , , L538;
jmp, , , L540;
L540:
jmp, , , L541;
L541:
jne, t1562, 36, L542;
jmp, , , L543;
jmp, , , L542;
L542:
<=, H, t1562, heap; // ingresando caracter de la cadena 2
+, H, 1, H;
+, t1559, 1, t1559;
=>, t1559, t1562, heap;
jmp, , , L541;
jmp, , , L543;
L543:
<=, H, 36, heap; // apuntador final de la cadena
+, h, 1, h;
+, P, 2, t1567; // pos del arreglo 
=>, t1567, t1568, stack; //apuntador al heap del arreglo
=>, t1568, t1569, heap; // apuntador del heap al heap donde inicia la cadena
=>, t1569, t1565, heap; // size del arreglo ape
+, t1569, 1, t1566; // pos 0 donde inicia el arreglo ape
=>, t1563, t1570, heap; // pos que apunta al size de la cadena
=>, t1570, t1571, heap; // size de la cadena
+, t1570, 1, t1572; // Pos 0 de la cadena
=>, t1572, t1573, heap; // sacandor el caracter del heap cadena
jle, t1571, t1565, L544;
jmp, , , L545;
jmp, , , L544;
L544:
jne, t1573, 36, L546;
jmp, , , L547;
jmp, , , L546;
L546:
<=, t1566, t1573, heap; // guardando el caracter 
+, t1566, 1, t1566; // incremnetnado la pos del arreglo
+, t1572, 1, t1572; // incrementando la pos de la cadena
=>, t1572, t1573, heap; // sacandor el caracter del heap cadena
jmp, , , L544;
jmp, , , L547;
L547:
jmp, , , L545;
L545:
jmp, , , L516; // salida del if
L518:

L516:

L515:
end, , Persona_vacio_matrimonio_Persona




begin, , , Persona_vacio_nacer

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t1574; // pos this 
=>, t1574, t1575, stack; // obtenido apuntador al heap 
=>, t1575, t1576, heap; // apuntador 
+, t1576, 1, t1577; // pos de edad
=>, t1577, t1578, heap; // obtengo el valor que se encuentre en el heap 
<=, t1577, 0, HEAP; // asignando variable 
// Resolviendo una cadena 
+, H, 0, t1579; //apuntaodr a cadena 
+, H, 1, t1580; //apu donde inicia la cadena
<=, t1579, t1580, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 14, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t1581; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 115, heap; //guardadndo s
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 121, heap; //guardadndo y
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t1579);

L548:
end, , Persona_vacio_nacer


