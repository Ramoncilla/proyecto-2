

<<<<<<< HEAD
begin, , , Node_vacio_Node_entero

// Asignando atributo key
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de key
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de d
=>, t5, t6, stack; // valor de lo que trae en el stack d
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo height
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de height
<=, t10, 1, heap; //guardando en el heap el valor del atributo

L1:
end, , Node_vacio_Node_entero




begin, , , Avl_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t11; // pos de tree
<=, t11, h, stack; //guardando referencia del heap para el objeto tree
+, h, 1, t12; // guardo la posicion donde inicia el objeto 
<=, h, t12, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 1, h; // reservando espacio para el objeto tree
//Ingresando referencia al this del objeto tree
+, p, 0, t13; // pos de tree
=>, t13, t14, stack; // obteniendo apuntador de tree
+, p, 1, t15; // simulando cambio de ambito
+, t15, 0, t16; //pos del this de tree
<=, t16, t14, stack; // insertando apuntador del heap al stack del obeto tree
// No posee parametros 
+, p, 1, p; // simulando cambio de ambito
call, , , Tree_vacio_tree;
-, p, 1, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t17; // pos del objeto
=>, t17, t19, stack; //apuntador al heap del obejto
=>, t19, t20, heap; // recuperando pos incial del objeto
+, t20, 0, t19;
=>, t19, t21, heap; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 0, t22; // pos del objeto
=>, t22, t24, stack; //apuntador al heap del obejto
+, P, 6, t25;
+, t25, 0, t26;
<=, t26, t24, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 6, t27; // size de funcion actual
+, t27, 1, t28; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 0, t29; // pos del objeto
=>, t29, t31, stack; //apuntador al heap del obejto
=>, t31, t32, heap; // recuperando pos incial del objeto
+, t32, 0, t31;
=>, t31, t33, heap; // valor a retoranar del acceso
<=, t28, t33, stack; // asignado al stack el parametro
+, p, 6, t34; // size de funcion actual
+, t34, 2, t35; //pos del parametro 2
<=, t35, 10, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t36;
=>, t36, t37, stack; // valor del return
-, P, 6, P;
=>, t36, t38, stack; // valor a retoranar del acceso
<=, t19, t38, heap; // asignando variable 
print("%d", 9);
// ----------------- Resolviendo acceso local 
+, P, 0, t39; // pos del objeto
=>, t39, t41, stack; //apuntador al heap del obejto
=>, t41, t42, heap; // recuperando pos incial del objeto
+, t42, 0, t41;
=>, t41, t43, heap; // recuperando pos incial del objeto
+, t43, 0, t41;
=>, t41, t44, heap; // valor a retoranar del acceso
print("%d", t44);
// ----------------- Resolviendo acceso local 
+, P, 0, t45; // pos del objeto
=>, t45, t47, stack; //apuntador al heap del obejto
=>, t47, t48, heap; // recuperando pos incial del objeto
+, t48, 0, t47;
=>, t47, t49, heap; // recuperando pos incial del objeto
+, t49, 1, t47;
=>, t47, t50, heap; // valor a retoranar del acceso
print("%d", t50);
// Resolviendo una cadena 
+, H, 0, t51; //apuntaodr a cadena 
+, H, 1, t52; //apu donde inicia la cadena
<=, t51, t52, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t53; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t51);

L2:
end, , Avl_PRINCIPAL




begin, , , Tree_vacio_tree


L3:
end, , Tree_vacio_tree




begin, , , Tree_entero_height_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t54; // pos de N
=>, t54, t55, stack; // valor de lo que trae en el stack N
je, t55, 36, L6;
jmp, , , L7;
L6:

// RESOLVIENDO UN RETORNO
+, P, 2, t56; // pos de retorno de a funcion Tree_entero_height_Node
<=, t56, 0, stack; //asignando el retorno con su valor
jmp, , , L4;
jmp, , , L5; // salida del if
L7:

L5:
// RESOLVIENDO UN RETORNO
// ----------------- Resolviendo acceso local 
+, P, 1, t57; // pos del objeto
=>, t57, t59, stack; //apuntador al heap del obejto
=>, t59, t60, heap; // recuperando pos incial del objeto
+, t60, 1, t59;
=>, t59, t61, heap; // valor a retoranar del acceso
+, P, 2, t62; // pos de retorno de a funcion Tree_entero_height_Node
<=, t62, t61, stack; //asignando el retorno con su valor
jmp, , , L4;

L4:
end, , Tree_entero_height_Node




begin, , , Tree_entero_max_entero_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t63; // pos de a
=>, t63, t64, stack; // valor de lo que trae en el stack a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t65; // pos de b
=>, t65, t66, stack; // valor de lo que trae en el stack b
jg, t64, t66, L10;
jmp, , , L11;
L10:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t67; // pos de a
=>, t67, t68, stack; // valor de lo que trae en el stack a
+, P, 3, t69; // pos de retorno de a funcion Tree_entero_max_entero_entero
<=, t69, t68, stack; //asignando el retorno con su valor
jmp, , , L8;
jmp, , , L9; // salida del if
L11:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t70; // pos de b
=>, t70, t71, stack; // valor de lo que trae en el stack b
+, P, 3, t72; // pos de retorno de a funcion Tree_entero_max_entero_entero
<=, t72, t71, stack; //asignando el retorno con su valor
jmp, , , L8;
L9:

L8:
end, , Tree_entero_max_entero_entero




begin, , , Tree_Node_rightRotate_Node

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t73; // pos de x
// ----------------- Resolviendo acceso local 
+, P, 1, t74; // pos del objeto
=>, t74, t76, stack; //apuntador al heap del obejto
=>, t76, t77, heap; // recuperando pos incial del objeto
+, t77, 2, t76;
=>, t76, t78, heap; // valor a retoranar del acceso
<=, t73, t78, stack; // asignando a x
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t79; // pos de T2
// ----------------- Resolviendo acceso local 
+, P, 2, t80; // pos del objeto
=>, t80, t82, stack; //apuntador al heap del obejto
=>, t82, t83, heap; // recuperando pos incial del objeto
+, t83, 3, t82;
=>, t82, t84, heap; // valor a retoranar del acceso
<=, t79, t84, stack; // asignando a T2
// ----------------- Resolviendo acceso local 
+, P, 2, t85; // pos del objeto
=>, t85, t87, stack; //apuntador al heap del obejto
=>, t87, t88, heap; // recuperando pos incial del objeto
+, t88, 3, t87;
=>, t87, t89, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t90; // pos de y
=>, t90, t91, stack; // valor de lo que trae en el stack y
<=, t87, t91, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t92; // pos del objeto
=>, t92, t94, stack; //apuntador al heap del obejto
=>, t94, t95, heap; // recuperando pos incial del objeto
+, t95, 2, t94;
=>, t94, t96, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t97; // pos de T2
=>, t97, t98, stack; // valor de lo que trae en el stack T2
<=, t94, t98, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t99; // pos del objeto
=>, t99, t101, stack; //apuntador al heap del obejto
=>, t101, t102, heap; // recuperando pos incial del objeto
+, t102, 1, t101;
=>, t101, t103, heap; // valor a retoranar del acceso
+, P, 0, t104;
=>, t104, t105, stack; 
+, P, 5, t106;
+, t105, 0, t107;
<=, t106, t105, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t108; // size de funcion actual
+, t108, 1, t109; //pos del parametro 1
+, P, 0, t110;
=>, t110, t111, stack; 
+, P, 5, t112;
+, t111, 0, t113;
<=, t112, t111, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t114; // size de funcion actual
+, t114, 1, t115; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t116; // pos del objeto
=>, t116, t118, stack; //apuntador al heap del obejto
=>, t118, t119, heap; // recuperando pos incial del objeto
+, t119, 2, t118;
=>, t118, t120, heap; // valor a retoranar del acceso
<=, t115, t120, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t121;
=>, t121, t122, stack; // valor del return
-, P, 5, P;
<=, t109, t122, stack; // asignado al stack el parametro
+, p, 5, t123; // size de funcion actual
+, t123, 2, t124; //pos del parametro 2
+, P, 0, t125;
=>, t125, t126, stack; 
+, P, 5, t127;
+, t126, 0, t128;
<=, t127, t126, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t129; // size de funcion actual
+, t129, 1, t130; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t131; // pos del objeto
=>, t131, t133, stack; //apuntador al heap del obejto
=>, t133, t134, heap; // recuperando pos incial del objeto
+, t134, 3, t133;
=>, t133, t135, heap; // valor a retoranar del acceso
<=, t130, t135, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t136;
=>, t136, t137, stack; // valor del return
-, P, 5, P;
<=, t124, t137, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t138;
=>, t138, t139, stack; // valor del return
-, P, 5, P;
+, t139, 1, t140;
<=, t101, t140, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 2, t141; // pos del objeto
=>, t141, t143, stack; //apuntador al heap del obejto
=>, t143, t144, heap; // recuperando pos incial del objeto
+, t144, 1, t143;
=>, t143, t145, heap; // valor a retoranar del acceso
+, P, 0, t146;
=>, t146, t147, stack; 
+, P, 5, t148;
+, t147, 0, t149;
<=, t148, t147, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t150; // size de funcion actual
+, t150, 1, t151; //pos del parametro 1
+, P, 0, t152;
=>, t152, t153, stack; 
+, P, 5, t154;
+, t153, 0, t155;
<=, t154, t153, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t156; // size de funcion actual
+, t156, 1, t157; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t158; // pos del objeto
=>, t158, t160, stack; //apuntador al heap del obejto
=>, t160, t161, heap; // recuperando pos incial del objeto
+, t161, 2, t160;
=>, t160, t162, heap; // valor a retoranar del acceso
<=, t157, t162, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t163;
=>, t163, t164, stack; // valor del return
-, P, 5, P;
<=, t151, t164, stack; // asignado al stack el parametro
+, p, 5, t165; // size de funcion actual
+, t165, 2, t166; //pos del parametro 2
+, P, 0, t167;
=>, t167, t168, stack; 
+, P, 5, t169;
+, t168, 0, t170;
<=, t169, t168, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t171; // size de funcion actual
+, t171, 1, t172; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t173; // pos del objeto
=>, t173, t175, stack; //apuntador al heap del obejto
=>, t175, t176, heap; // recuperando pos incial del objeto
+, t176, 3, t175;
=>, t175, t177, heap; // valor a retoranar del acceso
<=, t172, t177, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t178;
=>, t178, t179, stack; // valor del return
-, P, 5, P;
<=, t166, t179, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t180;
=>, t180, t181, stack; // valor del return
-, P, 5, P;
+, t181, 1, t182;
<=, t143, t182, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t183; // pos de x
=>, t183, t184, stack; // valor de lo que trae en el stack x
+, P, 4, t185; // pos de retorno de a funcion Tree_Node_rightRotate_Node
<=, t185, t184, stack; //asignando el retorno con su valor
jmp, , , L12;

L12:
end, , Tree_Node_rightRotate_Node




begin, , , Tree_Node_leftRotate_Node

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t186; // pos de y
// ----------------- Resolviendo acceso local 
+, P, 1, t187; // pos del objeto
=>, t187, t189, stack; //apuntador al heap del obejto
=>, t189, t190, heap; // recuperando pos incial del objeto
+, t190, 3, t189;
=>, t189, t191, heap; // valor a retoranar del acceso
<=, t186, t191, stack; // asignando a y
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t192; // pos de T2
// ----------------- Resolviendo acceso local 
+, P, 2, t193; // pos del objeto
=>, t193, t195, stack; //apuntador al heap del obejto
=>, t195, t196, heap; // recuperando pos incial del objeto
+, t196, 2, t195;
=>, t195, t197, heap; // valor a retoranar del acceso
<=, t192, t197, stack; // asignando a T2
// ----------------- Resolviendo acceso local 
+, P, 2, t198; // pos del objeto
=>, t198, t200, stack; //apuntador al heap del obejto
=>, t200, t201, heap; // recuperando pos incial del objeto
+, t201, 2, t200;
=>, t200, t202, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t203; // pos de x
=>, t203, t204, stack; // valor de lo que trae en el stack x
<=, t200, t204, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t205; // pos del objeto
=>, t205, t207, stack; //apuntador al heap del obejto
=>, t207, t208, heap; // recuperando pos incial del objeto
+, t208, 3, t207;
=>, t207, t209, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t210; // pos de T2
=>, t210, t211, stack; // valor de lo que trae en el stack T2
<=, t207, t211, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t212; // pos del objeto
=>, t212, t214, stack; //apuntador al heap del obejto
=>, t214, t215, heap; // recuperando pos incial del objeto
+, t215, 1, t214;
=>, t214, t216, heap; // valor a retoranar del acceso
+, P, 0, t217;
=>, t217, t218, stack; 
+, P, 5, t219;
+, t218, 0, t220;
<=, t219, t218, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t221; // size de funcion actual
+, t221, 1, t222; //pos del parametro 1
+, P, 0, t223;
=>, t223, t224, stack; 
+, P, 5, t225;
+, t224, 0, t226;
<=, t225, t224, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t227; // size de funcion actual
+, t227, 1, t228; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t229; // pos del objeto
=>, t229, t231, stack; //apuntador al heap del obejto
=>, t231, t232, heap; // recuperando pos incial del objeto
+, t232, 2, t231;
=>, t231, t233, heap; // valor a retoranar del acceso
<=, t228, t233, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t234;
=>, t234, t235, stack; // valor del return
-, P, 5, P;
<=, t222, t235, stack; // asignado al stack el parametro
+, p, 5, t236; // size de funcion actual
+, t236, 2, t237; //pos del parametro 2
+, P, 0, t238;
=>, t238, t239, stack; 
+, P, 5, t240;
+, t239, 0, t241;
<=, t240, t239, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t242; // size de funcion actual
+, t242, 1, t243; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t244; // pos del objeto
=>, t244, t246, stack; //apuntador al heap del obejto
=>, t246, t247, heap; // recuperando pos incial del objeto
+, t247, 3, t246;
=>, t246, t248, heap; // valor a retoranar del acceso
<=, t243, t248, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t249;
=>, t249, t250, stack; // valor del return
-, P, 5, P;
<=, t237, t250, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t251;
=>, t251, t252, stack; // valor del return
-, P, 5, P;
+, t252, 1, t253;
<=, t214, t253, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 2, t254; // pos del objeto
=>, t254, t256, stack; //apuntador al heap del obejto
=>, t256, t257, heap; // recuperando pos incial del objeto
+, t257, 1, t256;
=>, t256, t258, heap; // valor a retoranar del acceso
+, P, 0, t259;
=>, t259, t260, stack; 
+, P, 5, t261;
+, t260, 0, t262;
<=, t261, t260, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t263; // size de funcion actual
+, t263, 1, t264; //pos del parametro 1
+, P, 0, t265;
=>, t265, t266, stack; 
+, P, 5, t267;
+, t266, 0, t268;
<=, t267, t266, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t269; // size de funcion actual
+, t269, 1, t270; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t271; // pos del objeto
=>, t271, t273, stack; //apuntador al heap del obejto
=>, t273, t274, heap; // recuperando pos incial del objeto
+, t274, 2, t273;
=>, t273, t275, heap; // valor a retoranar del acceso
<=, t270, t275, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t276;
=>, t276, t277, stack; // valor del return
-, P, 5, P;
<=, t264, t277, stack; // asignado al stack el parametro
+, p, 5, t278; // size de funcion actual
+, t278, 2, t279; //pos del parametro 2
+, P, 0, t280;
=>, t280, t281, stack; 
+, P, 5, t282;
+, t281, 0, t283;
<=, t282, t281, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t284; // size de funcion actual
+, t284, 1, t285; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t286; // pos del objeto
=>, t286, t288, stack; //apuntador al heap del obejto
=>, t288, t289, heap; // recuperando pos incial del objeto
+, t289, 3, t288;
=>, t288, t290, heap; // valor a retoranar del acceso
<=, t285, t290, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t291;
=>, t291, t292, stack; // valor del return
-, P, 5, P;
<=, t279, t292, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t293;
=>, t293, t294, stack; // valor del return
-, P, 5, P;
+, t294, 1, t295;
<=, t256, t295, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t296; // pos de y
=>, t296, t297, stack; // valor de lo que trae en el stack y
+, P, 4, t298; // pos de retorno de a funcion Tree_Node_leftRotate_Node
<=, t298, t297, stack; //asignando el retorno con su valor
jmp, , , L13;

L13:
end, , Tree_Node_leftRotate_Node




begin, , , Tree_entero_getBalance_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t299; // pos de N
=>, t299, t300, stack; // valor de lo que trae en el stack N
je, t300, 36, L16;
jmp, , , L17;
L16:

// RESOLVIENDO UN RETORNO
+, P, 2, t301; // pos de retorno de a funcion Tree_entero_getBalance_Node
<=, t301, 0, stack; //asignando el retorno con su valor
jmp, , , L14;
jmp, , , L15; // salida del if
L17:

L15:
// RESOLVIENDO UN RETORNO
+, P, 0, t302;
=>, t302, t303, stack; 
+, P, 3, t304;
+, t303, 0, t305;
<=, t304, t303, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t306; // size de funcion actual
+, t306, 1, t307; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t308; // pos del objeto
=>, t308, t310, stack; //apuntador al heap del obejto
=>, t310, t311, heap; // recuperando pos incial del objeto
+, t311, 2, t310;
=>, t310, t312, heap; // valor a retoranar del acceso
<=, t307, t312, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_entero_height_Node;
+, P, 2, t313;
=>, t313, t314, stack; // valor del return
-, P, 3, P;
+, P, 0, t315;
=>, t315, t316, stack; 
+, P, 3, t317;
+, t316, 0, t318;
<=, t317, t316, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t319; // size de funcion actual
+, t319, 1, t320; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t321; // pos del objeto
=>, t321, t323, stack; //apuntador al heap del obejto
=>, t323, t324, heap; // recuperando pos incial del objeto
+, t324, 3, t323;
=>, t323, t325, heap; // valor a retoranar del acceso
<=, t320, t325, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_entero_height_Node;
+, P, 2, t326;
=>, t326, t327, stack; // valor del return
-, P, 3, P;
-, t314, t327, t328;
+, P, 2, t329; // pos de retorno de a funcion Tree_entero_getBalance_Node
<=, t329, t328, stack; //asignando el retorno con su valor
jmp, , , L14;

L14:
end, , Tree_entero_getBalance_Node




begin, , , Tree_Node_insert_Node_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t330; // pos de node2
=>, t330, t331, stack; // valor de lo que trae en el stack node2
je, t331, 36, L20;
jmp, , , L21;
L20:

print("%d", 66);
// ----------- Instancia a una variable local --------------
+, p, 3, t332; // pos de o
<=, t332, h, stack; //guardando referencia del heap para el objeto o
+, h, 1, t333; // guardo la posicion donde inicia el objeto 
<=, h, t333, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 4, h; // reservando espacio para el objeto o
//Ingresando referencia al this del objeto o
+, p, 3, t334; // pos de o
=>, t334, t335, stack; // obteniendo apuntador de o
+, p, 6, t336; // simulando cambio de ambito
+, t336, 0, t337; //pos del this de o
<=, t337, t335, stack; // insertando apuntador del heap al stack del obeto o
// Asignando parametros  
+, p, 6, t338; // size de funcion actual
+, t338, 1, t339; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t340; // pos de key
=>, t340, t341, stack; // valor de lo que trae en el stack key
<=, t339, t341, stack; // asignado al stack el parametro
+, p, 6, p; // simulando cambio de ambito
call, , , Node_vacio_Node_entero;
-, p, 6, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 3, t342; // pos del objeto
=>, t342, t344, stack; //apuntador al heap del obejto
=>, t344, t345, heap; // recuperando pos incial del objeto
+, t345, 0, t344;
=>, t344, t346, heap; // valor a retoranar del acceso
print("%d", t346);
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t347; // pos de o
=>, t347, t348, stack; // valor de lo que trae en el stack o
+, P, 5, t349; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t349, t348, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L19; // salida del if
L21:

L19:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t350; // pos de key
=>, t350, t351, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t352; // pos del objeto
=>, t352, t354, stack; //apuntador al heap del obejto
=>, t354, t355, heap; // recuperando pos incial del objeto
+, t355, 0, t354;
=>, t354, t356, heap; // valor a retoranar del acceso
jl, t351, t356, L23;
jmp, , , L24;
L23:

// Resolviendo una cadena 
+, H, 0, t357; //apuntaodr a cadena 
+, H, 1, t358; //apu donde inicia la cadena
<=, t357, t358, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t359; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t357);
// ----------------- Resolviendo acceso local 
+, P, 1, t360; // pos del objeto
=>, t360, t362, stack; //apuntador al heap del obejto
=>, t362, t363, heap; // recuperando pos incial del objeto
+, t363, 2, t362;
=>, t362, t364, heap; // valor a retoranar del acceso
+, P, 0, t365;
=>, t365, t366, stack; 
+, P, 6, t367;
+, t366, 0, t368;
<=, t367, t366, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t369; // size de funcion actual
+, t369, 1, t370; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t371; // pos del objeto
=>, t371, t373, stack; //apuntador al heap del obejto
=>, t373, t374, heap; // recuperando pos incial del objeto
+, t374, 2, t373;
=>, t373, t375, heap; // valor a retoranar del acceso
<=, t370, t375, stack; // asignado al stack el parametro
+, p, 6, t376; // size de funcion actual
+, t376, 2, t377; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t378; // pos de key
=>, t378, t379, stack; // valor de lo que trae en el stack key
<=, t377, t379, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t380;
=>, t380, t381, stack; // valor del return
-, P, 6, P;
<=, t362, t381, heap; // asignando variable 
jmp, , , L22; // salida del if
L24:

// Resolviendo una cadena 
+, H, 0, t382; //apuntaodr a cadena 
+, H, 1, t383; //apu donde inicia la cadena
<=, t382, t383, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t384; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t382);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t385; // pos de key
=>, t385, t386, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t387; // pos del objeto
=>, t387, t389, stack; //apuntador al heap del obejto
=>, t389, t390, heap; // recuperando pos incial del objeto
+, t390, 0, t389;
=>, t389, t391, heap; // valor a retoranar del acceso
jg, t386, t391, L26;
jmp, , , L27;
L26:

// ----------------- Resolviendo acceso local 
+, P, 1, t392; // pos del objeto
=>, t392, t394, stack; //apuntador al heap del obejto
=>, t394, t395, heap; // recuperando pos incial del objeto
+, t395, 3, t394;
=>, t394, t396, heap; // valor a retoranar del acceso
+, P, 0, t397;
=>, t397, t398, stack; 
+, P, 6, t399;
+, t398, 0, t400;
<=, t399, t398, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t401; // size de funcion actual
+, t401, 1, t402; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t403; // pos del objeto
=>, t403, t405, stack; //apuntador al heap del obejto
=>, t405, t406, heap; // recuperando pos incial del objeto
+, t406, 3, t405;
=>, t405, t407, heap; // valor a retoranar del acceso
<=, t402, t407, stack; // asignado al stack el parametro
+, p, 6, t408; // size de funcion actual
+, t408, 2, t409; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t410; // pos de key
=>, t410, t411, stack; // valor de lo que trae en el stack key
<=, t409, t411, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t412;
=>, t412, t413, stack; // valor del return
-, P, 6, P;
<=, t394, t413, heap; // asignando variable 
jmp, , , L25; // salida del if
L27:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t414; // pos de node2
=>, t414, t415, stack; // valor de lo que trae en el stack node2
+, P, 5, t416; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t416, t415, stack; //asignando el retorno con su valor
jmp, , , L18;
L25:
L22:
// ----------------- Resolviendo acceso local 
+, P, 1, t417; // pos del objeto
=>, t417, t419, stack; //apuntador al heap del obejto
=>, t419, t420, heap; // recuperando pos incial del objeto
+, t420, 1, t419;
=>, t419, t421, heap; // valor a retoranar del acceso
+, P, 0, t422;
=>, t422, t423, stack; 
+, P, 6, t424;
+, t423, 0, t425;
<=, t424, t423, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t426; // size de funcion actual
+, t426, 1, t427; //pos del parametro 1
+, P, 0, t428;
=>, t428, t429, stack; 
+, P, 6, t430;
+, t429, 0, t431;
<=, t430, t429, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t432; // size de funcion actual
+, t432, 1, t433; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t434; // pos del objeto
=>, t434, t436, stack; //apuntador al heap del obejto
=>, t436, t437, heap; // recuperando pos incial del objeto
+, t437, 2, t436;
=>, t436, t438, heap; // valor a retoranar del acceso
<=, t433, t438, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_height_Node;
+, P, 2, t439;
=>, t439, t440, stack; // valor del return
-, P, 6, P;
<=, t427, t440, stack; // asignado al stack el parametro
+, p, 6, t441; // size de funcion actual
+, t441, 2, t442; //pos del parametro 2
+, P, 0, t443;
=>, t443, t444, stack; 
+, P, 6, t445;
+, t444, 0, t446;
<=, t445, t444, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t447; // size de funcion actual
+, t447, 1, t448; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t449; // pos del objeto
=>, t449, t451, stack; //apuntador al heap del obejto
=>, t451, t452, heap; // recuperando pos incial del objeto
+, t452, 3, t451;
=>, t451, t453, heap; // valor a retoranar del acceso
<=, t448, t453, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_height_Node;
+, P, 2, t454;
=>, t454, t455, stack; // valor del return
-, P, 6, P;
<=, t442, t455, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t456;
=>, t456, t457, stack; // valor del return
-, P, 6, P;
+, 1, t457, t458;
<=, t419, t458, heap; // asignando variable 
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t459; // pos de balance
+, P, 0, t460;
=>, t460, t461, stack; 
+, P, 6, t462;
+, t461, 0, t463;
<=, t462, t461, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t464; // size de funcion actual
+, t464, 1, t465; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t466; // pos de node2
=>, t466, t467, stack; // valor de lo que trae en el stack node2
<=, t465, t467, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_getBalance_Node;
+, P, 2, t468;
=>, t468, t469, stack; // valor del return
-, P, 6, P;
<=, t459, t469, stack; // asignando a balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t470; // pos de balance
=>, t470, t471, stack; // valor de lo que trae en el stack balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t472; // pos de key
=>, t472, t473, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t474; // pos del objeto
=>, t474, t476, stack; //apuntador al heap del obejto
=>, t476, t477, heap; // recuperando pos incial del objeto
+, t477, 2, t476;
=>, t476, t478, heap; // recuperando pos incial del objeto
+, t478, 0, t476;
=>, t476, t479, heap; // valor a retoranar del acceso
jg, t471, 1, L29;
jmp, , , L30;
L29:

jl, t473, t479, L31;
jmp, , , L32;

L31:

// RESOLVIENDO UN RETORNO
+, P, 0, t480;
=>, t480, t481, stack; 
+, P, 6, t482;
+, t481, 0, t483;
<=, t482, t481, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t484; // size de funcion actual
+, t484, 1, t485; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t486; // pos de node2
=>, t486, t487, stack; // valor de lo que trae en el stack node2
<=, t485, t487, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t488;
=>, t488, t489, stack; // valor del return
-, P, 6, P;
+, P, 5, t490; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t490, t489, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L28; // salida del if
L30:
L32:

L28:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t491; // pos de balance
=>, t491, t492, stack; // valor de lo que trae en el stack balance
*, 1, -1, t493;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t494; // pos de key
=>, t494, t495, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t496; // pos del objeto
=>, t496, t498, stack; //apuntador al heap del obejto
=>, t498, t499, heap; // recuperando pos incial del objeto
+, t499, 3, t498;
=>, t498, t500, heap; // recuperando pos incial del objeto
+, t500, 0, t498;
=>, t498, t501, heap; // valor a retoranar del acceso
jl, t492, t493, L34;
jmp, , , L35;
L34:

jg, t495, t501, L36;
jmp, , , L37;

L36:

// RESOLVIENDO UN RETORNO
+, P, 0, t502;
=>, t502, t503, stack; 
+, P, 6, t504;
+, t503, 0, t505;
<=, t504, t503, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t506; // size de funcion actual
+, t506, 1, t507; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t508; // pos de node2
=>, t508, t509, stack; // valor de lo que trae en el stack node2
<=, t507, t509, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t510;
=>, t510, t511, stack; // valor del return
-, P, 6, P;
+, P, 5, t512; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t512, t511, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L33; // salida del if
L35:
L37:

L33:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t513; // pos de balance
=>, t513, t514, stack; // valor de lo que trae en el stack balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t515; // pos de key
=>, t515, t516, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t517; // pos del objeto
=>, t517, t519, stack; //apuntador al heap del obejto
=>, t519, t520, heap; // recuperando pos incial del objeto
+, t520, 2, t519;
=>, t519, t521, heap; // recuperando pos incial del objeto
+, t521, 0, t519;
=>, t519, t522, heap; // valor a retoranar del acceso
jg, t514, 1, L39;
jmp, , , L40;
L39:

jg, t516, t522, L41;
jmp, , , L42;

L41:

// RESOLVIENDO UN RETORNO
+, P, 0, t523;
=>, t523, t524, stack; 
+, P, 6, t525;
+, t524, 0, t526;
<=, t525, t524, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t527; // size de funcion actual
+, t527, 1, t528; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t529; // pos de node2
=>, t529, t530, stack; // valor de lo que trae en el stack node2
<=, t528, t530, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t531;
=>, t531, t532, stack; // valor del return
-, P, 6, P;
+, P, 5, t533; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t533, t532, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L38; // salida del if
L40:
L42:

L38:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t534; // pos de balance
=>, t534, t535, stack; // valor de lo que trae en el stack balance
*, 1, -1, t536;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t537; // pos de key
=>, t537, t538, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t539; // pos del objeto
=>, t539, t541, stack; //apuntador al heap del obejto
=>, t541, t542, heap; // recuperando pos incial del objeto
+, t542, 3, t541;
=>, t541, t543, heap; // recuperando pos incial del objeto
+, t543, 0, t541;
=>, t541, t544, heap; // valor a retoranar del acceso
jl, t535, t536, L44;
jmp, , , L45;
L44:

jl, t538, t544, L46;
jmp, , , L47;

L46:

// ----------------- Resolviendo acceso local 
+, P, 1, t545; // pos del objeto
=>, t545, t547, stack; //apuntador al heap del obejto
=>, t547, t548, heap; // recuperando pos incial del objeto
+, t548, 3, t547;
=>, t547, t549, heap; // valor a retoranar del acceso
+, P, 0, t550;
=>, t550, t551, stack; 
+, P, 6, t552;
+, t551, 0, t553;
<=, t552, t551, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t554; // size de funcion actual
+, t554, 1, t555; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t556; // pos del objeto
=>, t556, t558, stack; //apuntador al heap del obejto
=>, t558, t559, heap; // recuperando pos incial del objeto
+, t559, 3, t558;
=>, t558, t560, heap; // valor a retoranar del acceso
<=, t555, t560, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t561;
=>, t561, t562, stack; // valor del return
-, P, 6, P;
<=, t547, t562, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
+, P, 0, t563;
=>, t563, t564, stack; 
+, P, 6, t565;
+, t564, 0, t566;
<=, t565, t564, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t567; // size de funcion actual
+, t567, 1, t568; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t569; // pos de node2
=>, t569, t570, stack; // valor de lo que trae en el stack node2
<=, t568, t570, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t571;
=>, t571, t572, stack; // valor del return
-, P, 6, P;
+, P, 5, t573; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t573, t572, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L43; // salida del if
L45:
L47:

L43:
// Resolviendo una cadena 
+, H, 0, t574; //apuntaodr a cadena 
+, H, 1, t575; //apu donde inicia la cadena
<=, t574, t575, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t576; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 40, heap; //guardadndo (
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t574);
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t577; // pos de node2
=>, t577, t578, stack; // valor de lo que trae en el stack node2
+, P, 5, t579; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t579, t578, stack; //asignando el retorno con su valor
jmp, , , L18;

L18:
end, , Tree_Node_insert_Node_entero




begin, , , Tree_vacio_postOrder_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t580; // pos de node2
=>, t580, t581, stack; // valor de lo que trae en el stack node2
jne, t581, 36, L50;
jmp, , , L51;
L50:

+, P, 0, t582;
=>, t582, t583, stack; 
+, P, 3, t584;
+, t583, 0, t585;
<=, t584, t583, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t586; // size de funcion actual
+, t586, 1, t587; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t588; // pos del objeto
=>, t588, t590, stack; //apuntador al heap del obejto
=>, t590, t591, heap; // recuperando pos incial del objeto
+, t591, 2, t590;
=>, t590, t592, heap; // valor a retoranar del acceso
<=, t587, t592, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_vacio_postOrder_Node;
+, P, 2, t593;
=>, t593, t594, stack; // valor del return
-, P, 3, P;
+, P, 0, t595;
=>, t595, t596, stack; 
+, P, 3, t597;
+, t596, 0, t598;
<=, t597, t596, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t599; // size de funcion actual
+, t599, 1, t600; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t601; // pos del objeto
=>, t601, t603, stack; //apuntador al heap del obejto
=>, t603, t604, heap; // recuperando pos incial del objeto
+, t604, 3, t603;
=>, t603, t605, heap; // valor a retoranar del acceso
<=, t600, t605, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_vacio_postOrder_Node;
+, P, 2, t606;
=>, t606, t607, stack; // valor del return
-, P, 3, P;
// ----------------- Resolviendo acceso local 
+, P, 1, t608; // pos del objeto
=>, t608, t610, stack; //apuntador al heap del obejto
=>, t610, t611, heap; // recuperando pos incial del objeto
+, t611, 0, t610;
=>, t610, t612, heap; // valor a retoranar del acceso
print("%d", t612);
jmp, , , L49; // salida del if
L51:

L49:

L48:
end, , Tree_vacio_postOrder_Node
=======
begin, , , prueba_PRINCIPAL

// Resolviendo una cadena 
+, H, 0, t1; //apuntaodr a cadena 
+, H, 1, t2; //apu donde inicia la cadena
<=, t1, t2, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t3; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 99, heap; //guardadndo c
+, H, 1, H;
<=, H, 107, heap; //guardadndo k
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 103, heap; //guardadndo g
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t1);

L1:
end, , prueba_PRINCIPAL
>>>>>>> refactor


