

begin, , , Node_vacio_Node_entero

// Asignando atributo key
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de key
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de d
=>, t5, t6, stack; // valor de lo que trae en el stack d
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo height
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de height
<=, t10, 1, heap; //guardando en el heap el valor del atributo

L1:
end, , Node_vacio_Node_entero




begin, , , Avl_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t11; // pos de arbol
<=, t11, h, stack; //guardando referencia del heap para el objeto arbol
+, h, 1, t12; // guardo la posicion donde inicia el objeto 
<=, h, t12, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 1, h; // reservando espacio para el objeto arbol
//Ingresando referencia al this del objeto arbol
+, p, 0, t13; // pos de arbol
=>, t13, t14, stack; // obteniendo apuntador de arbol
+, p, 1, t15; // simulando cambio de ambito
+, t15, 0, t16; //pos del this de arbol
<=, t16, t14, stack; // insertando apuntador del heap al stack del obeto arbol
// No posee parametros 
+, p, 1, p; // simulando cambio de ambito
call, , , Tree_vacio_tree;
-, p, 1, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t17; // pos del objeto
=>, t17, t19, stack; //apuntador al heap del obejto
=>, t19, t20, heap; // recuperando pos incial del objeto
+, t20, 0, t19;
=>, t19, t21, heap; // valor a retoranar del acceso
// ----------------- Resolviendo acceso local 
+, P, 0, t22; // pos del objeto
=>, t22, t24, stack; //apuntador al heap del obejto
+, P, 6, t25;
+, t25, 0, t26;
<=, t26, t24, stack; // pasadon como refeenria el valor del this
// Asignando parametros de llamada a funcion  
+, p, 6, t27; // size de funcion actual
+, t27, 1, t28; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 0, t29; // pos del objeto
=>, t29, t31, stack; //apuntador al heap del obejto
=>, t31, t32, heap; // recuperando pos incial del objeto
+, t32, 0, t31;
=>, t31, t33, heap; // valor a retoranar del acceso
<=, t28, t33, stack; // asignado al stack el parametro
+, p, 6, t34; // size de funcion actual
+, t34, 2, t35; //pos del parametro 2
<=, t35, 10, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t36;
=>, t36, t37, stack; // valor del return
-, P, 6, P;
=>, t36, t38, stack; // valor a retoranar del acceso
<=, t19, t38, heap; // asignando variable 

L2:
end, , Avl_PRINCIPAL




begin, , , Tree_vacio_tree


L3:
end, , Tree_vacio_tree




begin, , , Tree_entero_height_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t39; // pos de N
=>, t39, t40, stack; // valor de lo que trae en el stack N
je, t40, 36, L6;
jmp, , , L7;
L6:

// RESOLVIENDO UN RETORNO
+, P, 2, t41; // pos de retorno de a funcion Tree_entero_height_Node
<=, t41, 0, stack; //asignando el retorno con su valor
jmp, , , L4;
jmp, , , L5; // salida del if
L7:

L5:
// RESOLVIENDO UN RETORNO
// ----------------- Resolviendo acceso local 
+, P, 1, t42; // pos del objeto
=>, t42, t44, stack; //apuntador al heap del obejto
=>, t44, t45, heap; // recuperando pos incial del objeto
+, t45, 1, t44;
=>, t44, t46, heap; // valor a retoranar del acceso
+, P, 2, t47; // pos de retorno de a funcion Tree_entero_height_Node
<=, t47, t46, stack; //asignando el retorno con su valor
jmp, , , L4;

L4:
end, , Tree_entero_height_Node




begin, , , Tree_entero_max_entero_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t48; // pos de a
=>, t48, t49, stack; // valor de lo que trae en el stack a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t50; // pos de b
=>, t50, t51, stack; // valor de lo que trae en el stack b
jg, t49, t51, L10;
jmp, , , L11;
L10:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t52; // pos de a
=>, t52, t53, stack; // valor de lo que trae en el stack a
+, P, 3, t54; // pos de retorno de a funcion Tree_entero_max_entero_entero
<=, t54, t53, stack; //asignando el retorno con su valor
jmp, , , L8;
jmp, , , L9; // salida del if
L11:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t55; // pos de b
=>, t55, t56, stack; // valor de lo que trae en el stack b
+, P, 3, t57; // pos de retorno de a funcion Tree_entero_max_entero_entero
<=, t57, t56, stack; //asignando el retorno con su valor
jmp, , , L8;
L9:

L8:
end, , Tree_entero_max_entero_entero




begin, , , Tree_Node_rightRotate_Node

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t58; // pos de x
// ----------------- Resolviendo acceso local 
+, P, 1, t59; // pos del objeto
=>, t59, t61, stack; //apuntador al heap del obejto
=>, t61, t62, heap; // recuperando pos incial del objeto
+, t62, 2, t61;
=>, t61, t63, heap; // valor a retoranar del acceso
<=, t58, t63, stack; // asignando a x
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t64; // pos de T2
// ----------------- Resolviendo acceso local 
+, P, 2, t65; // pos del objeto
=>, t65, t67, stack; //apuntador al heap del obejto
=>, t67, t68, heap; // recuperando pos incial del objeto
+, t68, 3, t67;
=>, t67, t69, heap; // valor a retoranar del acceso
<=, t64, t69, stack; // asignando a T2
// ----------------- Resolviendo acceso local 
+, P, 2, t70; // pos del objeto
=>, t70, t72, stack; //apuntador al heap del obejto
=>, t72, t73, heap; // recuperando pos incial del objeto
+, t73, 3, t72;
=>, t72, t74, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t75; // pos de y
=>, t75, t76, stack; // valor de lo que trae en el stack y
<=, t72, t76, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t77; // pos del objeto
=>, t77, t79, stack; //apuntador al heap del obejto
=>, t79, t80, heap; // recuperando pos incial del objeto
+, t80, 2, t79;
=>, t79, t81, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t82; // pos de T2
=>, t82, t83, stack; // valor de lo que trae en el stack T2
<=, t79, t83, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t84; // pos del objeto
=>, t84, t86, stack; //apuntador al heap del obejto
=>, t86, t87, heap; // recuperando pos incial del objeto
+, t87, 1, t86;
=>, t86, t88, heap; // valor a retoranar del acceso
+, P, 0, t89;
=>, t89, t90, stack; 
+, P, 5, t91;
+, t90, 0, t92;
<=, t91, t90, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t93; // size de funcion actual
+, t93, 1, t94; //pos del parametro 1
+, P, 0, t95;
=>, t95, t96, stack; 
+, P, 5, t97;
+, t96, 0, t98;
<=, t97, t96, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t99; // size de funcion actual
+, t99, 1, t100; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t101; // pos del objeto
=>, t101, t103, stack; //apuntador al heap del obejto
=>, t103, t104, heap; // recuperando pos incial del objeto
+, t104, 2, t103;
=>, t103, t105, heap; // valor a retoranar del acceso
<=, t100, t105, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t106;
=>, t106, t107, stack; // valor del return
-, P, 5, P;
<=, t94, t107, stack; // asignado al stack el parametro
+, p, 5, t108; // size de funcion actual
+, t108, 2, t109; //pos del parametro 2
+, P, 0, t110;
=>, t110, t111, stack; 
+, P, 5, t112;
+, t111, 0, t113;
<=, t112, t111, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t114; // size de funcion actual
+, t114, 1, t115; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t116; // pos del objeto
=>, t116, t118, stack; //apuntador al heap del obejto
=>, t118, t119, heap; // recuperando pos incial del objeto
+, t119, 3, t118;
=>, t118, t120, heap; // valor a retoranar del acceso
<=, t115, t120, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t121;
=>, t121, t122, stack; // valor del return
-, P, 5, P;
<=, t109, t122, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t123;
=>, t123, t124, stack; // valor del return
-, P, 5, P;
+, t124, 1, t125;
<=, t86, t125, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 2, t126; // pos del objeto
=>, t126, t128, stack; //apuntador al heap del obejto
=>, t128, t129, heap; // recuperando pos incial del objeto
+, t129, 1, t128;
=>, t128, t130, heap; // valor a retoranar del acceso
+, P, 0, t131;
=>, t131, t132, stack; 
+, P, 5, t133;
+, t132, 0, t134;
<=, t133, t132, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t135; // size de funcion actual
+, t135, 1, t136; //pos del parametro 1
+, P, 0, t137;
=>, t137, t138, stack; 
+, P, 5, t139;
+, t138, 0, t140;
<=, t139, t138, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t141; // size de funcion actual
+, t141, 1, t142; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t143; // pos del objeto
=>, t143, t145, stack; //apuntador al heap del obejto
=>, t145, t146, heap; // recuperando pos incial del objeto
+, t146, 2, t145;
=>, t145, t147, heap; // valor a retoranar del acceso
<=, t142, t147, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t148;
=>, t148, t149, stack; // valor del return
-, P, 5, P;
<=, t136, t149, stack; // asignado al stack el parametro
+, p, 5, t150; // size de funcion actual
+, t150, 2, t151; //pos del parametro 2
+, P, 0, t152;
=>, t152, t153, stack; 
+, P, 5, t154;
+, t153, 0, t155;
<=, t154, t153, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t156; // size de funcion actual
+, t156, 1, t157; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t158; // pos del objeto
=>, t158, t160, stack; //apuntador al heap del obejto
=>, t160, t161, heap; // recuperando pos incial del objeto
+, t161, 3, t160;
=>, t160, t162, heap; // valor a retoranar del acceso
<=, t157, t162, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t163;
=>, t163, t164, stack; // valor del return
-, P, 5, P;
<=, t151, t164, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t165;
=>, t165, t166, stack; // valor del return
-, P, 5, P;
+, t166, 1, t167;
<=, t128, t167, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t168; // pos de x
=>, t168, t169, stack; // valor de lo que trae en el stack x
+, P, 4, t170; // pos de retorno de a funcion Tree_Node_rightRotate_Node
<=, t170, t169, stack; //asignando el retorno con su valor
jmp, , , L12;

L12:
end, , Tree_Node_rightRotate_Node




begin, , , Tree_Node_leftRotate_Node

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 2, t171; // pos de y
// ----------------- Resolviendo acceso local 
+, P, 1, t172; // pos del objeto
=>, t172, t174, stack; //apuntador al heap del obejto
=>, t174, t175, heap; // recuperando pos incial del objeto
+, t175, 3, t174;
=>, t174, t176, heap; // valor a retoranar del acceso
<=, t171, t176, stack; // asignando a y
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t177; // pos de T2
// ----------------- Resolviendo acceso local 
+, P, 2, t178; // pos del objeto
=>, t178, t180, stack; //apuntador al heap del obejto
=>, t180, t181, heap; // recuperando pos incial del objeto
+, t181, 2, t180;
=>, t180, t182, heap; // valor a retoranar del acceso
<=, t177, t182, stack; // asignando a T2
// ----------------- Resolviendo acceso local 
+, P, 2, t183; // pos del objeto
=>, t183, t185, stack; //apuntador al heap del obejto
=>, t185, t186, heap; // recuperando pos incial del objeto
+, t186, 2, t185;
=>, t185, t187, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t188; // pos de x
=>, t188, t189, stack; // valor de lo que trae en el stack x
<=, t185, t189, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t190; // pos del objeto
=>, t190, t192, stack; //apuntador al heap del obejto
=>, t192, t193, heap; // recuperando pos incial del objeto
+, t193, 3, t192;
=>, t192, t194, heap; // valor a retoranar del acceso
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t195; // pos de T2
=>, t195, t196, stack; // valor de lo que trae en el stack T2
<=, t192, t196, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 1, t197; // pos del objeto
=>, t197, t199, stack; //apuntador al heap del obejto
=>, t199, t200, heap; // recuperando pos incial del objeto
+, t200, 1, t199;
=>, t199, t201, heap; // valor a retoranar del acceso
+, P, 0, t202;
=>, t202, t203, stack; 
+, P, 5, t204;
+, t203, 0, t205;
<=, t204, t203, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t206; // size de funcion actual
+, t206, 1, t207; //pos del parametro 1
+, P, 0, t208;
=>, t208, t209, stack; 
+, P, 5, t210;
+, t209, 0, t211;
<=, t210, t209, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t212; // size de funcion actual
+, t212, 1, t213; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t214; // pos del objeto
=>, t214, t216, stack; //apuntador al heap del obejto
=>, t216, t217, heap; // recuperando pos incial del objeto
+, t217, 2, t216;
=>, t216, t218, heap; // valor a retoranar del acceso
<=, t213, t218, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t219;
=>, t219, t220, stack; // valor del return
-, P, 5, P;
<=, t207, t220, stack; // asignado al stack el parametro
+, p, 5, t221; // size de funcion actual
+, t221, 2, t222; //pos del parametro 2
+, P, 0, t223;
=>, t223, t224, stack; 
+, P, 5, t225;
+, t224, 0, t226;
<=, t225, t224, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t227; // size de funcion actual
+, t227, 1, t228; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t229; // pos del objeto
=>, t229, t231, stack; //apuntador al heap del obejto
=>, t231, t232, heap; // recuperando pos incial del objeto
+, t232, 3, t231;
=>, t231, t233, heap; // valor a retoranar del acceso
<=, t228, t233, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t234;
=>, t234, t235, stack; // valor del return
-, P, 5, P;
<=, t222, t235, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t236;
=>, t236, t237, stack; // valor del return
-, P, 5, P;
+, t237, 1, t238;
<=, t199, t238, heap; // asignando variable 
// ----------------- Resolviendo acceso local 
+, P, 2, t239; // pos del objeto
=>, t239, t241, stack; //apuntador al heap del obejto
=>, t241, t242, heap; // recuperando pos incial del objeto
+, t242, 1, t241;
=>, t241, t243, heap; // valor a retoranar del acceso
+, P, 0, t244;
=>, t244, t245, stack; 
+, P, 5, t246;
+, t245, 0, t247;
<=, t246, t245, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t248; // size de funcion actual
+, t248, 1, t249; //pos del parametro 1
+, P, 0, t250;
=>, t250, t251, stack; 
+, P, 5, t252;
+, t251, 0, t253;
<=, t252, t251, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t254; // size de funcion actual
+, t254, 1, t255; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t256; // pos del objeto
=>, t256, t258, stack; //apuntador al heap del obejto
=>, t258, t259, heap; // recuperando pos incial del objeto
+, t259, 2, t258;
=>, t258, t260, heap; // valor a retoranar del acceso
<=, t255, t260, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t261;
=>, t261, t262, stack; // valor del return
-, P, 5, P;
<=, t249, t262, stack; // asignado al stack el parametro
+, p, 5, t263; // size de funcion actual
+, t263, 2, t264; //pos del parametro 2
+, P, 0, t265;
=>, t265, t266, stack; 
+, P, 5, t267;
+, t266, 0, t268;
<=, t267, t266, stack; 
// Asignando parametros de llamada a funcion  
+, p, 5, t269; // size de funcion actual
+, t269, 1, t270; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 2, t271; // pos del objeto
=>, t271, t273, stack; //apuntador al heap del obejto
=>, t273, t274, heap; // recuperando pos incial del objeto
+, t274, 3, t273;
=>, t273, t275, heap; // valor a retoranar del acceso
<=, t270, t275, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_height_Node;
+, P, 2, t276;
=>, t276, t277, stack; // valor del return
-, P, 5, P;
<=, t264, t277, stack; // asignado al stack el parametro
+, P, 5, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t278;
=>, t278, t279, stack; // valor del return
-, P, 5, P;
+, t279, 1, t280;
<=, t241, t280, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t281; // pos de y
=>, t281, t282, stack; // valor de lo que trae en el stack y
+, P, 4, t283; // pos de retorno de a funcion Tree_Node_leftRotate_Node
<=, t283, t282, stack; //asignando el retorno con su valor
jmp, , , L13;

L13:
end, , Tree_Node_leftRotate_Node




begin, , , Tree_entero_getBalance_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t284; // pos de N
=>, t284, t285, stack; // valor de lo que trae en el stack N
je, t285, 36, L16;
jmp, , , L17;
L16:

// RESOLVIENDO UN RETORNO
+, P, 2, t286; // pos de retorno de a funcion Tree_entero_getBalance_Node
<=, t286, 0, stack; //asignando el retorno con su valor
jmp, , , L14;
jmp, , , L15; // salida del if
L17:

L15:
// RESOLVIENDO UN RETORNO
+, P, 0, t287;
=>, t287, t288, stack; 
+, P, 3, t289;
+, t288, 0, t290;
<=, t289, t288, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t291; // size de funcion actual
+, t291, 1, t292; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t293; // pos del objeto
=>, t293, t295, stack; //apuntador al heap del obejto
=>, t295, t296, heap; // recuperando pos incial del objeto
+, t296, 2, t295;
=>, t295, t297, heap; // valor a retoranar del acceso
<=, t292, t297, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_entero_height_Node;
+, P, 2, t298;
=>, t298, t299, stack; // valor del return
-, P, 3, P;
+, P, 0, t300;
=>, t300, t301, stack; 
+, P, 3, t302;
+, t301, 0, t303;
<=, t302, t301, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t304; // size de funcion actual
+, t304, 1, t305; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t306; // pos del objeto
=>, t306, t308, stack; //apuntador al heap del obejto
=>, t308, t309, heap; // recuperando pos incial del objeto
+, t309, 3, t308;
=>, t308, t310, heap; // valor a retoranar del acceso
<=, t305, t310, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_entero_height_Node;
+, P, 2, t311;
=>, t311, t312, stack; // valor del return
-, P, 3, P;
-, t299, t312, t313;
+, P, 2, t314; // pos de retorno de a funcion Tree_entero_getBalance_Node
<=, t314, t313, stack; //asignando el retorno con su valor
jmp, , , L14;

L14:
end, , Tree_entero_getBalance_Node




begin, , , Tree_Node_insert_Node_entero

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t315; // pos de node2
=>, t315, t316, stack; // valor de lo que trae en el stack node2
je, t316, 36, L20;
jmp, , , L21;
L20:

// ----------- Instancia a una variable local --------------
+, p, 3, t317; // pos de o
<=, t317, h, stack; //guardando referencia del heap para el objeto o
+, h, 1, t318; // guardo la posicion donde inicia el objeto 
<=, h, t318, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 4, h; // reservando espacio para el objeto o
//Ingresando referencia al this del objeto o
+, p, 3, t319; // pos de o
=>, t319, t320, stack; // obteniendo apuntador de o
+, p, 6, t321; // simulando cambio de ambito
+, t321, 0, t322; //pos del this de o
<=, t322, t320, stack; // insertando apuntador del heap al stack del obeto o
// Asignando parametros  
+, p, 6, t323; // size de funcion actual
+, t323, 1, t324; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t325; // pos de key
=>, t325, t326, stack; // valor de lo que trae en el stack key
<=, t324, t326, stack; // asignado al stack el parametro
+, p, 6, p; // simulando cambio de ambito
call, , , Node_vacio_Node_entero;
-, p, 6, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t327; // pos de o
=>, t327, t328, stack; // valor de lo que trae en el stack o
+, P, 5, t329; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t329, t328, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L19; // salida del if
L21:

L19:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t330; // pos de key
=>, t330, t331, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t332; // pos del objeto
=>, t332, t334, stack; //apuntador al heap del obejto
=>, t334, t335, heap; // recuperando pos incial del objeto
+, t335, 0, t334;
=>, t334, t336, heap; // valor a retoranar del acceso
jl, t331, t336, L23;
jmp, , , L24;
L23:

// Resolviendo una cadena 
+, H, 0, t337; //apuntaodr a cadena 
+, H, 1, t338; //apu donde inicia la cadena
<=, t337, t338, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 4, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t339; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t337);
// ----------------- Resolviendo acceso local 
+, P, 1, t340; // pos del objeto
=>, t340, t342, stack; //apuntador al heap del obejto
=>, t342, t343, heap; // recuperando pos incial del objeto
+, t343, 2, t342;
=>, t342, t344, heap; // valor a retoranar del acceso
+, P, 0, t345;
=>, t345, t346, stack; 
+, P, 6, t347;
+, t346, 0, t348;
<=, t347, t346, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t349; // size de funcion actual
+, t349, 1, t350; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t351; // pos del objeto
=>, t351, t353, stack; //apuntador al heap del obejto
=>, t353, t354, heap; // recuperando pos incial del objeto
+, t354, 2, t353;
=>, t353, t355, heap; // valor a retoranar del acceso
<=, t350, t355, stack; // asignado al stack el parametro
+, p, 6, t356; // size de funcion actual
+, t356, 2, t357; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t358; // pos de key
=>, t358, t359, stack; // valor de lo que trae en el stack key
<=, t357, t359, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t360;
=>, t360, t361, stack; // valor del return
-, P, 6, P;
<=, t342, t361, heap; // asignando variable 
jmp, , , L22; // salida del if
L24:

// Resolviendo una cadena 
+, H, 0, t362; //apuntaodr a cadena 
+, H, 1, t363; //apu donde inicia la cadena
<=, t362, t363, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 5, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t364; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 50, heap; //guardadndo 2
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t362);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t365; // pos de key
=>, t365, t366, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t367; // pos del objeto
=>, t367, t369, stack; //apuntador al heap del obejto
=>, t369, t370, heap; // recuperando pos incial del objeto
+, t370, 0, t369;
=>, t369, t371, heap; // valor a retoranar del acceso
jg, t366, t371, L26;
jmp, , , L27;
L26:

// ----------------- Resolviendo acceso local 
+, P, 1, t372; // pos del objeto
=>, t372, t374, stack; //apuntador al heap del obejto
=>, t374, t375, heap; // recuperando pos incial del objeto
+, t375, 3, t374;
=>, t374, t376, heap; // valor a retoranar del acceso
+, P, 0, t377;
=>, t377, t378, stack; 
+, P, 6, t379;
+, t378, 0, t380;
<=, t379, t378, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t381; // size de funcion actual
+, t381, 1, t382; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t383; // pos del objeto
=>, t383, t385, stack; //apuntador al heap del obejto
=>, t385, t386, heap; // recuperando pos incial del objeto
+, t386, 3, t385;
=>, t385, t387, heap; // valor a retoranar del acceso
<=, t382, t387, stack; // asignado al stack el parametro
+, p, 6, t388; // size de funcion actual
+, t388, 2, t389; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t390; // pos de key
=>, t390, t391, stack; // valor de lo que trae en el stack key
<=, t389, t391, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_insert_Node_entero;
+, P, 5, t392;
=>, t392, t393, stack; // valor del return
-, P, 6, P;
<=, t374, t393, heap; // asignando variable 
jmp, , , L25; // salida del if
L27:

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t394; // pos de node2
=>, t394, t395, stack; // valor de lo que trae en el stack node2
+, P, 5, t396; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t396, t395, stack; //asignando el retorno con su valor
jmp, , , L18;
L25:
L22:
// ----------------- Resolviendo acceso local 
+, P, 1, t397; // pos del objeto
=>, t397, t399, stack; //apuntador al heap del obejto
=>, t399, t400, heap; // recuperando pos incial del objeto
+, t400, 1, t399;
=>, t399, t401, heap; // valor a retoranar del acceso
+, P, 0, t402;
=>, t402, t403, stack; 
+, P, 6, t404;
+, t403, 0, t405;
<=, t404, t403, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t406; // size de funcion actual
+, t406, 1, t407; //pos del parametro 1
+, P, 0, t408;
=>, t408, t409, stack; 
+, P, 6, t410;
+, t409, 0, t411;
<=, t410, t409, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t412; // size de funcion actual
+, t412, 1, t413; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t414; // pos del objeto
=>, t414, t416, stack; //apuntador al heap del obejto
=>, t416, t417, heap; // recuperando pos incial del objeto
+, t417, 2, t416;
=>, t416, t418, heap; // valor a retoranar del acceso
<=, t413, t418, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_height_Node;
+, P, 2, t419;
=>, t419, t420, stack; // valor del return
-, P, 6, P;
<=, t407, t420, stack; // asignado al stack el parametro
+, p, 6, t421; // size de funcion actual
+, t421, 2, t422; //pos del parametro 2
+, P, 0, t423;
=>, t423, t424, stack; 
+, P, 6, t425;
+, t424, 0, t426;
<=, t425, t424, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t427; // size de funcion actual
+, t427, 1, t428; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t429; // pos del objeto
=>, t429, t431, stack; //apuntador al heap del obejto
=>, t431, t432, heap; // recuperando pos incial del objeto
+, t432, 3, t431;
=>, t431, t433, heap; // valor a retoranar del acceso
<=, t428, t433, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_height_Node;
+, P, 2, t434;
=>, t434, t435, stack; // valor del return
-, P, 6, P;
<=, t422, t435, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_max_entero_entero;
+, P, 3, t436;
=>, t436, t437, stack; // valor del return
-, P, 6, P;
+, 1, t437, t438;
<=, t399, t438, heap; // asignando variable 
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t439; // pos de balance
+, P, 0, t440;
=>, t440, t441, stack; 
+, P, 6, t442;
+, t441, 0, t443;
<=, t442, t441, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t444; // size de funcion actual
+, t444, 1, t445; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t446; // pos de node2
=>, t446, t447, stack; // valor de lo que trae en el stack node2
<=, t445, t447, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_entero_getBalance_Node;
+, P, 2, t448;
=>, t448, t449, stack; // valor del return
-, P, 6, P;
<=, t439, t449, stack; // asignando a balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t450; // pos de balance
=>, t450, t451, stack; // valor de lo que trae en el stack balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t452; // pos de key
=>, t452, t453, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t454; // pos del objeto
=>, t454, t456, stack; //apuntador al heap del obejto
=>, t456, t457, heap; // recuperando pos incial del objeto
+, t457, 2, t456;
=>, t456, t458, heap; // recuperando pos incial del objeto
+, t458, 0, t456;
=>, t456, t459, heap; // valor a retoranar del acceso
jg, t451, 1, L29;
jmp, , , L30;
L29:

jl, t453, t459, L31;
jmp, , , L32;

L31:

// RESOLVIENDO UN RETORNO
+, P, 0, t460;
=>, t460, t461, stack; 
+, P, 6, t462;
+, t461, 0, t463;
<=, t462, t461, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t464; // size de funcion actual
+, t464, 1, t465; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t466; // pos de node2
=>, t466, t467, stack; // valor de lo que trae en el stack node2
<=, t465, t467, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t468;
=>, t468, t469, stack; // valor del return
-, P, 6, P;
+, P, 5, t470; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t470, t469, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L28; // salida del if
L30:
L32:

L28:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t471; // pos de balance
=>, t471, t472, stack; // valor de lo que trae en el stack balance
*, 1, -1, t473;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t474; // pos de key
=>, t474, t475, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t476; // pos del objeto
=>, t476, t478, stack; //apuntador al heap del obejto
=>, t478, t479, heap; // recuperando pos incial del objeto
+, t479, 3, t478;
=>, t478, t480, heap; // recuperando pos incial del objeto
+, t480, 0, t478;
=>, t478, t481, heap; // valor a retoranar del acceso
jl, t472, t473, L34;
jmp, , , L35;
L34:

jg, t475, t481, L36;
jmp, , , L37;

L36:

// RESOLVIENDO UN RETORNO
+, P, 0, t482;
=>, t482, t483, stack; 
+, P, 6, t484;
+, t483, 0, t485;
<=, t484, t483, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t486; // size de funcion actual
+, t486, 1, t487; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t488; // pos de node2
=>, t488, t489, stack; // valor de lo que trae en el stack node2
<=, t487, t489, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t490;
=>, t490, t491, stack; // valor del return
-, P, 6, P;
+, P, 5, t492; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t492, t491, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L33; // salida del if
L35:
L37:

L33:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t493; // pos de balance
=>, t493, t494, stack; // valor de lo que trae en el stack balance
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t495; // pos de key
=>, t495, t496, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t497; // pos del objeto
=>, t497, t499, stack; //apuntador al heap del obejto
=>, t499, t500, heap; // recuperando pos incial del objeto
+, t500, 2, t499;
=>, t499, t501, heap; // recuperando pos incial del objeto
+, t501, 0, t499;
=>, t499, t502, heap; // valor a retoranar del acceso
jg, t494, 1, L39;
jmp, , , L40;
L39:

jg, t496, t502, L41;
jmp, , , L42;

L41:

// ----------------- Resolviendo acceso local 
+, P, 1, t503; // pos del objeto
=>, t503, t505, stack; //apuntador al heap del obejto
=>, t505, t506, heap; // recuperando pos incial del objeto
+, t506, 2, t505;
=>, t505, t507, heap; // valor a retoranar del acceso
+, P, 0, t508;
=>, t508, t509, stack; 
+, P, 6, t510;
+, t509, 0, t511;
<=, t510, t509, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t512; // size de funcion actual
+, t512, 1, t513; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t514; // pos del objeto
=>, t514, t516, stack; //apuntador al heap del obejto
=>, t516, t517, heap; // recuperando pos incial del objeto
+, t517, 2, t516;
=>, t516, t518, heap; // valor a retoranar del acceso
<=, t513, t518, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t519;
=>, t519, t520, stack; // valor del return
-, P, 6, P;
<=, t505, t520, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
+, P, 0, t521;
=>, t521, t522, stack; 
+, P, 6, t523;
+, t522, 0, t524;
<=, t523, t522, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t525; // size de funcion actual
+, t525, 1, t526; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t527; // pos de node2
=>, t527, t528, stack; // valor de lo que trae en el stack node2
<=, t526, t528, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t529;
=>, t529, t530, stack; // valor del return
-, P, 6, P;
+, P, 5, t531; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t531, t530, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L38; // salida del if
L40:
L42:

L38:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t532; // pos de balance
=>, t532, t533, stack; // valor de lo que trae en el stack balance
*, 1, -1, t534;
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t535; // pos de key
=>, t535, t536, stack; // valor de lo que trae en el stack key
// ----------------- Resolviendo acceso local 
+, P, 1, t537; // pos del objeto
=>, t537, t539, stack; //apuntador al heap del obejto
=>, t539, t540, heap; // recuperando pos incial del objeto
+, t540, 3, t539;
=>, t539, t541, heap; // recuperando pos incial del objeto
+, t541, 0, t539;
=>, t539, t542, heap; // valor a retoranar del acceso
jl, t533, t534, L44;
jmp, , , L45;
L44:

jl, t536, t542, L46;
jmp, , , L47;

L46:

// ----------------- Resolviendo acceso local 
+, P, 1, t543; // pos del objeto
=>, t543, t545, stack; //apuntador al heap del obejto
=>, t545, t546, heap; // recuperando pos incial del objeto
+, t546, 3, t545;
=>, t545, t547, heap; // valor a retoranar del acceso
+, P, 0, t548;
=>, t548, t549, stack; 
+, P, 6, t550;
+, t549, 0, t551;
<=, t550, t549, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t552; // size de funcion actual
+, t552, 1, t553; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t554; // pos del objeto
=>, t554, t556, stack; //apuntador al heap del obejto
=>, t556, t557, heap; // recuperando pos incial del objeto
+, t557, 3, t556;
=>, t556, t558, heap; // valor a retoranar del acceso
<=, t553, t558, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_rightRotate_Node;
+, P, 4, t559;
=>, t559, t560, stack; // valor del return
-, P, 6, P;
<=, t545, t560, heap; // asignando variable 
// RESOLVIENDO UN RETORNO
+, P, 0, t561;
=>, t561, t562, stack; 
+, P, 6, t563;
+, t562, 0, t564;
<=, t563, t562, stack; 
// Asignando parametros de llamada a funcion  
+, p, 6, t565; // size de funcion actual
+, t565, 1, t566; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t567; // pos de node2
=>, t567, t568, stack; // valor de lo que trae en el stack node2
<=, t566, t568, stack; // asignado al stack el parametro
+, P, 6, P;
call, , , Tree_Node_leftRotate_Node;
+, P, 4, t569;
=>, t569, t570, stack; // valor del return
-, P, 6, P;
+, P, 5, t571; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t571, t570, stack; //asignando el retorno con su valor
jmp, , , L18;
jmp, , , L43; // salida del if
L45:
L47:

L43:
// Resolviendo una cadena 
+, H, 0, t572; //apuntaodr a cadena 
+, H, 1, t573; //apu donde inicia la cadena
<=, t572, t573, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 8, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t574; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 113, heap; //guardadndo q
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 58, heap; //guardadndo :
+, H, 1, H;
<=, H, 40, heap; //guardadndo (
+, H, 1, H;
<=, H, 36, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
print("%s", t572);
// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t575; // pos de node2
=>, t575, t576, stack; // valor de lo que trae en el stack node2
+, P, 5, t577; // pos de retorno de a funcion Tree_Node_insert_Node_entero
<=, t577, t576, stack; //asignando el retorno con su valor
jmp, , , L18;

L18:
end, , Tree_Node_insert_Node_entero




begin, , , Tree_vacio_postOrder_Node

// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t578; // pos de node2
=>, t578, t579, stack; // valor de lo que trae en el stack node2
jne, t579, 36, L50;
jmp, , , L51;
L50:

+, P, 0, t580;
=>, t580, t581, stack; 
+, P, 3, t582;
+, t581, 0, t583;
<=, t582, t581, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t584; // size de funcion actual
+, t584, 1, t585; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t586; // pos del objeto
=>, t586, t588, stack; //apuntador al heap del obejto
=>, t588, t589, heap; // recuperando pos incial del objeto
+, t589, 2, t588;
=>, t588, t590, heap; // valor a retoranar del acceso
<=, t585, t590, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_vacio_postOrder_Node;
+, P, 2, t591;
=>, t591, t592, stack; // valor del return
-, P, 3, P;
+, P, 0, t593;
=>, t593, t594, stack; 
+, P, 3, t595;
+, t594, 0, t596;
<=, t595, t594, stack; 
// Asignando parametros de llamada a funcion  
+, p, 3, t597; // size de funcion actual
+, t597, 1, t598; //pos del parametro 1
// ----------------- Resolviendo acceso local 
+, P, 1, t599; // pos del objeto
=>, t599, t601, stack; //apuntador al heap del obejto
=>, t601, t602, heap; // recuperando pos incial del objeto
+, t602, 3, t601;
=>, t601, t603, heap; // valor a retoranar del acceso
<=, t598, t603, stack; // asignado al stack el parametro
+, P, 3, P;
call, , , Tree_vacio_postOrder_Node;
+, P, 2, t604;
=>, t604, t605, stack; // valor del return
-, P, 3, P;
// ----------------- Resolviendo acceso local 
+, P, 1, t606; // pos del objeto
=>, t606, t608, stack; //apuntador al heap del obejto
=>, t608, t609, heap; // recuperando pos incial del objeto
+, t609, 0, t608;
=>, t608, t610, heap; // valor a retoranar del acceso
print("%d", t610);
jmp, , , L49; // salida del if
L51:

L49:

L48:
end, , Tree_vacio_postOrder_Node


