

begin, , , llanta_vacio_llanta_entero_entero

// Asignando atributo valor1Llanta
+, p, 0, t1; //pos this 
=>, t1, t2, stack; // apuntador al heap
=>, t2, t3, heap; // apuntador donde inicia el objeto
+, t3, 0, t4; // pos real  de valor1Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t5; // pos de val1
=>, t5, t6, stack; // valor de lo que trae en el stack val1
<=, t4, t6, heap; //guardando en el heap el valor del atributo
// Asignando atributo valor2Llanta
+, p, 0, t7; //pos this 
=>, t7, t8, stack; // apuntador al heap
=>, t8, t9, heap; // apuntador donde inicia el objeto
+, t9, 1, t10; // pos real  de valor2Llanta
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t11; // pos de val2
=>, t11, t12, stack; // valor de lo que trae en el stack val2
<=, t10, t12, heap; //guardando en el heap el valor del atributo

L1:
end, , llanta_vacio_llanta_entero_entero




begin, , , llanta_vacio_mostrarVAlor1

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t13; // pos this 
=>, t13, t14, stack; // obtenido apuntador al heap 
=>, t14, t15, heap; // apuntador 
+, t15, 0, t16; // pos de valor1Llanta
=>, t16, t17, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t17);

L2:
end, , llanta_vacio_mostrarVAlor1




begin, , , llanta_vacio_mostrarVAlor2

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t18; // pos this 
=>, t18, t19, stack; // obtenido apuntador al heap 
=>, t19, t20, heap; // apuntador 
+, t20, 1, t21; // pos de valor2Llanta
=>, t21, t22, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t22);

L3:
end, , llanta_vacio_mostrarVAlor2




begin, , , carro_vacio_carro_caracter_entero

// Asignando atributo col
+, p, 0, t23; //pos this 
=>, t23, t24, stack; // apuntador al heap
=>, t24, t25, heap; // apuntador donde inicia el objeto
+, t25, 0, t26; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t27; // pos de color
=>, t27, t28, stack; // valor de lo que trae en el stack color
<=, t26, t28, heap; //guardando en el heap el valor del atributo
print("%c", 89);
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t29; // pos de rinLlanta
=>, t29, t30, stack; // valor de lo que trae en el stack rinLlanta
print("%d", t30);
// Asignando atributo valorCarro
+, p, 0, t31; //pos this 
=>, t31, t32, stack; // apuntador al heap
=>, t32, t33, heap; // apuntador donde inicia el objeto
+, t33, 2, t34; // pos real  de valorCarro
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t35; // pos de rinLlanta
=>, t35, t36, stack; // valor de lo que trae en el stack rinLlanta
<=, t34, t36, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t37;// pos this de lla1
=>, t37, t38, stack; //apuntador del heap de lla1
=>, t38, t39, heap; //posicion real del heap donde inicia lla1
+, t39, 1, t40; //pos real del atributo lla1
<=, t40, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t41;
=>, t41, t42, stack; //apuntador al heap de lla1
=>, t42, t43, heap; //posicion real donde incia el objeto lla1
+, t43, 1, t44; // pos real donde incial el objeto lla1

+, p, 4, t45; // tamanho de la funcion actual carro_vacio_carro_caracter_entero
+, t45, 0, t46; // pos del this para la nueva instancia de lla1
<=, t46, t44, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 4, t47; // size de funcion actual
+, t47, 1, t48; //pos del parametro 1
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t49; // pos de rinLlanta
=>, t49, t50, stack; // valor de lo que trae en el stack rinLlanta
*, t50, 2, t51;
<=, t48, t51, stack; // asignado al stack el parametro
+, p, 4, t52; // size de funcion actual
+, t52, 2, t53; //pos del parametro 2
// -------------- Resolviendo para un ID (var local) ------------
+, p, 2, t54; // pos de rinLlanta
=>, t54, t55, stack; // valor de lo que trae en el stack rinLlanta
*, t55, 3, t56;
<=, t53, t56, stack; // asignado al stack el parametro
+, p, 4, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 4, p; // regresando al ambito acutal


L4:
end, , carro_vacio_carro_caracter_entero




begin, , , carro_caracter_obtenerNombreCarro

// ------------------------ Creando arreglo local h
+, P, 1, t57; //pos de arreglo h
<=, t57, H, stack; // ingrensando al stack apunt del heap para h
+, H, 1, t58;
<=, H, t58, heap; //insetnado donde inicia el arreglo h
+, H, 1, H;
// calculando el tamanho del arreglo
-, 30, 1, t59; //calculando el n real
-, t59, 0, t60; //iReal columna 0
+, t60, 1, t60; //size del arreglo h
<=, H, t60, heap; // insertando el tamanio del arreglo linealizado h
+, H, 1, H;
+, h, t60, h; // reservnado el espacio del arreglo h
// Resolviendo una cadena 
+, H, 0, t61; //apuntaodr a cadena 
+, H, 1, t62; //apu donde inicia la cadena
<=, t61, t62, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 12, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t63; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 116, heap; //guardadndo t
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 1, t66; // pos del arreglo 
=>, t66, t67, stack; //apuntador al heap del arreglo
=>, t67, t68, heap; // apuntador del heap al heap donde inicia la cadena
=>, t68, t64, heap; // size del arreglo h
+, t68, 1, t65; // pos 0 donde inicia el arreglo h
=>, t61, t69, heap; // pos que apunta al size de la cadena
=>, t69, t70, heap; // size de la cadena
+, t69, 1, t71; // Pos 0 de la cadena
=>, t71, t72, heap; // sacandor el caracter del heap cadena
jle, t70, t64, L6;
jmp, , , L7;
jmp, , , L6;
L6:
jne, t72, 34, L8;
jmp, , , L9;
jmp, , , L8;
L8:
<=, t65, t72, heap; // guardando el caracter 
+, t65, 1, t65; // incremnetnado la pos del arreglo
+, t71, 1, t71; // incrementando la pos de la cadena
=>, t71, t72, heap; // sacandor el caracter del heap cadena
jmp, , , L6;
jmp, , , L9;
L9:
jmp, , , L7;
L7:
+, P, 1, t73; // pos de arreglo h
=>, t73, t74, stack; // apunt al heap de arreglo h
=>, t74, t75, heap; //apunt al heap donde inicia el arreglo h
=>, t75, t76, heap; //obteniendo el tamanio del arreglo h
+, t75, 1, t77; // pos 0 del arreglo h
// ---- Calculo de valor de las posiciones  
// -----------(Obteniendo valor) Calculo de iReal para el arreglo h
-, 4, 0, t78; //calculando el n real ()
-, t78, 0, t79; //iReal columna 0
+, t77, t79, t80; // pos buscada del arreglo  h
=>, t80, t81, heap; //valor que trae el objeto
print("%c", t81);
// RESOLVIENDO UN RETORNO
+, P, 1, t82; // pos de arreglo h
=>, t82, t83, stack; // apunt al heap de arreglo h
=>, t83, t84, heap; //apunt al heap donde inicia el arreglo h
=>, t84, t85, heap; //obteniendo el tamanio del arreglo h
+, t84, 1, t86; // pos 0 del arreglo h
// ---- Calculo de valor de las posiciones  
// -----------(Obteniendo valor) Calculo de iReal para el arreglo h
-, 8, 0, t87; //calculando el n real ()
-, t87, 0, t88; //iReal columna 0
+, t86, t88, t89; // pos buscada del arreglo  h
=>, t89, t90, heap; //valor que trae el objeto
+, P, 2, t91; // pos de retorno de a funcion carro_caracter_obtenerNombreCarro
<=, t91, t90, stack; //asignando el retorno con su valor
jmp, , , L5;

L5:
end, , carro_caracter_obtenerNombreCarro




begin, , , carro_caracter_obtenerColor

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t92; // pos this 
=>, t92, t93, stack; // obtenido apuntador al heap 
=>, t93, t94, heap; // apuntador 
+, t94, 0, t95; // pos de col
=>, t95, t96, heap; // obtengo el valor que se encuentre en el heap 
+, P, 1, t97; // pos de retorno de a funcion carro_caracter_obtenerColor
<=, t97, t96, stack; //asignando el retorno con su valor
jmp, , , L10;

L10:
end, , carro_caracter_obtenerColor




begin, , , carro_entero_obtenerValor

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t98; // pos this 
=>, t98, t99, stack; // obtenido apuntador al heap 
=>, t99, t100, heap; // apuntador 
+, t100, 2, t101; // pos de valorCarro
=>, t101, t102, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t102);
print("%c", 76);
// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t103; // pos this 
=>, t103, t104, stack; // obtenido apuntador al heap 
=>, t104, t105, heap; // apuntador 
+, t105, 2, t106; // pos de valorCarro
=>, t106, t107, heap; // obtengo el valor que se encuentre en el heap 
*, t107, 5, t108;
+, P, 1, t109; // pos de retorno de a funcion carro_entero_obtenerValor
<=, t109, t108, stack; //asignando el retorno con su valor
jmp, , , L11;

L11:
end, , carro_entero_obtenerValor




begin, , , carro_vacio_carro_caracter

// Asignando atributo col
+, p, 0, t110; //pos this 
=>, t110, t111, stack; // apuntador al heap
=>, t111, t112, heap; // apuntador donde inicia el objeto
+, t112, 0, t113; // pos real  de col
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t114; // pos de n
=>, t114, t115, stack; // valor de lo que trae en el stack n
<=, t113, t115, heap; //guardando en el heap el valor del atributo
// ----------- Instancia a un atributo --------------
+, p, 0, t116;// pos this de lla1
=>, t116, t117, stack; //apuntador del heap de lla1
=>, t117, t118, heap; //posicion real del heap donde inicia lla1
+, t118, 1, t119; //pos real del atributo lla1
<=, t119, h, heap; //guardando la pos real donde inicia el objeto lla1
+, h, 2, h; // reservando el espacio de memoria para el nuevo objeto lla1

// Guardando la referencia al this del objeto para la llamada al constructor lla1
+, p, 0, t120;
=>, t120, t121, stack; //apuntador al heap de lla1
=>, t121, t122, heap; //posicion real donde incia el objeto lla1
+, t122, 1, t123; // pos real donde incial el objeto lla1

+, p, 3, t124; // tamanho de la funcion actual carro_vacio_carro_caracter
+, t124, 0, t125; // pos del this para la nueva instancia de lla1
<=, t125, t123, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 3, t126; // size de funcion actual
+, t126, 1, t127; //pos del parametro 1
<=, t127, 10, stack; // asignado al stack el parametro
+, p, 3, t128; // size de funcion actual
+, t128, 2, t129; //pos del parametro 2
<=, t129, 20, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , llanta_vacio_llanta_entero_entero;
-, p, 3, p; // regresando al ambito acutal


L12:
end, , carro_vacio_carro_caracter




begin, , , carro_vacio_imprimir_Color

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t130; // pos this 
=>, t130, t131, stack; // obtenido apuntador al heap 
=>, t131, t132, heap; // apuntador 
+, t132, 0, t133; // pos de col
=>, t133, t134, heap; // obtengo el valor que se encuentre en el heap 
print("%c", t134);

L13:
end, , carro_vacio_imprimir_Color




begin, , , persona_PRINCIPAL

// ----------- Instancia a una variable local --------------
+, p, 0, t135; // pos de p1
<=, t135, h, stack; //guardando referencia del heap para el objeto p1
+, h, 1, t136; // guardo la posicion donde inicia el objeto 
<=, h, t136, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto p1
//Ingresando referencia al this del objeto p1
+, p, 0, t137; // pos de p1
=>, t137, t138, stack; // obteniendo apuntador de p1
+, p, 3, t139; // simulando cambio de ambito
+, t139, 0, t140; //pos del this de p1
<=, t140, t138, stack; // insertando apuntador del heap al stack del obeto p1
// Asignando parametros  
+, p, 3, t141; // size de funcion actual
+, t141, 1, t142; //pos del parametro 1
<=, t142, 25, stack; // asignado al stack el parametro
+, p, 3, t143; // size de funcion actual
+, t143, 2, t144; //pos del parametro 2
<=, t144, 80, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , persona_vacio_persona_entero_caracter;
-, p, 3, p; // regresando al ambito acutal

// ----------------- Resolviendo acceso local 
+, P, 0, t145; // pos del objeto
=>, t145, t147, stack; //apuntador al heap del obejto
+, P, 2, t148;
+, t148, 0, t149;
<=, t149, t147, stack; // pasadon como refeenria el valor del this
+, P, 2, P;
call, , , persona_entero_incrementarEdad;
+, P, 1, t150;
=>, t150, t151, stack; // valor del return
-, P, 2, P;
=>, t150, t152, stack; // valor a retoranar del acceso
print("%d", t152);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t153; // pos de valor1
// ----------------- Resolviendo acceso local 
+, P, 0, t154; // pos del objeto
=>, t154, t156, stack; //apuntador al heap del obejto
+, P, 3, t157;
+, t157, 0, t158;
<=, t158, t156, stack; // pasadon como refeenria el valor del this
+, P, 3, P;
call, , , persona_carro_retornoCarro;
+, P, 2, t159;
=>, t159, t160, stack; // valor del return
-, P, 3, P;
=>, t159, t161, stack; // recuperando pos incial del objeto 888
+, t161, 0, t159;
+, P, 3, t162;
+, t162, 0, t163;
<=, t163, t159, stack; // pasadon como refeenria el valor del this
+, P, 3, P;
call, , , carro_caracter_obtenerNombreCarro;
+, P, 2, t164;
=>, t164, t165, stack; // valor del return
-, P, 3, P;
=>, t164, t166, stack; // valor a retoranar del acceso
<=, t153, t166, stack; // asignando a valor1
// ------------------------ Creando arreglo local nombre
+, P, 2, t167; //pos de arreglo nombre
<=, t167, H, stack; // ingrensando al stack apunt del heap para nombre
+, H, 1, t168;
<=, H, t168, heap; //insetnado donde inicia el arreglo nombre
+, H, 1, H;
// calculando el tamanho del arreglo
-, 20, 1, t169; //calculando el n real
-, t169, 0, t170; //iReal columna 0
+, t170, 1, t170; //size del arreglo nombre
<=, H, t170, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, h, t170, h; // reservnado el espacio del arreglo nombre
// Resolviendo una cadena 
+, H, 0, t171; //apuntaodr a cadena 
+, H, 1, t172; //apu donde inicia la cadena
<=, t171, t172, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 12, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t173; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 65, heap; //guardadndo A
+, H, 1, H;
<=, H, 108, heap; //guardadndo l
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 85, heap; //guardadndo U
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
+, P, 2, t176; // pos del arreglo 
=>, t176, t177, stack; //apuntador al heap del arreglo
=>, t177, t178, heap; // apuntador del heap al heap donde inicia la cadena
=>, t178, t174, heap; // size del arreglo nombre
+, t178, 1, t175; // pos 0 donde inicia el arreglo nombre
=>, t171, t179, heap; // pos que apunta al size de la cadena
=>, t179, t180, heap; // size de la cadena
+, t179, 1, t181; // Pos 0 de la cadena
=>, t181, t182, heap; // sacandor el caracter del heap cadena
jle, t180, t174, L15;
jmp, , , L16;
jmp, , , L15;
L15:
jne, t182, 34, L17;
jmp, , , L18;
jmp, , , L17;
L17:
<=, t175, t182, heap; // guardando el caracter 
+, t175, 1, t175; // incremnetnado la pos del arreglo
+, t181, 1, t181; // incrementando la pos de la cadena
=>, t181, t182, heap; // sacandor el caracter del heap cadena
jmp, , , L15;
jmp, , , L18;
L18:
jmp, , , L16;
L16:
+, P, 2, t183; // pos de arreglo nombre
=>, t183, t184, stack; // apunt al heap de arreglo nombre
=>, t184, t185, heap; //apunt al heap donde inicia el arreglo nombre
=>, t185, t186, heap; //obteniendo el tamanio del arreglo nombre
+, t185, 1, t187; // pos 0 del arreglo nombre
// ---- Calculo de valor de las posiciones  
// -----------(Obteniendo valor) Calculo de iReal para el arreglo nombre
-, 8, 0, t188; //calculando el n real ()
-, t188, 0, t189; //iReal columna 0
+, t187, t189, t190; // pos buscada del arreglo  nombre
=>, t190, t191, heap; //valor que trae el objeto
print("%c", t191);
+, P, 2, t192; // pos de arreglo nombre
=>, t192, t193, stack; // apunt al heap de arreglo nombre
=>, t193, t194, heap; //apunt al heap donde inicia el arreglo nombre
=>, t194, t195, heap; //obteniendo el tamanio del arreglo nombre
+, t194, 1, t196; // pos 0 del arreglo nombre
// ---- Calculo de valor de las posiciones  
// -----------(Obteniendo valor) Calculo de iReal para el arreglo nombre
-, 4, 0, t197; //calculando el n real ()
-, t197, 0, t198; //iReal columna 0
+, t196, t198, t199; // pos buscada del arreglo  nombre
=>, t199, t200, heap; //valor que trae el objeto
print("%c", t200);
// ----------------- Resolviendo acceso local 
+, P, 0, t201; // pos del objeto
=>, t201, t203, stack; //apuntador al heap del obejto
//------------- Asignancio posicion de un arreglo Atributo  nombre
=>, t203, t205, heap; // obteniendo apuntador al heap del arreglo 
+, t205, 2, t204; // pos del arreglo dentro del heap acceso 
=>, t204, t206, heap; // apuntador donde inicia el arreglo
=>, t206, t207, heap; // size del arreglo nombre
+, t206, 1, t208; //pos 0 del arreglo nombre
// ----------- Calculo de iReal para el arreglo nombre
-, 4, 0, t209; //calculando el n real ()
-, t209, 0, t210; //iReal columna 0
+, t208, t210, t211; // pos buscade del arreglo atributo nombre
=>, t211, t212, heap; // valor a retoranar del acceso
print("%c", t212);

L14:
end, , persona_PRINCIPAL




begin, , , persona_vacio_molestar

// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t213; // pos this 
=>, t213, t214, stack; // obtenido apuntador al heap 
=>, t214, t215, heap; // apuntador 
+, t215, 0, t216; // pos de edad
=>, t216, t217, heap; // obtengo el valor que se encuentre en el heap 
print("%d", t217);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 1, t218; // pos de a
<=, t218, 189, stack; // asignando a a
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t219; // pos de a
=>, t219, t220, stack; // valor de lo que trae en el stack a
print("%d", t220);
// RESOLVIENDO UN RETORNO
jmp, , , L19;
print("%c", 84);

L19:
end, , persona_vacio_molestar




begin, , , persona_carro_obtenerCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t221; // pos de c
<=, t221, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t222; // guardo la posicion donde inicia el objeto 
<=, h, t222, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t223; // pos de c
=>, t223, t224, stack; // obteniendo apuntador de c
+, p, 3, t225; // simulando cambio de ambito
+, t225, 0, t226; //pos del this de c
<=, t226, t224, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t227; // size de funcion actual
+, t227, 1, t228; //pos del parametro 1
<=, t228, 72, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t229; // pos de c
=>, t229, t230, stack; // valor de lo que trae en el stack c
+, P, 2, t231; // pos de retorno de a funcion persona_carro_obtenerCarro
<=, t231, t230, stack; //asignando el retorno con su valor
jmp, , , L20;

L20:
end, , persona_carro_obtenerCarro




begin, , , persona_entero_obtenernUmero

// RESOLVIENDO UN RETORNO
*, 5, 8, t232;
+, P, 1, t233; // pos de retorno de a funcion persona_entero_obtenernUmero
<=, t233, t232, stack; //asignando el retorno con su valor
jmp, , , L21;

L21:
end, , persona_entero_obtenernUmero




begin, , , persona_vacio_persona_entero_caracter

// ----------------------- Creando arreglo atributo nombre
+, P, 0, t234; //pos this del arreglo
=>, t234, t235, stack; //obteniendo apuntador de arreglo en eel heap
=>, t235, t236, heap;//apuntando donde en verdad inicia el arreglo
+, t236, 2, t237; //pos del heap que guarda apuntador del heap para el arreglo nombre
<=, t237, H, heap; //escribiendo apunt del heap donde inicia el arreglo 
// REsolvemos tamanio del arreglo
-, 30, 1, t238; //calculando el n real
-, t238, 0, t239; //iReal columna 0
+, t239, 1, t239; //size del arreglo nombre
<=, H, t239, heap; // insertando el tamanio del arreglo linealizado nombre
+, H, 1, H;
+, t239, 0, t240; // anhadiendo una posicion mas
+, h, t240, h; // reservnado el espacio del arreglo nombre
+, P, 0, t243; // pos this del objeto 
=>, t243, t244, stack; // apuntador al heap del objeto 
=>, t244, t245, heap; // apunt al heap donde inica el objeto
+, t245, 2, t246; //apuntador a posicion donde incia el arreglo
=>, t246, t247, heap; // inicia el arreglo
=>, t247, t241, heap; // size del arreglo nombre
+, t247, 1, t242; //Pos 0 del arreglo
// Resolviendo una cadena 
+, H, 0, t248; //apuntaodr a cadena 
+, H, 1, t249; //apu donde inicia la cadena
<=, t248, t249, heap; //guaradnod donde inicia la cadena 
+, H, 1, H;
<=, H, 20, heap; //guardando el tamanio de la cadena
+, H, 1, H;
+, H, 0, t250; // referencia de donde iniciar el primer caracter de la cadena
<=, H, 80, heap; //guardadndo P
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 111, heap; //guardadndo o
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 67, heap; //guardadndo C
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 117, heap; //guardadndo u
+, H, 1, H;
<=, H, 122, heap; //guardadndo z
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 100, heap; //guardadndo d
+, H, 1, H;
<=, H, 101, heap; //guardadndo e
+, H, 1, H;
<=, H, 32, heap; //guardadndo  
+, H, 1, H;
<=, H, 85, heap; //guardadndo U
+, H, 1, H;
<=, H, 114, heap; //guardadndo r
+, H, 1, H;
<=, H, 98, heap; //guardadndo b
+, H, 1, H;
<=, H, 105, heap; //guardadndo i
+, H, 1, H;
<=, H, 110, heap; //guardadndo n
+, H, 1, H;
<=, H, 97, heap; //guardadndo a
+, H, 1, H;
<=, H, 34, heap; // ingresando caracter de escape de la cadena
+, H, 1, H;
=>, t248, t251, heap; // pos que apunta al size de la cadena
=>, t251, t252, heap; // size de la cadena
+, t251, 1, t253; // Pos 0 de la cadena
=>, t253, t254, heap; // sacandor el caracter del heap cadena
jle, t252, t241, L23;
jmp, , , L24;
jmp, , , L23;
L23:
jne, t254, 34, L25;
jmp, , , L26;
jmp, , , L25;
L25:
<=, t242, t254, heap; // guardando el caracter 
+, t242, 1, t242; // incremnetnado la pos del arreglo
+, t253, 1, t253; // incrementando la pos de la cadena
=>, t253, t254, heap; // sacandor el caracter del heap cadena
jmp, , , L23;
jmp, , , L26;
L26:
jmp, , , L24;
L24:
// Asignando atributo edad
+, p, 0, t255; //pos this 
=>, t255, t256, stack; // apuntador al heap
=>, t256, t257, heap; // apuntador donde inicia el objeto
+, t257, 0, t258; // pos real  de edad
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t259; // pos de val
=>, t259, t260, stack; // valor de lo que trae en el stack val
<=, t258, t260, heap; //guardando en el heap el valor del atributo
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t261; // pos this 
=>, t261, t262, stack; // obtenido apuntador al heap 
=>, t262, t263, heap; // apuntador 
+, t263, 0, t264; // pos de edad
=>, t264, t265, heap; // obtengo el valor que se encuentre en el heap 
+, t265, 10, t266;
print("%d", t266);
// ----------- Instancia a un atributo --------------
+, p, 0, t267;// pos this de car
=>, t267, t268, stack; //apuntador del heap de car
=>, t268, t269, heap; //posicion real del heap donde inicia car
+, t269, 1, t270; //pos real del atributo car
<=, t270, h, heap; //guardando la pos real donde inicia el objeto car
+, h, 3, h; // reservando el espacio de memoria para el nuevo objeto car

// Guardando la referencia al this del objeto para la llamada al constructor car
+, p, 0, t271;
=>, t271, t272, stack; //apuntador al heap de car
=>, t272, t273, heap; //posicion real donde incia el objeto car
+, t273, 1, t274; // pos real donde incial el objeto car

+, p, 7, t275; // tamanho de la funcion actual persona_vacio_persona_entero_caracter
+, t275, 0, t276; // pos del this para la nueva instancia de car
<=, t276, t274, stack; //guaradndo el puntero del this en el stack 

// Asignando parametros  
+, p, 7, t277; // size de funcion actual
+, t277, 1, t278; //pos del parametro 1
<=, t278, 70, stack; // asignado al stack el parametro
+, p, 7, t279; // size de funcion actual
+, t279, 2, t280; //pos del parametro 2
<=, t280, 126, stack; // asignado al stack el parametro
+, p, 7, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter_entero;
-, p, 7, p; // regresando al ambito acutal

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 3, t281; // pos de color
// Resolviendo un acceso para un atrinuto
+, P, 0, t282; 
=>, t282, t283, stack; // apuntador al heap
=>, t283, t284, heap;
+, t284, 1, t286; 
+, P, 2, t287;
+, t287, 0, t288;
<=, t288, t286, stack; // pasadon como refeenria el valor del this
+, P, 2, P;
call, , , carro_caracter_obtenerColor;
+, P, 1, t289;
=>, t289, t290, stack; // valor del return
-, P, 2, P;
=>, t289, t291, stack; // valor a retoranar del acceso
<=, t281, t291, stack; // asignando a color
// -------------- Resolviendo para un ID (var local) ------------
+, p, 3, t292; // pos de color
=>, t292, t293, stack; // valor de lo que trae en el stack color
print("%c", t293);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t294; // pos de i
<=, t294, 0, stack; // asignando a i
// Resolviendo un repetur mientras
jmp, , ,L27; //regresando a la etiqueral del ciclo repetir- mientras
L27:
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t295; // pos de i
=>, t295, t296, stack; // valor de lo que trae en el stack i
// Resolviendo un acceso para un atrinuto
+, P, 0, t297; 
=>, t297, t298, stack; // apuntador al heap
=>, t298, t299, heap;
+, t299, 2, t301; 
=>, t301, t302, heap; // recuperando pos incial del objeto
=>, t302, t303, heap; // obteneindio el size del arreglo 
jl, t296, t303, L28;
jmp, , , L29;
L28:

//------------- Asignancio posicion de un arreglo Atributo  nombre
+, P, 0, t305; // pos this del objeto 
=>, t305, t306, stack; // apunt del heap para le objeto
=>, t306, t307, heap; // apunt donde inicia el objeto
+, t307, 2, t304; // pos del arreglo dentro del heap 
=>, t304, t308, heap; // apuntador donde inicia el arreglo
=>, t308, t309, heap; // size del arreglo nombre
+, t308, 1, t310; //pos 0 del arreglo nombre
// -------------- Resolviendo para un ID (var local) ------------
+, p, 4, t311; // pos de i
=>, t311, t312, stack; // valor de lo que trae en el stack i
// ----------- Calculo de iReal para el arreglo nombre
-, t312, 0, t313; //calculando el n real ()
-, t313, 0, t314; //iReal columna 0
+, t310, t314, t315; // pos buscade del arreglo atributo nombre
=>, t315, t316, heap; //valor que trae el objeto
print("%c", t316);
// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 4, t317; // pos de i
=>, t317, t318, stack; //obtenidoe el valor de i
+, t318, 1, t319;
<=, t317, t319, stack; // asignando a i
jmp, , ,L27; //regresando a la etiqueral del ciclo repetir mientras
L29:

// -------------- Resolviendo para un ID (var local) Asignacion ------------
+, p, 5, t320; // pos de g
+, P, 0, t321;
=>, t321, t322, stack; 
+, P, 7, t323;
+, t322, 0, t324;
<=, t323, t322, stack; 
+, P, 7, P;
call, , , persona_caracter_obtenerChar;
+, P, 1, t325;
=>, t325, t326, stack; // valor del return
-, P, 7, P;
<=, t320, t326, stack; // asignando a g
// -------------- Resolviendo para un ID (var local) ------------
+, p, 5, t327; // pos de g
=>, t327, t328, stack; // valor de lo que trae en el stack g
print("%c", t328);

L22:
end, , persona_vacio_persona_entero_caracter




begin, , , persona_caracter_obtenerChar

// RESOLVIENDO UN RETORNO
+, P, 1, t329; // pos de retorno de a funcion persona_caracter_obtenerChar
<=, t329, 75, stack; //asignando el retorno con su valor
jmp, , , L30;

L30:
end, , persona_caracter_obtenerChar




begin, , , persona_carro_retornoCarro

// ----------- Instancia a una variable local --------------
+, p, 1, t330; // pos de c
<=, t330, h, stack; //guardando referencia del heap para el objeto c
+, h, 1, t331; // guardo la posicion donde inicia el objeto 
<=, h, t331, heap; // guardando donde es que inicia el objeto dentro del heap
+, h, 1, h; // sumando al heap la posicion que usamos extra para el doble apuntador 
+, h, 3, h; // reservando espacio para el objeto c
//Ingresando referencia al this del objeto c
+, p, 1, t332; // pos de c
=>, t332, t333, stack; // obteniendo apuntador de c
+, p, 3, t334; // simulando cambio de ambito
+, t334, 0, t335; //pos del this de c
<=, t335, t333, stack; // insertando apuntador del heap al stack del obeto c
// Asignando parametros  
+, p, 3, t336; // size de funcion actual
+, t336, 1, t337; //pos del parametro 1
<=, t337, 82, stack; // asignado al stack el parametro
+, 5, 5, t340;
*, t340, 2, t341;
+, p, 3, t338; // size de funcion actual
+, t338, 2, t339; //pos del parametro 2
<=, t339, t341, stack; // asignado al stack el parametro
+, p, 3, p; // simulando cambio de ambito
call, , , carro_vacio_carro_caracter_entero;
-, p, 3, p; // regresando al ambito acutal

// RESOLVIENDO UN RETORNO
// -------------- Resolviendo para un ID (var local) ------------
+, p, 1, t342; // pos de c
=>, t342, t343, stack; // valor de lo que trae en el stack c
+, P, 2, t344; // pos de retorno de a funcion persona_carro_retornoCarro
<=, t344, t343, stack; //asignando el retorno con su valor
jmp, , , L31;

L31:
end, , persona_carro_retornoCarro




begin, , , persona_entero_incrementarEdad

// RESOLVIENDO UN RETORNO
// ------------ Resolviendo un ID (atributo) -----------
+, p, 0, t345; // pos this 
=>, t345, t346, stack; // obtenido apuntador al heap 
=>, t346, t347, heap; // apuntador 
+, t347, 0, t348; // pos de edad
=>, t348, t349, heap; // obtengo el valor que se encuentre en el heap 
+, t349, 1, t350;
+, P, 1, t351; // pos de retorno de a funcion persona_entero_incrementarEdad
<=, t351, t350, stack; //asignando el retorno con su valor
jmp, , , L32;

L32:
end, , persona_entero_incrementarEdad


